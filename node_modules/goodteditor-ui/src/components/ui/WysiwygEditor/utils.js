import { ToolsMap } from './tools-and-commands';

/**
 * @typedef {import('./constants').ToolDef} Tool
 * @typedef {import('./constants').CommandDef} Command
 * @typedef {Object} ToolGroup
 * @property {string} title
 * @property {string[]} group
 */

/**
 * @param {ToolGroup[]} toolGroups
 * @return {{title:string, group: Tool[]}[]}
 */
export const buildToolGroups = (toolGroups) => {
    const toolsFlatted = toolGroups.flatMap(({ group }) => group);
    const availableTools = Object
        .values(ToolsMap)
        .filter(({ name: toolName }) => toolsFlatted.some(
            (tool) => typeof tool === 'string' ? toolName === tool : tool?.name === toolName)
        );
    
    /**
     * @param {Tool[]} toolsGroup
     * @return Tool[]
     */
    const populateToolsGroup = (toolsGroup) =>
        toolsGroup.reduce((acc, tool) => {
            const { name = tool, ...rest } = typeof tool === 'string' ? {} : tool;
            const foundTool = availableTools.find(({ name: toolName }) => toolName === name);
            
            return [...acc, { ...foundTool, ...rest }];
        }, []);
    return toolGroups.reduce((acc, { group, title }) => [...acc, { title, group: populateToolsGroup(group) }], []);
};

/**
 * @param {Tool|Command} value
 * @param {Record<string, any>} context
 * @return {Tool|Command}
 */
export const bindContext = (value, context) => {
    if (value == null || typeof value !== 'object') {
        return value;
    }
    
    return Object.entries(value).reduce((acc, [propName, propValue]) => {
        if (typeof propValue === 'function') {
            return { ...acc, [propName]: propValue.bind(context) };
        }
        
        if (Array.isArray(propValue)) {
            return { ...acc, [propName]: propValue.map((childProp) => bindContext(childProp, context)) };
        }
        
        return { ...acc, [propName]: propValue };
    }, {});
};
