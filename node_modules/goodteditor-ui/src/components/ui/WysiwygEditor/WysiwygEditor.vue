<template>
    <div class="d-flex flex-col">
        <div ref="menu" :class="{ bubble: bubbleMenu, 'mar-bot-l1': !bubbleMenu }" class="editor-toolbar">
            <!--
            @slot Toolbar slot
            @binding {title: string, group: Tool[]} toolGroups      array of using tools
            @binding {Function} buildToolBinds                      build tool binds function(tool:Tool)
            -->
            <slot v-if="editor != null" name="toolbar" v-bind="{ toolGroups, buildToolBinds }">
                <div class="row row-gap-l1">
                    <div
                        v-for="({ title, group }, groupIndex) of toolGroups"
                        :key="groupIndex"
                        class="col col-vbot col-auto">
                        <div class="d-flex flex-col flex-v-center">
                            <div v-if="resolveGroupTitle(title, groupIndex) !== ''" class="group-header">
                                <!--
                                @slot Group header slot
                                @binding {number} groupIndex                index of the tools group
                                @binding {string} title                     tools group title
                                -->
                                <slot name="group-header" v-bind="{ groupIndex, title }">
                                    <div class="text-small text-center">{{ resolveGroupTitle(title, groupIndex) }}</div>
                                </slot>
                            </div>
                            <div>
                                <div v-for="tool of group" :key="tool.name" class="tool d-inline-block">
                                    <!--
                                    @slot Tool slot
                                    @binding {Tool} tool         tool's already bound to editor context
                                    -->
                                    <slot name="tool" v-bind="{ tool: buildToolBinds(tool) }">
                                        <component :is="tool.render" :tool="buildToolBinds(tool)" />
                                    </slot>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </slot>
        </div>
        <div class="editor-content flex-grow d-flex">
            <editor-content :editor="editor" class="w-100"/>
        </div>
    </div>
</template>

<script>
import { Editor, EditorContent } from '@tiptap/vue-2';

import { debounce } from '../utils/Helpers';
import { resolveExtensions } from './extensions';
import { buildToolGroups, bindContext } from './utils';
import { DefaultTools, WysiwygAutofocus, EMPTY_PTAG_REGEXP } from './constants';

/**
 * @typedef {import('@tiptap/core').EditorEvents} EditorEvents
 * @typedef {Omit<import('@tiptap/extension-bubble-menu').BubbleMenuOptions, 'element'>} BubbleMenuOptions
 * @typedef {import('vue').PropOptions.<Boolean|BubbleMenuOptions>} BubbleMenuOptionsProp
 * @typedef {import('./constants').ITool} ITool
 */

export default {
    components: {
        EditorContent
    },
    props: {
        /**
         * @model
         */
        value: {
            type: String,
            default: '',
        },
        /**
         * array of using tools: { title: string, group: Array<string|ITool> }
         */
        tools: {
            type: Array,
            default: () => DefaultTools,
            validator: (tools) => tools.every((tool) => typeof tool === 'object' && Array.isArray(tool) === false)
        },
        /**
         * @public
         * func allows to receive image url from the environment
         */
        getImageUrl: {
            type: Function,
            default: async () => {}
        },
        /**
         * bubble menu options
         * @type {BubbleMenuOptionsProp}
         * @see See [Bubble menu settings](https://tiptap.dev/docs/editor/api/extensions/bubble-menu#settings)
         */
        bubbleMenu: {
            type: [Boolean, Object],
            default: false
        },
        /**
         * whether the outline of the focused content editor should be visible
         */
        focusVisible: {
            type: Boolean,
            default: true
        },
        /**
         * whether to force the cursor to jump in the editor on initialization
         */
        autofocus: {
            type: [Boolean, String, Number],
            default: WysiwygAutofocus.END
        },
        /**
         * Editor content options for styling css/style
         * { class: string[]|Record<string, boolean> style: string }
         */
        editorContent: {
            type: Object,
            default() {
                return { class: {}, style: '' };
            },
        },
    },
    data: () => ({
        /** @type {Editor} */
        editor: null,
        caretPosition: 0
    }),
    computed: {
        /**
         * @return {string}
         */
        content() {
            const html = this.editor?.getHTML() ?? '';
            return EMPTY_PTAG_REGEXP.test(html) ? '' : html;
        },
        /**
         * @return {{title: string, group: ITool[]}[]}
         */
        toolGroups() {
            return buildToolGroups(this.tools);
        },
        editorClass() {
            const { editorContent: { class: editorClass }, focusVisible } = this;
            const classes = Array.isArray(editorClass)
                ? editorClass
                : Object.entries(editorClass).filter(([, value]) => Boolean(value)).map(([key]) => key);

            if (focusVisible === false) {
                classes.push('focus-outline-none');
            }

            return classes.join(' ');
        }
    },
    watch: {
        /**
         * @param {string} value
         */
        value(value) {
            const isSame = this.content === value;

            if (isSame) {
                return;
            }

            this.editor.commands.setContent(value, false);
        },
        editorContent() {
            this.editor.setOptions({
                editorProps: {
                    attributes: {
                        class: this.editorClass,
                        style: this.editorContent?.style ?? ''
                    }
                }
            })
        }
    },
    created() {
        this.onSelectionUpdateDebounced = debounce(this.onSelectionUpdate, 300);
    },
    mounted() {
        const { $refs, value, bubbleMenu, autofocus, editorContent, editorClass, onSelectionUpdateDebounced } = this;

        this.editor = new Editor({
            content: value,
            extensions: resolveExtensions({
                ...(bubbleMenu && {
                    bubbleMenu: {
                        element: $refs.menu,
                        ...bubbleMenu
                    }
                })
            }),
            autofocus,
            editorProps: {
                attributes: {
                    class: editorClass,
                    style: editorContent?.style ?? ''
                }
            },
            onUpdate: () => {
                this.onInput();
                // case when the editor lost focus bc the editor menu form element (e.g. input)
                // intercepted it & the editor value was updated from that element later
                if (!this.editor.isFocused) {
                    this.onChange();
                }
            },
            onBlur: () => {
                const isSame = this.content === this.value;

                if (isSame) {
                    return;
                }
                this.onChange();
            },
            onSelectionUpdate: onSelectionUpdateDebounced
        });
    },
    activated() {
        this.editor.commands.focus(this.caretPosition);
    },
    beforeDestroy() {
        this.editor?.destroy();
    },
    methods: {
        onInput() {
            /**
             * Input event
             * @property {string} value
             */
            this.$emit('input', this.content);
        },
        onChange() {
            /**
             * change event
             * @property {string} value
             */
            this.$emit('change', this.content);
        },
        /**
         * @param {EditorEvents.selectionUpdate} selectionUpdateEvent
         * @param {EditorEvents.selectionUpdate.transaction} selectionUpdateEvent.transaction
         */
        onSelectionUpdate({ transaction }) {
            this.caretPosition = transaction.curSelection.to;
        },
        /**
         * @param {ITool} tool
         * @return {ITool}
         */
        buildToolBinds(tool) {
            const { editor, toolGroups } = this;

            const context = Object.freeze({
                get editor() {
                    return editor;
                },
                get tool() {
                    return tool;
                },
                get tools() {
                    return toolGroups.flatMap(({ group }) => group);
                },
                change: this.change,
                getImageUrl: this.getImageUrl,
            });

            return bindContext(tool, context);
        },
        /**
         * @param {string} title
         * @param {number} groupIndex
         * @return string
         */
        resolveGroupTitle(title, groupIndex) {
            return typeof title === 'string' ? title : `Group ${groupIndex + 1}`;
        }
    }
}
</script>
<style lang="less" scoped>
.editor {
    &-toolbar {
        &.bubble {
            padding: 1rem;
            background-color: var(--color-white);
            border-radius: var(--border-radius);
            box-shadow: 0 1px 4px -2px rgba(0, 0, 0, 0.25);
        }
    }
}

.group-header {
    min-height: calc(var(--line-height)*1rem)
}

.tool {
    &:not(:last-child) {
        margin-right: 0.25rem;
    }
}

::v-deep .ProseMirror {
    &.focus-outline-none:focus-visible {
        outline: none;
    }

    & .ProseMirror-selectednode {
        outline: 2px solid var(--color-focus);
    }

    & img {
        display: block;
    }
}
</style>
