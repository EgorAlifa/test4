<template>
    <div class="ui-color-picker">
        <div class="panel pad-2 d-inline-flex">
            <div :style="{ width: `${totalWidth}px` }">
                <div class="d-flex">
                    <cp-saturation
                        ref="saturation"
                        :color="rgbString"
                        :hsv="hsv"
                        :size="hueHeight"
                        @changeSaturation="changeSaturation"
                        @selectSaturation="selectSaturation" />
                    <cp-hue
                        class="mar-left-2"
                        ref="hue"
                        :hsv="hsv"
                        :width="hueWidth"
                        :height="hueHeight"
                        @selectHue="selectHue" />
                    <cp-alpha
                        class="mar-left-2"
                        ref="alpha"
                        :color="rgbString"
                        :rgba="rgba"
                        :width="hueWidth"
                        :height="hueHeight"
                        @selectAlpha="selectAlpha" />
                </div>
                <cp-preview
                    class="mar-top-2"
                    :color="previewRgbaString"
                    :width="previewWidth"
                    :height="previewHeight" />
                <div class="footer d-flex mar-top-2">
                    <input
                        class="input input-small text-xsmall flex-grow"
                        type="text"
                        :value="modelRgba"
                        @input="({ target }) => inputRgba(target.value)"
                        v-if="modelMode === modelModes.RGBA" />
                    <input
                        class="input input-small text-xsmall flex-grow"
                        type="text"
                        :value="modelHex"
                        @input="({ target }) => inputHex(target.value)"
                        v-else />
                    <button class="btn btn-outline btn-small" :title="nextModelMode" @click="toggleModelMode">
                        <span class="text-xsmall text-upper">{{ nextModelMode[0] }}</span>
                    </button>
                    <button class="btn btn-outline btn-small" @click="submit" v-if="showSubmit">
                        <i class="mdi mdi-check"></i>
                    </button>
                </div>
                <cp-colors
                    class="mar-top-2"
                    :color="rgbaString"
                    :colors-default="colorsDefault"
                    :colors-history-key="colorsHistoryKey"
                    @selectColor="selectColor"
                    v-if="colorsDefault.length || colorsHistoryKey" />
            </div>
        </div>
    </div>
</template>
<style lang="less" scoped>
.ui-color-picker {
    canvas {
        display: block;
    }

    input {
        min-width: 0;
    }

    .footer {
        gap: var(--spacer2);
    }

    .btn {
        min-height: 0;
        width: 2.25em;
        padding: 0;
    }

    .text-upper {
        text-transform: uppercase;
    }
}
</style>
<script>
import { MODEL_MODE, setColorValue, rgb2hex, isValidColorString, resolveColorMode } from './ColorPicker/utils';
import { Key } from './utils/Helpers';
import CpSaturation from './ColorPicker/Saturation.vue';
import CpHue from './ColorPicker/Hue.vue';
import CpAlpha from './ColorPicker/Alpha.vue';
import CpPreview from './ColorPicker/Preview.vue';
import CpColors from './ColorPicker/Colors.vue';

export const DefaultChannelValues = {
    r: 0,
    g: 0,
    b: 0,
    a: 1,
    h: 0,
    s: 0,
    v: 0
};

export default {
    components: {
        CpSaturation,
        CpHue,
        CpAlpha,
        CpPreview,
        CpColors
    },
    props: {
        /**
         * @model
         */
        value: {
            type: String,
            default: '#000000'
        },
        /**
         * Default colors palette
         */
        colorsDefault: {
            type: Array,
            default: () => []
        },
        /**
         * LocalStorage key for saving used colors
         */
        colorsHistoryKey: {
            type: String,
            default: ''
        },
        /**
         * Show submit button
         */
        showSubmit: {
            type: Boolean,
            default: false
        }
    },
    data() {
        return {
            hueWidth: 15,
            hueHeight: 150,
            previewHeight: 15,
            modelRgba: '',
            modelHex: '',
            modelMode: MODEL_MODE.RGBA,
            modelModes: MODEL_MODE,
            ...DefaultChannelValues
        };
    },
    computed: {
        /**
         * @return {string}
         */
        nextModelMode() {
            let { HEX, RGBA } = MODEL_MODE;
            return this.modelMode === HEX ? RGBA : HEX;
        },
        /**
         * @return {number}
         */
        totalWidth() {
            return this.hueHeight + (this.hueWidth + 4) * 2;
        },
        /**
         * @return {number}
         */
        previewWidth() {
            return this.totalWidth;
        },
        /**
         * @return {{a: number, r: number, b: number, g: number}}
         */
        rgba() {
            return {
                r: this.r,
                g: this.g,
                b: this.b,
                a: this.a
            };
        },
        /**
         * @return {{s: number, v: number, h: number}}
         */
        hsv() {
            return {
                h: this.h,
                s: this.s,
                v: this.v
            };
        },
        /**
         * @return {string}
         */
        rgbString() {
            return `rgb(${this.r}, ${this.g}, ${this.b})`;
        },
        /**
         * @return {string}
         */
        rgbaStringShort() {
            return `${this.r}, ${this.g}, ${this.b}, ${this.a}`;
        },
        /**
         * @return {string}
         */
        rgbaString() {
            return `rgba(${this.rgbaStringShort})`;
        },
        /**
         * @return {string}
         */
        hexString() {
            return rgb2hex(this.rgba, true);
        },
        /**
         * @return {string}
         */
        previewRgbaString() {
            return this.rgbaString;
        },
        /**
         * @return {string}
         */
        modelModeValue() {
            const { modelMode, modelHex, rgbaString } = this;
            const { RGBA } = MODEL_MODE;
            return modelMode === RGBA ? rgbaString : modelHex;
        }
    },
    watch: {
        value: {
            handler(input, prevInput) {
                if (prevInput == null) {
                    this.modelMode = resolveColorMode(input);
                }
                const channels = isValidColorString(input) ? setColorValue(input) : { ...DefaultChannelValues };
                Object.assign(this, channels);
                this.setText();
            },
            immediate: true
        },
        modelModeValue() {
            this.emitDetails('changeColor');
            /**
             * Triggers when the color changes
             * @property {Number} rgbaString color rgba string
             */
            this.$emit('input', this.modelModeValue);
        }
    },
    created() {
        document.addEventListener('keydown', this.onDocKeydown);
    },
    beforeDestroy() {
        document.removeEventListener('keydown', this.onDocKeydown);
    },
    methods: {
        /**
         * Triggers when the color changes
         * @property {Object} color color object
         */
        emitDetails(eventName) {
            const { modelMode, modelModeValue, modelHex, rgba, hsv } = this;
            /**
             * Triggers when the color changes
             * @property {Object} color color object
             */
            this.$emit(eventName, {
                value: modelModeValue,
                rgba,
                hsv,
                hex: modelHex,
                mode: modelMode
            });
        },
        submit() {
            this.emitDetails('submit');
        },
        toggleModelMode() {
            const { HEX, RGBA } = MODEL_MODE;
            this.modelMode = this.modelMode === HEX ? RGBA : HEX;
        },
        selectSaturation(color) {
            const { r, g, b, h, s, v } = setColorValue(color);
            Object.assign(this, { r, g, b, h, s, v });
            this.setText();
        },
        changeSaturation(color) {
            //const { r, g, b } = setColorValue(color);
            //const { a } = this;
            //this.previewRgbaString = `rgba(${r},${g},${b},${a})`;
            const { r, g, b, h, s, v } = setColorValue(color);
            Object.assign(this, { r, g, b, h, s, v });
            this.setText();
        },
        selectHue(color) {
            const { r, g, b, h, s, v } = setColorValue(color);
            Object.assign(this, { r, g, b, h, s, v });
            this.setText();
            this.$nextTick(() => {
                this.$refs.saturation.renderColor();
                this.$refs.saturation.renderSlide();
            });
        },
        selectAlpha(a) {
            this.a = a;
            this.setText();
        },
        inputHex(color) {
            const { r, g, b, a, h, s, v } = setColorValue(color);
            Object.assign(this, { r, g, b, a, h, s, v });
            this.modelHex = color;
            this.modelRgba = this.rgbaStringShort;
            this.$nextTick(() => {
                this.$refs.saturation.renderColor();
                this.$refs.saturation.renderSlide();
                this.$refs.hue.renderSlide();
            });
        },
        inputRgba(color) {
            const { r, g, b, a, h, s, v } = setColorValue(color);
            Object.assign(this, { r, g, b, a, h, s, v });
            this.modelHex = this.hexString;
            this.modelRgba = color;
            this.$nextTick(() => {
                this.$refs.saturation.renderColor();
                this.$refs.saturation.renderSlide();
                this.$refs.hue.renderSlide();
            });
        },
        setText() {
            this.modelHex = this.hexString;
            this.modelRgba = this.rgbaStringShort;
        },
        selectColor(color) {
            const { r, g, b, a, h, s, v } = setColorValue(color);
            Object.assign(this, { r, g, b, a, h, s, v });
            this.setText();
            this.$nextTick(() => {
                this.$refs.saturation.renderColor();
                this.$refs.saturation.renderSlide();
                this.$refs.hue.renderSlide();
            });
        },
        onDocKeydown(e) {
            if (e.key === Key.ESC) {
                e.stopImmediatePropagation();
                this.$emit('close');
                return;
            }
            if (e.key === Key.ENTER) {
                e.preventDefault();
                e.stopImmediatePropagation();
                this.submit();
            }
        }
    }
};
</script>
