const scrollIntoView = c => {
    if (!c || !c.parentNode) {
        return;
    }
    let p = c.parentNode;
    let ph = p.offsetHeight;
    let py = p.scrollTop;
    let ch = c.offsetHeight;
    let cy = c.offsetTop;
    if (cy < py) {
        p.scrollTop = cy;
    } else if (cy > py + ph - ch) {
        p.scrollTop = cy - ph + ch;
    }
};

let ID = 1;
const nextId = prefix => `${prefix}-${ID++}`;
const isDateValid = d => d instanceof Date && !isNaN(d.getTime());

const Key = {
    UP: 'ArrowUp',
    DOWN: 'ArrowDown',
    ENTER: 'Enter',
    ESC: 'Escape',
};

const Position = {
    LEFT: 'left',
    RIGHT: 'right',
    TOP: 'top',
    BOTTOM: 'bottom',
    START: 'start',
    END: 'end',
};

const TriggerOn = {
    MOUSE_MOVE: 'mousemove',
    CLICK: 'click'
};

const debounce = (func, delay) => {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, delay);
    };
};

/**
 * @param {Element} target
 * @param {IntersectionObserverCallback} callback
 * @param {IntersectionObserverInit} options
 * @return {{ observer:IntersectionObserver, stop:Function }}
 */
const useIntersectionObserver = (target, callback, options) => {
    const observer = new IntersectionObserver(callback, options);
    observer.observe(target);
    return { observer, stop: () => observer.disconnect() };
};

/**
 * @param {number} x - x-axis coordinate
 * @param {number} y - y-axis coordinate
 * @return {function: DOMRect}
 */
const generateGetBoundingClientRect = (x = 0, y = 0) => () => ({
    width: 0,
    height: 0,
    top: y,
    right: x,
    bottom: y,
    left: x,
});

export {
    scrollIntoView,
    isDateValid,
    nextId,
    Key,
    Position,
    TriggerOn,
    debounce,
    useIntersectionObserver,
    generateGetBoundingClientRect,
};
