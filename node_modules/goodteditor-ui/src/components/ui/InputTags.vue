<template>
    <div class="ui-input-tags form-elem" :class="cssClass" @focus="onRootFocus" tabindex="0">
        <div class="ui-input-tags-tags" v-if="value.length">
            <!--
            @slot Tag slot
            @binding {String} tag       tag
            @binding {Function} remove  remove tag function(tag)
            -->
            <slot name="tag" v-for="tag in value" v-bind="{ tag, remove: removeTag }">
                <ui-badge
                    class="ui-input-tags-badge mar-none mar-right-2 mar-bot-2 pull-left cursor-pointer"
                    :class="{ 'ui-input-tags-badge--selected': tagSelected === tag }"
                    theme="primary"
                    size="small"
                    :key="tag"
                    removable
                    @remove="removeTag(tag)"
                >
                    <span>{{ tag }}</span>
                </ui-badge>
            </slot>
        </div>
        <!--
        @slot Custom input slot
        @binding {String} id            input id attribute value
        @binding {String} value         input value
        @binding {Function} addTag      function to add tag
        @binding {Function} setValue    function to set the 'value' function(value)
        @binding {Object} inputBinds    input props (use v-bind)
        @binding {Object} inputEvents   input events (use v-on)
        -->
        <slot
            name="input"
            v-bind="{
                id: inputId,
                value: newTag,
                addTag,
                setValue: setNewTag,
                inputBinds,
                inputEvents,
            }"
        >
            <input
                :id="inputId"
                class="ui-input-tags-input w-100"
                :class="{ 'mar-top-2': value.length }"
                type="text"
                tabindex="-1"
                :value="newTag"
                v-bind="inputBinds"
                v-on="inputEvents"
            />
        </slot>
    </div>
</template>
<style lang="pcss" scoped>
.ui-input-tags {
    display: inline-flex;
    flex-wrap: wrap;

    &-input {
        line-height: 1.5;
        border: none;
        padding: 0;
        color: inherit;
        background: transparent;
        outline: none;
    }

    &-tags {
        max-width: 100%;
    }

    &-badge {
        white-space: normal;
        overflow-wrap: break-word;
        word-break: break-word;
        &--selected {
            background-color: var(--color-primary-dark);
        }
    }
}
</style>
<script>
import UiBadge from './Badge.vue';
import FormComponent from './utils/FormComponent';

export default {
    components: {
        UiBadge,
    },
    mixins: [FormComponent],
    props: {
        /**
         * @model
         */
        value: {
            type: Array,
            default() {
                return [];
            },
        },
        /**
         * Filters new values before adding function(values:Array, valuesNew:Array):Array
         */
        valueFilter: {
            type: Function,
            default(values, valuesNew) {
                return valuesNew.filter((v, i, a) => a.indexOf(v) === i && !values.includes(v));
            },
        },
        /**
         * Delimiter
         */
        delimiter: {
            type: String,
            default: ',',
        },
    },
    data() {
        return {
            newTag: '',
            tagSelected: null,
            inputBinds: {
                placeholder: this.placeholder,
                readonly: this.readonly,
            },
            inputEvents: {
                input: this.onInputInput,
                focus: this.onInputFocus,
                blur: this.onInputBlur,
                keydown: this.onInputKeydown
            },
        };
    },
    methods: {
        /**
         *
         * @param {string} value
         */
        setNewTag(value) {
            this.newTag = value;
        },
        addTag() {
            let newTags = this.valueFilter(
                this.value,
                this.newTag.split(this.delimiter).map(tag => tag.trim())
            );
            if (!newTags.length) {
                return;
            }
            let tags = [...this.value, ...newTags];
            /**
             * Input event
             * @property {Array} tags
             */
            this.$emit('input', tags);
            /**
             * Change event
             * @property {Array} tags
             */
            this.$emit('change', tags);
            this.newTag = '';
        },
        /**
         * @param {string} tag
         */
        removeTag(tag) {
            let tags = this.value.filter(t => t !== tag);
            /**
             * Input event
             * @property {Array} tags
             */
            this.$emit('input', tags);
            /**
             * Change event
             * @property {Array} tags
             */
            this.$emit('change', tags);
        },
        onRootFocus() {
            let input = this.getInputRef();
            input && input.focus();
        },
        onInputInput(e) {
            this.newTag = e.target.value;
            this.tagSelected = null;
        },
        onInputFocus() {
            this.rootHasFocus = true;
        },
        onInputBlur() {
            this.rootHasFocus = false;
        },
        /**
         * @param {KeyboardEvent} e
         */
        onInputEnter(e) {
            e.preventDefault();
            e.stopPropagation();
            this.addTag();
        },
        /**
         * @param {KeyboardEvent} e
         */
        onInputEsc(e) {
            e.stopPropagation();
            let input = this.getInputRef();
            input && input.blur();
        },
        /**
         *
         * @param {number} direction
         */
        selectTag(direction = -1) {
            const lastIndex = this.value.length - 1;
            let tagSelected = this.tagSelected;

            if (tagSelected === null) {
                tagSelected = this.value[lastIndex] ?? null;
            } else {
                let index = this.value.findIndex((tag) => tag === tagSelected) + direction;
                if (index > lastIndex) {
                    index = 0;
                }
                if (index < 0) {
                    index = lastIndex;
                }
                tagSelected = this.value[index];
            }

            if (tagSelected === null) {
                this.onRootFocus();
            }
            this.tagSelected = tagSelected;
        },
        /**
         *
         * @param {KeyboardEvent} e
         */
        onInputKeydown(e) {
            switch (e.key) {
                case 'Enter': {
                    this.onInputEnter(e);
                    return;
                }
                case 'Escape': {
                    this.onInputEsc(e);
                    return;
                }
            }

            // if some text in input exist
            if (e.target.value !== '') {
                return;
            }

            switch (e.key) {
                case 'Backspace': {
                    if (this.tagSelected === null) {
                        this.selectTag();
                        return;
                    }
                    this.removeTag(this.tagSelected);
                    this.tagSelected = null;
                    this.$nextTick(() => {
                        this.selectTag();
                    });
                    return;
                }
                case 'ArrowLeft':
                case 'ArrowUp': {
                    this.selectTag(-1);
                    return;
                }
                case 'ArrowRight':
                case 'ArrowDown': {
                    this.selectTag(1);
                    return;
                }
            }
        }
    },
};
</script>
