<template>
    <transition name="transition" appear>
        <div :style="cssStyle" v-if="show" v-append-body>
            <slot></slot>
        </div>
    </transition>
</template>
<style lang="less" scoped>
.transition {
    &-enter,
    &-leave-to {
        opacity: 0;
    }
    &-enter-active,
    &-leave-active {
        transition: opacity 0.15s ease;
    }
}
</style>
<script>
import { createPopper } from '@popperjs/core';
import { Position, generateGetBoundingClientRect } from './utils/Helpers';

const isElem = el => el instanceof HTMLElement;

const isCoordinates = (target) => {
    if (Array.isArray(target) === false) {
        return false;
    }
    if (target.length !== 2) {
        return false;
    }
    if (target.some((item) => Number.isNaN(Number(item)))) {
        return false;
    }
    return true;
}

const Strategy = Object.freeze({
    ABSOLUTE: 'absolute',
    FIXED: 'fixed'
});

const Modifier = Object.freeze({
    FLIP: 'flip',
    OFFSET: 'offset'
});

export default {
    directives: {
        'append-body': {
            inserted(el, bindings, { context }) {
                let { appendToBody } = context;
                if (!appendToBody) {
                    return;
                }
                const nt = context.$nextTick;
                nt(() => nt(() => document.body.appendChild(el)));
            },
            unbind(el, bindings, { context }) {
                el.parentNode && el.parentNode.removeChild(el);
            },
        },
    },
    props: {
        /**
         * Target HTMLElement|selector|array of coordinates used for positioning
         */
        target: { default: null },
        /**
         * Whether to show popover
         */
        show: { type: Boolean, default: false },
        /**
         * z-index
         */
        zIndex: {
            type: Number,
            default: 1010,
        },
        /**
         * Whether to append popover to body
         */
        appendToBody: {
            type: Boolean,
            default: true,
        },
        /**
         * Position, values of the popover:
         * bl, br, tl, tr - bottom-left, bottom-right, top-left, top-right
         * @values bl, br, tl, tr, top, top-start, top-end, left, left-start, left-end, right, right-start, right-end, bottom, bottom-start, bottom-end
         */
        position: {
            type: String,
            default: `${Position.BOTTOM}-${Position.START}`,
        },
        /**
         * Position offset [ x, y ] where:
         * x - skidding (offset along target)
         * y - distance (offset away from target)
         */
        positionOffset: {
            type: Array,
            default() {
                return [1, 1];
            },
        },
        /**
         * Whether to flip position if out of viewport
         */
        positionFlip: {
            type: Boolean,
            default: true,
        },
        /**
         * Auto width
         */
        autoWidth: {
            type: Boolean,
            default: false,
        },
        /**
         * Should respond to pointer events
         */
        shouldRespondToPointerEvents: {
            type: Boolean,
            default: true
        }
    },
    data() {
        return { cssStyle: {} };
    },
    computed: {
        placement() {
            const { position } = this;
            const map = { t: Position.TOP, l: Position.START, r: Position.END, b: Position.BOTTOM };
            // t-b-l-r mode
            if (position.length == 2) {
                return position
                    .split('')
                    .map(k => map[k])
                    .filter(v => !!v)
                    .join('-');
            }
            return position;
        },
        options() {
            const { appendToBody, placement, positionFlip, positionOffset } = this;
            const strategy = appendToBody ? Strategy.FIXED : Strategy.ABSOLUTE;
            const modifiers = [
                {
                    name: Modifier.FLIP,
                    enabled: positionFlip,
                },
                {
                    name: Modifier.OFFSET,
                    options: {
                        offset: positionOffset,
                    },
                },
            ]
            return { placement, strategy, modifiers };
        }
    },
    watch: {
        show: {
            handler(val) {
                this.$nextTick(() => {
                    if (val === false) {
                        this.handleReset();
                        return;
                    }

                    if (isCoordinates(this.target) === false) {
                        this.addEventListeners();
                    }

                    this.createPopper();
                });
            },
            immediate: true,
        },
    },
    created() {
        this.popper = null;
    },
    destroyed() {
        this.handleReset();
    },
    methods: {
        addEventListeners() {
            window.addEventListener('blur', this.onWinBlur);
            document.addEventListener('mousedown', this.onDocMouseDown);
        },
        removeEventListeners() {
            window.removeEventListener('blur', this.onWinBlur);
            document.removeEventListener('mousedown', this.onDocMouseDown);
        },
        calcStyle() {
            const { zIndex, autoWidth, shouldRespondToPointerEvents } = this;
            const target = this.getTarget();
            const style = { zIndex };
            if (autoWidth && target) {
                const b = target.getBoundingClientRect();
                style.width = `${b.width}px`;
            }
            if (shouldRespondToPointerEvents === false) {
                style.pointerEvents = 'none';
            }
            this.cssStyle = style;
        },
        getTarget() {
            const { target } = this;
            return isCoordinates(target) ? null : isElem(target) ? target : document.querySelector(target);
        },
        setShow(val) {
            this.$nextTick(() => this.$emit('update:show', val));
        },
        createPopper() {
            const { options, $el: popper } = this;
            const target = this.getTarget();

            if (target != null) {
                this.popper = createPopper(target, popper, options);
                this.$nextTick(this.updatePopper);
                return;
            }

            if (isCoordinates(this.target)) {
                const [x, y] = this.target;
                const virtualElem = {
                    getBoundingClientRect: generateGetBoundingClientRect(x, y),
                };
                this.popper = createPopper(virtualElem, popper, options);
                this.$nextTick(this.updatePopper);
                this.unwatchCursorCoordinates = this.$watch('target', ([x, y]) => {
                    virtualElem.getBoundingClientRect = generateGetBoundingClientRect(x, y);
                    this.popper?.update();
                });
            }
        },
        updatePopper() {
            this.calcStyle();
            this.popper.update();
        },
        destroyPopper() {
            this.popper?.destroy();
            this.popper = null;
        },
        handleReset() {
            this.unwatchCursorCoordinates?.();
            if (isCoordinates(this.target) === false) {
                this.removeEventListeners();
            }
            this.destroyPopper();
        },
        onWinBlur(e) {
            if (this.show) {
                this.setShow(false);
            }
        },
        onDocMouseDown(e) {
            let target = this.getTarget();
            let root = this.$el && isElem(this.$el) ? this.$el : null;
            if ((root && root.contains(e.target)) || (target && target.contains(e.target))) {
                return;
            }
            if (this.show) {
                this.setShow(false);
            }
        },
    },
};
</script>
