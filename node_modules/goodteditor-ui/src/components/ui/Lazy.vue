<script>
import { useIntersectionObserver } from './utils/Helpers';

export default {
    props: {
        /** which tag name to use when wrapping slot */
        tag: { type: String, default: 'div' },
        /** viewport element selector/reference or null for 'viewport' */
        root: { type: [String, Element], default: null },
        /** viewport margins */
        rootMargin: { type: String, default: '300px' },
        /** target's visibility ratios */
        threshold: { type: [Number, Array], default: 0 },
        /** defered rendering delay (ms) */
        renderDelay: { type: Number, default: 100 },
        /** defered rendering delay (ms) */
        unrenderDelay: { type: Number, default: 500 },
        /** default initial min-height of the lazy content */
        minHeight: { type: String, default: '' },
    },
    data: () => ({ shouldRender: false, minHeightCalc: 0 }),
    created() {
        /** @type {Function} */
        this.stopObserver = null;
        /** @type {number} */
        this.renderTimeout = null;
    },
    computed: {
        /** @return {object} */
        cssStyle() {
            const { minHeight, minHeightCalc } = this;
            const mh = minHeightCalc ? `${minHeightCalc}px` : minHeight;
            return { minHeight: mh };
        },
    },
    mounted() {
        const { root: rootSelector, rootMargin, threshold } = this;
        const root =
            rootSelector instanceof Element ? rootSelector : document.querySelector(rootSelector);
        const { stop } = useIntersectionObserver(
            this.$el,
            ([{ isIntersecting }]) => this.handleIntersection(isIntersecting),
            { root, rootMargin, threshold }
        );
        this.stopObserver = stop;
        this.calcMinHeight();
    },
    beforeDestroy() {
        if (this.stopObserver) {
            this.stopObserver();
        }
        this.calcMinHeight();
    },
    methods: {
        /**
         * @param {boolean} shouldRender
         * @effect shouldRender, renderTimeout
         */
        handleIntersection(shouldRender) {
            const { renderTimeout, renderDelay, unrenderDelay } = this;
            // clear prev render/unrender if any
            if (renderTimeout) {
                clearTimeout(renderTimeout);
            }
            const delay = shouldRender ? renderDelay : unrenderDelay;
            this.renderTimeout = setTimeout(() => {
                this.$nextTick(() => {
                    this.shouldRender = shouldRender;
                    if (shouldRender) {
                        this.calcMinHeight();
                    }
                });
            }, delay);
        },
        /**
         * Recalcs min-height
         * @effect minHeightCalc
         */
        calcMinHeight() {
            this.$nextTick(() => {
                this.minHeightCalc = this.$el.clientHeight;
            });
        },
    },
    render(h) {
        const { tag, shouldRender, cssStyle: style } = this;
        const { default: defaultSlot } = this.$scopedSlots;
        const children = shouldRender && defaultSlot ? defaultSlot() : [];
        return h(tag, { style }, children);
    },
};
</script>
