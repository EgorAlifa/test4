export const MODEL_MODE = {
    HEX: 'hex',
    RGBA: 'rgba'
};

export const isValidColorString = (value) => {
    return CSS.supports('color', value);
}

const hex2Dec = (val) => {
    const value = parseInt(val, 16);
    if (Number.isNaN(value)) {
        throw new Error(`${val} is not a valid HEX number`);
    }
    return value;
};

const checkRgbaColorChannelRange = (c) => {
    if (c < 0 || c > 255) {
        throw new Error(`${c} is not a valid RGBa color channel value range`);
    }
};

const checkRgbaAlphaChannelRange = (c) => {
    if (c < 0 || c > 1) {
        throw new Error(`${c} is not a valid RGBa alpha channel value range`);
    }
};

const checkRgbaChannelsRange = (rgba) => {
    ['r', 'g', 'b'].forEach((c) => checkRgbaColorChannelRange(rgba[c]));
    checkRgbaAlphaChannelRange(rgba['a']);
};

export const rgb2hex = ({ r, g, b, a }, toUpper) => {
    const change = val => ('0' + Number(val).toString(16)).slice(-2);
    const color = `#${change(r)}${change(g)}${change(b)}${a < 1 ? change(Math.round(a * 255)) : ''}`;
    return toUpper ? color.toUpperCase() : color;
};

export const hex2rgb = (hex) => {
    hex = hex.slice(1);
    if (hex.length === 3) {
        hex = hex.split('').map((v) => v.padEnd(2, v)).join('');
    } else if (hex.length < 6) {
        hex = hex.padEnd(6, '0');
    }
    hex = hex.padEnd(8, 'ff');
    const [r, g, b, a] = [0, 2, 4, 6].map((i) => hex2Dec(hex.slice(i, i + 2)));
    return {
        r,
        g,
        b,
        a: (a / 255).toFixed(2)
    };
};

export const rgb2rgba = (rgba) => {
    if (typeof rgba === 'string') {
        const error = new Error(`${rgba} is not a valid RGBa`);
        rgba = /rgba?\((.*?)\)/.exec(rgba);
        if (rgba === null) {
            throw error;
        }
        rgba = rgba[1].split(',').map(Number);
        if (rgba.length < 3 || rgba.some((v) => Number.isNaN(v))) {
            throw error;
        }
        return {
            r: rgba[0],
            g: rgba[1],
            b: rgba[2],
            a: rgba[3] ?? 1
        };
    } else {
        return rgba;
    }
};

export const rgb2hsv = ({ r, g, b }) => {
    r = r / 255;
    g = g / 255;
    b = b / 255;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const delta = max - min;
    let h = 0;
    if (max === min) {
        h = 0;
    } else if (max === r) {
        if (g >= b) {
            h = (60 * (g - b)) / delta;
        } else {
            h = (60 * (g - b)) / delta + 360;
        }
    } else if (max === g) {
        h = (60 * (b - r)) / delta + 120;
    } else if (max === b) {
        h = (60 * (r - g)) / delta + 240;
    }
    h = Math.floor(h);
    let s = parseFloat((max === 0 ? 0 : 1 - min / max).toFixed(2));
    let v = parseFloat(max.toFixed(2));
    return { h, s, v };
};

const normalizeRgbaChannels = (rgba) => {
    rgba = { ...rgba };
    ['r', 'g', 'b'].forEach((c) => { rgba[c] = Math.min(Math.max(rgba[c], 0), 255) });
    rgba['a'] = Math.min(Math.max(rgba['a'], 0), 1);
    return rgba;
};

export const resolveColorMode = (color) => {
    if (color.startsWith('#')) {
        return MODEL_MODE.HEX;
    }
    return  MODEL_MODE.RGBA;
}

export const setColorValue = (color) => {
    let rgba;
    if (/#/.test(color)) {
        rgba = hex2rgb(color);
    } else if (/rgb/.test(color)) {
        rgba = rgb2rgba(color);
    } else if (typeof color === 'string') {
        rgba = rgb2rgba(`rgba(${color})`);
    } else if (color instanceof Object) {
        rgba = color;
    } else {
        throw new Error('Invalid color value');
    }

    rgba = normalizeRgbaChannels(rgba);
    const { r, g, b, a } = rgba;
    const { h, s, v } = rgb2hsv(rgba);
    return {
        r,
        g,
        b,
        a: a === undefined ? 1 : a,
        h,
        s,
        v
    };
};

export const createAlphaSquare = (size) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const doubleSize = size * 2;
    canvas.width = doubleSize;
    canvas.height = doubleSize;

    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, doubleSize, doubleSize);
    ctx.fillStyle = '#ccd5db';
    ctx.fillRect(0, 0, size, size);
    ctx.fillRect(size, size, size, size);

    return canvas;
};

export const createLinearGradient = (direction, ctx, width, height, color1, color2) => {
    const isL = direction === 'l';
    const gradient = ctx.createLinearGradient(0, 0, isL ? width : 0, isL ? 0 : height);
    gradient.addColorStop(0.01, color1);
    gradient.addColorStop(0.99, color2);
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);
};

export default {};
