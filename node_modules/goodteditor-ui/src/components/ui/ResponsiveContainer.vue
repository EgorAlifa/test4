<script>
import { debounce } from './utils/Helpers';

const ObserverManager = {
    observer: null,
    records: new Map(),
    register({ fn, el }) {
        const { records } = this;
        if (!records.size) {
            this.createObserver();
        }
        records.set(el, fn);
        this.observer.observe(el);
    },
    unregister(el) {
        const { records } = this;
        records.delete(el);
        this.observer.unobserve(el);
        if (!records.size) {
            this.destroyObserver();
        }
    },
    createObserver() {
        const { records } = this;
        const callback = entries => {
            entries.forEach(entry => {
                const fn = records.get(entry.target);
                fn && fn(entry);
            });
        };
        this.observer = new ResizeObserver(debounce(callback, 50));
    },
    destroyObserver() {
        this.observer.disconnect();
        this.observer = null;
    },
};

export default {
    props: {
        /**
         * Breakpoints hash { '<name>': '<max-width-in-px>' }<br>
         * example:
         * <pre>{ 'mobile': 400, 'tablet': 800 }</pre>
         */
        breakpoints: {
            type: Object,
            default: () => ({}),
        },
    },
    data: () => ({ width: 0, height: 0 }),
    computed: {
        /**
         * @return {[string, number][]}
         */
        breakpointEntries() {
            return Object.entries(this.breakpoints).sort(([, aVal], [, bVal]) => aVal - bVal);
        },
        /**
         * @return {string}
         */
        breakpoint() {
            const { breakpointEntries, width } = this;
            if (width === 0) {
                return null;
            }
            const match = breakpointEntries.find(([, value]) => width < value);
            return match?.[0] ?? null;
        },
    },
    mounted() {
        const { $el: el } = this;
        const fn = ({ contentRect }) => {
            this.width = contentRect.width | 0;
            this.height = contentRect.height | 0;
        };
        ObserverManager.register({ fn, el });
    },
    beforeDestroy() {
        ObserverManager.unregister(this.$el);
    },
    render(h) {
        const { breakpoint, width, height } = this;
        /*
        @slot Page data slot
        @binding {string} breakpoint    breakpoint name 
        @binding {number} width         current container width (px)    
        @binding {number} height        current container height (px)
        */
        const content = this.$scopedSlots.default
            ? this.$scopedSlots.default({ breakpoint, width, height })
            : null;
        if (content.length > 1) {
            return h('div', 'Slot content should have one child');
        }
        return content;
    },
};
</script>
