import { CoreError } from '@goodt-wcore/errors';
import { CanvasSizeUnits } from '@goodt-wcore/panels';

/* eslint-disable no-underscore-dangle */
const sizeConverterEnforcer = Symbol('sizeConverterEnforcer');

// TODO remove when will be performed refactoring
/**
 * converts recursively passed value if it contains a css-variable to its computed value
 * @param {*} option
 * @param {CSSStyleDeclaration} computedStyle
 * @return {*}
 */
export const convertCssVarToComputedValue = (option, computedStyle) => {
    const extractCssVarValue = (cssVar) =>
        computedStyle.getPropertyValue(cssVar.substring(4, cssVar.length - 1)) || cssVar;
    
    if (Array.isArray(option)) {
        return option.map((item) => convertCssVarToComputedValue(item, computedStyle));
    }
    
    if (typeof option === 'object' && option != null) {
        return Object.entries(option).reduce(
            (acc, [key, value]) => ({
                ...acc,
                [key]: convertCssVarToComputedValue(value, computedStyle)
            }),
            {}
        );
    }
    
    if (/^var\(--/.test(option)) {
        return extractCssVarValue(option);
    }
    
    return option;
};

export class SizeConverter {
    /**
     * @private
     * @type {SizeConverter}
     */
    static _instance;
    
    /**
     * @private
     * @type {HTMLDivElement}
     */
    _gageElement;
    
    /**
     * Constructor
     *
     * @param {symbol} enforcer singleton enforcer
     */
    constructor(enforcer) {
        if (enforcer !== sizeConverterEnforcer) {
            throw new Error(`Instantiation failed: use SizeConverter.instance`);
        }
        this._gageElement = SizeConverter._createGageElement();
    }
    
    /**
     * @return {SizeConverter}
     */
    static get instance() {
        if (SizeConverter._instance == null) {
            SizeConverter._instance = new SizeConverter(sizeConverterEnforcer);
        }
        return SizeConverter._instance;
    }
    
    /**
     * @private
     * @return {HTMLDivElement}
     */
    static _createGageElement() {
        const elem = document.createElement('div');
        elem.style.display = 'none';
        document.body.append(elem);
        return elem;
    }
    
    /**
     * @private
     * @param {string} cssVar
     * @param {CSSStyleDeclaration} computedStyle
     * @return {string}
     */
    static _extractCssVarValue(cssVar, computedStyle){
        return computedStyle.getPropertyValue(cssVar.substring(4, cssVar.length - 1)) || cssVar;
    }
    
    /**
     * converts recursively passed value if it contains a css-variable to its value
     * @param {*} option
     * @param {CSSStyleDeclaration} [computedStyle]
     * @return {*}
     */
    convertCssVarToValue(option, computedStyle) {
        if (computedStyle == null) {
            computedStyle = getComputedStyle(this._gageElement);
        }
        
        if (Array.isArray(option)) {
            return option.map((item) => this.convertCssVarToValue(item, computedStyle));
        }
        
        if (typeof option === 'object' && option != null) {
            return Object.entries(option).reduce(
                (acc, [key, value]) => ({
                    ...acc,
                    [key]: this.convertCssVarToValue(value, computedStyle)
                }),
                {}
            );
        }
        
        if (/^var\(--/.test(option)) {
            return SizeConverter._extractCssVarValue(option, computedStyle);
        }
        
        return option;
    }
    
    /**
     * takes size info and returns absolute value expressed in pixels
     *
     * @param {Object} sizeInfo
     * @param {string} [sizeInfo.size=''] concatenated unit and value or css-variable
     * @param {string} [sizeInfo.unit] unit
     * @param {string|number} [sizeInfo.value] value
     * @param {CSSStyleDeclaration} [computedStyle] computed style
     * @return {number} unit size in absolute value
     */
    convertToAbsoluteValue({ size = '', unit, value } = {}, computedStyle) {
        size = this.convertCssVarToValue(String(size), computedStyle);
        unit = unit ?? size.match(/[a-zA-Z]+$/)?.[0] ?? 'px';
        value = (value ?? parseFloat(size)) || 0;
        
        if (CanvasSizeUnits.includes(unit) === false) {
            throw new CoreError(`Invalid unit type was passed and cannot be converted: "${unit}"`);
        }
        
        const element = this._gageElement;
        element.style.fontSize = `${value}${unit}`;
        
        return parseFloat(getComputedStyle(element).getPropertyValue('font-size'));
    }
}
