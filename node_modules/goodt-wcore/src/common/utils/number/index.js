import { clamp } from 'lodash';
import { Const } from '@goodt-wcore/core';
import NumberFormat from './number-format';
import NumberFormatPattern from './number-format-pattern';
import { getCompactIntegerPartLength } from './utils';

/**
 * @typedef {import('.').NumberFormatOptions} NumberFormatOptions
 * @typedef {import('./number-format').NumberFormatConstructorOptions} NumberFormatConstructorOptions
 * @typedef {import('./number-format-pattern').NumberFormatPatternConstructorOptions} NumberFormatPatternConstructorOptions
 */

/**
 * Format number as currency value
 * @param {number} number
 * @param {NumberFormatPatternConstructorOptions} [pattern={}]
 * @param {NumberFormatOptions} [options={}]
 * @return {string}
 */
const formatCurrency = (number, { digits = 2, unit = '', modifiers = [] } = {}, { locale = Const.LOCALE } = {}) => {
    const { Style, Notation, CurrencyDisplay } = NumberFormat;
    const { DIGITS_MAX } = NumberFormatPattern;
    const isCompact = modifiers.includes(NumberFormatPattern.Modifier.COMPACT);
    const isFixed = modifiers.includes(NumberFormatPattern.Modifier.FIXED);
    const maximumFractionDigits = clamp(digits, DIGITS_MAX);
    const currencyUSD = 'USD';
    const num = Number(number);
    const integerPartLength = getCompactIntegerPartLength(num);
    const maximumSignificantDigits = clamp(integerPartLength + maximumFractionDigits, DIGITS_MAX);

    return num
        .toLocaleString(locale || [], {
            style: Style.CURRENCY,
            currency: currencyUSD,
            currencyDisplay: CurrencyDisplay.CODE,
            notation: isCompact ? Notation.COMPACT : Notation.STANDARD,
            minimumFractionDigits: isFixed ? maximumFractionDigits : 0,
            maximumFractionDigits,
            minimumSignificantDigits: isCompact && isFixed ? maximumSignificantDigits : undefined,
            maximumSignificantDigits: isCompact ? maximumSignificantDigits : undefined
        })
        .replace(currencyUSD, unit.trim())
        .trim();
};

/**
 * Format number as a decimal number
 * @param {number} number
 * @param {NumberFormatPatternConstructorOptions} [pattern={}]
 * @param {NumberFormatOptions} [options={}]
 * @return {string}
 */
const formatDecimal = (
    number,
    { digits = NumberFormatPattern.DIGITS_MAX, unit = '', modifiers = [] } = {},
    { locale = Const.LOCALE } = {}
) => {
    const { Style, Notation } = NumberFormat;
    const { DIGITS_MAX } = NumberFormatPattern;
    const isCompact = modifiers.includes(NumberFormatPattern.Modifier.COMPACT);
    const isPercent = modifiers.includes(NumberFormatPattern.Modifier.PERCENT);
    const isFixed = modifiers.includes(NumberFormatPattern.Modifier.FIXED);
    const maximumFractionDigits = clamp(digits, DIGITS_MAX);
    const num = Number(number);
    const integerPartLength = getCompactIntegerPartLength(num, isPercent);
    const maximumSignificantDigits = clamp(integerPartLength + maximumFractionDigits, DIGITS_MAX);

    let string = num.toLocaleString(locale || [], {
        style: isPercent ? Style.PERCENT : Style.DECIMAL,
        notation: isCompact ? Notation.COMPACT : Notation.STANDARD,
        minimumFractionDigits: isFixed ? maximumFractionDigits : 0,
        maximumFractionDigits,
        minimumSignificantDigits: isCompact && isFixed ? maximumSignificantDigits : undefined,
        maximumSignificantDigits: isCompact ? maximumSignificantDigits : undefined
    });
    if (isPercent) {
        // remove whitespaces around ' % '
        string = string.replace(/\s?%\s?/, '%');
    }
    return `${string}${unit}`;
};

/**
 * Format number according using defined format
 * @param {number} number
 * @param {string|NumberFormat|NumberFormatConstructorOptions} [format]
 * @param {NumberFormatOptions} [options={}]
 * @return {string}
 */
const formatNumber = (number, format, options = { locale: Const.LOCALE }) => {
    let formatInstance =  new NumberFormat();
    if (format instanceof NumberFormat) {
        formatInstance = format;
    }
    if (typeof format === 'string') {
        try {
            formatInstance = NumberFormat.fromString(format);
        } catch {}
    }
    if (typeof format === 'object') {
        try {
            formatInstance = new NumberFormat(format);
        } catch {}
    }

    const handlers = {
        [NumberFormat.Type.CURRENCY]: formatCurrency,
        [NumberFormat.Type.DECIMAL]: formatDecimal
    };
    const { type, pattern } = formatInstance;
    if (handlers[type]) {
        return handlers[type](number, pattern, options);
    }
    throw new Error(`Number format type "${type}" not implemented`);
};

/**
 * Create format number function
 * @param {string|NumberFormat|NumberFormatConstructorOptions} [format]
 * @param {NumberFormatOptions} [options={}]
 * @return {typeof formatNumber}
 */
const createFormatNumber = ({ format: formatDefault, options: optionsDefault } = {}) => {
    return (number, format, options) => {
        // if format is null, undefined or empty string use formatDefault
        return formatNumber(number, format || formatDefault, options ?? optionsDefault);
    }
}

export { NumberFormat, NumberFormatPattern, formatCurrency, formatDecimal, formatNumber, createFormatNumber };
