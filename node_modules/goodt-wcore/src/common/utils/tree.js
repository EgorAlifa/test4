// @ts-check

/**
 * @typedef {import('./tree').AppEntityElem} AppEntityElem
 * @typedef {import('./tree').TMapper} TMapper
 */

export class Queue {
    _array = [];

    _mapper = () => (node) => node;

    /**
     * @template Node
     * @param {Node[]} [array] - started array of nodes
     * @param {TMapper} [mapper]
     */
    constructor(array = [], { mapper } = {}) {
        if (mapper != null) {
            this._mapper = mapper;
        }
        this.enqueue(array);
    }

    /**
     * @template Node
     * @param {Node[]} nodes - nodes for interaction
     * @param {(Node|null)=null} args - parent node of nodes
     */
    enqueue(nodes, ...args) {
        this._array.push(...nodes.map(this._mapper(...args)));
    }

    /**
     * @template Node
     * @return {[Node, Node]} - first element in queue
     */
    dequeue() {
        return this._array.shift();
    }

    /**
     * @return {boolean} - shows queue is empty or not
     */
    get isEmpty() {
        return this._array.length === 0;
    }
}

/**
 * AppEntityElem mapper for Queue
 * @type {TMapper<AppEntityElem, [AppEntityElem|null], [AppEntityElem, AppEntityElem|null]>}
 */
const AppEntityElemMapper =
    (parent) =>
        (node) =>
            [node, parent];

/**
 * finds node in the tree by the "match" function and returns it
 * @param {AppEntityElem[]} array
 * @param {string} childrenProp
 * @param {(node: AppEntityElem) => boolean} match
 * @return {AppEntityElem|null}
 */
function findNode(array, childrenProp, match) {
    const nodeQueue = new Queue(array, { mapper: AppEntityElemMapper });

    while (!nodeQueue.isEmpty) {
        const [currentNode] = nodeQueue.dequeue();
        if (match(currentNode)) {
            return currentNode;
        }
        nodeQueue.enqueue(currentNode[childrenProp], currentNode);
    }

    return null;
}

/**
 * find parent of node in the tree by the "match" function and returns it
 * @param {AppEntityElem[]} array
 * @param {string} childrenProp
 * @param {(node: AppEntityElem) => boolean} match
 * @return {Object|null}
 */
function findParentNode(array, childrenProp, match) {
    const nodeQueue = new Queue(array, { mapper: AppEntityElemMapper });

    while (!nodeQueue.isEmpty) {
        const [currentNode] = nodeQueue.dequeue();
        // eslint-disable-next-line no-restricted-syntax
        for (const childNode of currentNode[childrenProp]) {
            if (match(childNode)) {
                return currentNode;
            }
        }
        nodeQueue.enqueue(currentNode[childrenProp], currentNode);
    }

    return null;
}

/**
 * finds node in the tree by the "match" function, delete it and returns boolean
 * @param {AppEntityElem[]} array
 * @param {string} childrenProp
 * @param {(node: AppEntityElem) => boolean} match
 * @return {boolean}
 */
function deleteNode(array, childrenProp, match) {
    const nodeQueue = new Queue(array, { mapper: AppEntityElemMapper });

    while (!nodeQueue.isEmpty) {
        const [currentNode, parentNode] = nodeQueue.dequeue();
        if (match(currentNode)) {
            const currentNodeIndex = parentNode[childrenProp].findIndex(match);
            parentNode[childrenProp].splice(currentNodeIndex, 1);
            return true;
        }
        nodeQueue.enqueue(currentNode[childrenProp], currentNode);
    }

    return false;
}

/**
 * apply callback function for each node in the tree or subtree
 * @param {AppEntityElem[]} array
 * @param {string} childrenProp
 * @param {(node: AppEntityElem, parentNode?: AppEntityElem) => void} callback
 */
function traverse(array, childrenProp, callback) {
    const nodeQueue = new Queue(array, { mapper: AppEntityElemMapper });

    while (!nodeQueue.isEmpty) {
        const [currentNode, parentNode] = nodeQueue.dequeue();
        callback(currentNode, parentNode);
        nodeQueue.enqueue(currentNode[childrenProp], currentNode);
    }
}

export { traverse, findNode, findParentNode, deleteNode };
