<template>
    <div class="grid">
        <ui-button id="drilldown-add" :disabled="!canAddDrilldown" @click="onDrilldownAdd">
            Добавить сложное измерение
        </ui-button>

        <ui-has-two-columns>
            <template #left>
                <ui-button type="secondary" class="w-100" @click="onAllEntitiesEnable">Выбрать все</ui-button>
            </template>
            <template #right>
                <ui-button type="secondary" class="w-100" @click="onAllEntitiesDisable">Сбросить все</ui-button>
            </template>
        </ui-has-two-columns>

        <ui-draggable
            v-if="selectedEntities.length"
            v-model="orderMutable"
            v-bind="dragOptions"
            class="grid"
            @change="onOrderChange">
            <div class="grid-item" v-for="(entity, index) in selectedEntities" :key="entity.name">
                <input
                    class="checkbox checkbox-small mar-top-2"
                    type="checkbox"
                    checked
                    :disabled="entity.type === EntityType.DRILLDOWN"
                    @change="onEntityRelease(entity)" />
                <div class="grid-item--content">
                    <ui-destruct
                        :of="
                            $getQueryEntityError(
                                [EntityType.METRIC, EntityType.DIMENSION, EntityType.DRILLDOWN],
                                entity.name
                            ) || {}
                        ">
                        <template #is="{ message }">
                            <div>
                                <ui-entity-badge-error v-if="message" :message="message">
                                    {{ entity.name }}
                                </ui-entity-badge-error>
                                <ui-entity-badge v-else draggable :type="entity.type" class="draggable">
                                    <ui-icon
                                        name="library-shelves"
                                        size="small"
                                        :box="false"
                                        v-if="$hasEntityTemplate(entity.name)"
                                        class="mar-right-2 color-grey"></ui-icon>
                                    <span>{{ entity.name }}</span>
                                </ui-entity-badge>
                            </div>
                        </template>
                    </ui-destruct>
                </div>
                <div v-if="entity.type === EntityType.DRILLDOWN">
                    <ui-icon name="pencil" @click="onDrilldownEdit(entity.name, index)"></ui-icon>
                    <ui-icon :id="`entity-${index}`" name="layers-off-outline" @click="onDrilldownRelease(entity)"></ui-icon>
                </div>
            </div>
        </ui-draggable>
        <template v-if="freeEntities.length">
            <hr v-if="selectedEntities.length !== 0" />
            <div class="grid">
                <div v-for="entity in freeEntities" :key="entity.name">
                    <input class="checkbox checkbox-small mar-right-3" type="checkbox" @change="onEntityUse(entity)" />
                    <ui-entity-badge :type="entity.type">
                        <ui-icon
                            name="library-shelves"
                            size="small"
                            :box="false"
                            v-if="$hasEntityTemplate(entity.name)"
                            class="mar-right-2 color-grey"></ui-icon>
                        <span>{{ entity.name }}</span>
                    </ui-entity-badge>
                </div>
            </div>
        </template>

        <ui-float-panel :target="editorTarget" @close="isEditorShown = false" v-if="isEditorShown">
            <ui-drilldown-panel
                v-bind="{
                    drilldown: editDrilldown,
                    drilldownNames,
                    dimensionNames,
                    dimensionNamesFree,
                    metricNames
                }"
                @save="onDrilldownSave"></ui-drilldown-panel>
        </ui-float-panel>
        <!-- <pre class="text-xsmall">{{ model.order }}</pre> -->
    </div>
</template>
<script>
import { cloneDeep } from 'lodash';
import UiDraggable from 'vuedraggable';
import { UiButton, UiHasTwoColumns } from '@goodt-wcore/panel-ui';
import { Destruct as UiDestruct, UiIcon } from '@goodt-wcore/components';
import UiDrilldownPanel from './DrilldownPanel.vue';
import UiEntityBadge from '../../shared/EntityBadge.vue';
import UiEntityBadgeError from '../../shared/EntityBadgeError.vue';
import UiFloatPanel from '../../shared/FloatPanel.vue';
import UiTooltipError from '../../shared/TooltipError.vue';
import { EntityType } from '../../../const';

/**
 * @typedef {import('@goodt-common/data').IDatasetEntity} IDatasetEntity
 * @typedef {import('@goodt-common/data').IDatasetQueryDrilldown} IDatasetQueryDrilldown
 * @typedef {import('@goodt-common/data').QueryModelBase} QueryModelBase
 */

export default {
    components: {
        UiButton,
        UiIcon,
        UiHasTwoColumns,
        UiDraggable,
        UiEntityBadge,
        UiEntityBadgeError,
        UiDestruct,
        UiFloatPanel,
        UiDrilldownPanel,
        UiTooltipError
    },
    inject: ['$hasEntityTemplate', '$getQueryEntityError'],
    props: {
        /** @type {import('vue').PropOptions<QueryModelBase>} */
        model: { type: Object, default: null },
        /** @type {import('vue').PropOptions<IDatasetEntity[]>} */
        availableMetrics: { type: Array, default: () => [] },
        /** @type {import('vue').PropOptions<IDatasetEntity[]>} */
        availableDimensions: { type: Array, default: () => [] }
    },
    data() {
        return {
            orderMutable: [],
            isEditorShown: false,
            editorTarget: null,
            editDrilldown: null
        };
    },
    static: {
        dragOptions: {
            animation: 200,
            handle: '.draggable'
        },
        EntityType
    },
    computed: {
        canAddDrilldown() {
            return this.dimensionNamesFree.length > 1;
        },
        dimensionNamesFree() {
            /** @type {{ model:QueryModelBase }} */
            const { model } = this;
            const drilldownDimensions = model.drilldowns.map(({ dimensions }) => dimensions).flat();
            return model.dimensions.filter((name) => drilldownDimensions.includes(name) === false);
        },
        dimensionNames() {
            /** @type {{ model:QueryModelBase }} */
            const { model } = this;
            return model.dimensions;
        },
        metricNames() {
            /** @type {{ model:QueryModelBase }} */
            const { model } = this;
            return model.metrics;
        },
        drilldownNames() {
            /** @type {{ model:QueryModelBase }} */
            const { model } = this;
            return model.drilldowns
                .map(({ name }) => name)
                .sort((a, b) => model.order.indexOf(a) - model.order.indexOf(b));
        },
        /**
         * @return {{ name:string, type:string }[]}
         */
        selectedEntities() {
            /** @type {{ model:QueryModelBase }} */
            const { model } = this;
            const drilldownDimensions = model.drilldowns.map(({ dimensions }) => dimensions).flat();
            const drilldowns = model.drilldowns.map(({ name }) => ({ name, type: EntityType.DRILLDOWN }));
            const metrics = model.metrics.map((name) => ({ name, type: EntityType.METRIC }));
            const dimensions = model.dimensions
                .map((name) => ({ name, type: EntityType.DIMENSION }))
                .filter(({ name }) => drilldownDimensions.includes(name) === false);

            const entities = [...drilldowns, ...dimensions, ...metrics].sort((a, b) => {
                const i = model.order.indexOf(a.name);
                const j = model.order.indexOf(b.name);
                return i - j;
            });
            return entities;
        },
        /**
         * @return {{ name:string, type:string }[]}
         */
        freeEntities() {
            /** @type {{ availableDimensions:IDatasetEntity[], availableMetrics:IDatasetEntity[], model:QueryModelBase }} */
            const { availableDimensions, availableMetrics, model } = this;
            const drilldownDimensions = model.drilldowns.map((item) => item.dimensions).flat();

            const freeMetrics = availableMetrics
                .map(({ name }) => ({ name, type: EntityType.METRIC }))
                .filter((item) => model.metrics.includes(item.name) === false);
            const freeDimensions = availableDimensions
                .map(({ name }) => ({ name, type: EntityType.DIMENSION }))
                .filter(
                    (item) =>
                        drilldownDimensions.includes(item.name) === false &&
                        model.dimensions.includes(item.name) === false
                );
            return [...freeDimensions, ...freeMetrics];
        }
    },
    watch: {
        'model.order': {
            handler(val) {
                this.orderMutable = [...val];
            },
            immediate: true
        }
    },
    methods: {
        /**
         * @param {{ drilldown:IDatasetQueryDrilldown, target:string }} options
         */
        showEditor({ drilldown = null, target }) {
            this.editDrilldown = drilldown;
            this.editorTarget = target;
            this.isEditorShown = true;
        },
        onDrilldownAdd() {
            this.showEditor({ target: '#drilldown-add' });
        },
        /**
         * @param {string} name
         * @return {string[]}
         */
        getDrilldownDimensions(name) {
            const drilldown = this.model.drilldowns.find((item) => item.name === name);
            return drilldown?.dimensions ?? [];
        },
        /**
         *
         * @param {{ drilldown:IDatasetQueryDrilldown, index:number }} options
         */
        onDrilldownSave({ drilldown, nameOld }) {
            /** @type {{ model:QueryModelBase }} */
            const { model } = this;
            const { metrics, dimensions, order, drilldowns } = model;
            const drilldownIndex = drilldowns.findIndex(({ name }) => name === nameOld);
            let drilldownsNew = [...drilldowns];
            let orderNew = [...order];
            // add new
            if (drilldownIndex < 0) {
                const [firstDimension] = drilldown.dimensions;
                const firstDimensionOrderIndex = orderNew.indexOf(firstDimension);
                // add drilldown
                drilldownsNew.push(drilldown);
                // add drilldown.name to order
                orderNew.splice(firstDimensionOrderIndex, 0, drilldown.name);
                // remove drilldown dimensions from order
                orderNew = orderNew.filter((name) => drilldown.dimensions.includes(name) === false);
            }
            // update existed
            else {
                const oldDrilldown = drilldowns[drilldownIndex];
                // release old drilldown dimensions
                orderNew.push(...oldDrilldown.dimensions);
                // replace drilldown nameOld -> name
                const oldDrilldownOrderIndex = orderNew.findIndex((name) => name === nameOld);
                orderNew.splice(oldDrilldownOrderIndex, 1, drilldown.name);
                // remove new dimensions
                orderNew = orderNew.filter((name) => drilldown.dimensions.includes(name) === false);
                // replace the drilldown
                drilldownsNew.splice(drilldownIndex, 1, drilldown);
            }

            const payload = {
                order: orderNew,
                metrics,
                dimensions,
                drilldowns: drilldownsNew
            };
            this.emitChange({ ...model, ...payload });
            this.isEditorShown = false;
        },
        /**
         * @param {{ name:string, type:string }} options
         */
        onEntityUse({ name, type }) {
            /** @type {{ model:QueryModelBase }} */
            const { model } = this;
            const { metrics, dimensions, order, drilldowns } = model;
            const payload = {
                order: [...order, name],
                metrics: type === EntityType.METRIC ? [...metrics, name] : metrics,
                dimensions: type === EntityType.DIMENSION ? [...dimensions, name] : dimensions,
                drilldowns
            };
            this.emitChange({ ...model, ...payload });
        },
        /**
         * @param {{ name:string, type:string }} options
         */
        onEntityRelease({ name, type }) {
            /** @type {{ model:QueryModelBase }} */
            const { model } = this;
            const { metrics, dimensions, order, drilldowns } = model;
            const payload = {
                order: order.filter((item) => item !== name),
                metrics: metrics.filter((item) => item !== name),
                dimensions: dimensions.filter((item) => item !== name),
                drilldowns: drilldowns.filter((item) => item.name !== name)
            };
            this.emitChange({ ...model, ...payload });
        },
        /**
         * @param {{ name:string, type:string }} options
         */
        onDrilldownRelease({ name, type }) {
            /** @type {{ model:QueryModelBase }} */
            const { model } = this;
            const { metrics, dimensions, order, drilldowns } = model;
            const drilldown = drilldowns.find((item) => item.name === name);
            if (drilldown == null) {
                return;
            }
            const drilldownOrderIndex = order.indexOf(drilldown.name);
            const orderNew = [...order];
            orderNew.splice(drilldownOrderIndex, 1, ...drilldown.dimensions);
            const payload = {
                order: orderNew,
                metrics,
                dimensions: [...dimensions, ...drilldown.dimensions],
                drilldowns: drilldowns.filter((item) => item.name !== name)
            };
            this.emitChange({ ...model, ...payload });
            this.isEditorShown = false;
        },
        /**
         * @param {string} name
         * @param {number} index
         */
        onDrilldownEdit(name, index) {
            /** @type {{ model:QueryModelBase }} */
            const { model } = this;
            const drilldown = model.drilldowns.find((item) => item.name === name);
            if (drilldown == null) {
                return;
            }
            this.showEditor({ drilldown: cloneDeep(drilldown), target: `#entity-${index}` });
        },
        onOrderChange() {
            /** @type {{ model:QueryModelBase }} */
            const { model, orderMutable } = this;
            const payload = {
                order: orderMutable,
                metrics: model.metrics,
                dimensions: model.dimensions,
                drilldowns: model.drilldowns
            };
            this.emitChange({ ...model, ...payload });
        },
        onAllEntitiesEnable() {
            const { freeEntities } = this;
            if (freeEntities.length === 0) {
                return;
            }
            /** @type {{ model:QueryModelBase }} */
            const { model } = this;
            const { metrics, dimensions, order } = model;
            const metricsNew = freeEntities.filter(({ type }) => type === EntityType.METRIC).map(({ name }) => name);
            const dimensionsNew = freeEntities
                .filter(({ type }) => type === EntityType.DIMENSION)
                .map(({ name }) => name);
            const payload = {
                order: [...order, ...freeEntities.map(({ name }) => name)],
                metrics: [...metrics, ...metricsNew],
                dimensions: [...dimensions, ...dimensionsNew],
                drilldowns: []
            };
            this.emitChange({ ...model, ...payload });
        },
        onAllEntitiesDisable() {
            const { selectedEntities } = this;
            if (selectedEntities.length === 0) {
                return;
            }
            /** @type {{ model:QueryModelBase }} */
            const { model } = this;
            const payload = {
                order: [],
                metrics: [],
                dimensions: [],
                drilldowns: []
            };
            this.emitChange({ ...model, ...payload });
        },
        /**
         * @param {{ metrics:string[], dimensions:string[], order:string[], drilldown: { name:string, dimensions:string[] }[] }} payload
         */
        emitChange(payload) {
            this.$emit('change', payload);
        }
    }
};
</script>
<style lang="pcss" scoped>
.grid {
    display: grid;
    gap: 1rem;

    &-item {
        display: grid;
        grid-template-columns: auto 1fr auto;
        gap: 0.5rem;

        &--content {
            display: grid;
            gap: 0.5rem;
            grid-template-columns: 1fr auto;
        }
    }
}
</style>
