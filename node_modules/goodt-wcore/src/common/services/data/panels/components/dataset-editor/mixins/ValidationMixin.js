import { QueryModelValidator } from '../models/query-model-validator';
import { EntityType } from '../../../const';

export default {
    provide() {
        const { getQueryEntityError: $getQueryEntityError } = this;
        return {
            $getQueryEntityError
        };
    },
    data() {
        return {
            /** @type {ValidationError[]} */
            errors: []
        };
    },
    watch: {
        errors(errors) {
            this.$handleError(errors, true, 'dataset-query-editor');
        }
    },
    computed: {
        /**
         * @return {QueryModelValidator}
         */
        queryModelValidator() {
            const { queryModel, datasetInfo } = this;
            return new QueryModelValidator({ queryModel, datasetInfo });
        },
        /**
         * @return {Record<EntityTypeEnum[keyof EntityTypeEnum], Record<string, ValidationError>>}
         */
        errorsDetails() {
            return this.errors.reduce((acc, { data }) => {
                Object.entries(data).forEach(([prop, details]) => {
                    acc[prop] = {
                        ...acc[prop],
                        ...details
                    };
                });
                return acc;
            }, {});
        },
        /**
         * @return {string[]}
         */
        errorEntityNames() {
            const errorsMap = this.getSectionErrors([EntityType.METRIC, EntityType.DIMENSION]);
            return Object.keys(errorsMap ?? {});
        }
    },
    methods: {
        /**
         * @param {EntityTypeEnum[keyof EntityTypeEnum]} sections
         * @return {boolean}
         */
        isQuerySectionHasError(sections) {
            return [sections].flat().some((section) => this.errorsDetails[section] != null);
        },
        /**
         *
         * @param {EntityTypeEnum[keyof EntityTypeEnum][]} sections
         * @return {Record<string, { message: MessageI18n }>}
         */
        getSectionErrors(sections) {
            sections = [sections].flat().filter(this.isQuerySectionHasError);
            return sections.reduce(
                (acc, section) => ({
                    ...acc,
                    ...this.errorsDetails[section]
                }),
                {}
            );
        },
        /**
         *
         * @param {EntityTypeEnum[keyof EntityTypeEnum][]} sections
         * @param {string} name
         * @return {null | { message: MessageI18n }}
         */
        getQueryEntityError(sections, name) {
            sections = [sections].flat().filter((section) => this.errorsDetails[section] != null);
            const errorsMap = this.getSectionErrors(sections);
            return errorsMap[name] ?? null;
        },
        /**
         *
         */
        validateQueryModel() {
            this.errors = [...this.queryModelValidator.validate(), ...this.queryModel.validate()];
        }
    }
};
