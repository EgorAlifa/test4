<template>
    <ui-grid-layout>
        <template #left>
            <ui-sidebar chromeless class="pos-rel">
                <ui-shim :z-index="2" overlay v-if="datasetInfo.error">
                    <ui-hero-placeholder icon="alert-circle-outline">Ошибка</ui-hero-placeholder>
                </ui-shim>
                <div class="aside pad-l2">
                    <ui-sidebar-collapse open icon="speedometer" :loading="datasetInfo.isLoading">
                        <template #header>Метрики/измерения</template>
                        <template #tools>
                            <ui-tooltip-error
                                v-if="
                                    isQuerySectionHasError([
                                        EntityType.METRIC,
                                        EntityType.DIMENSION,
                                        EntityType.DRILLDOWN
                                    ])
                                "
                                message="Есть ошибки"></ui-tooltip-error>
                            <span
                                class="text-xsmall"
                                v-if="queryModel.metrics.length + queryModel.dimensions.length > 0">
                                {{ queryModel.metrics.length + queryModel.dimensions.length }}
                            </span>
                        </template>
                        <ui-entities
                            v-bind="{
                                model: queryModel,
                                availableMetrics: datasetInfo.metrics,
                                availableDimensions: datasetInfo.dimensions
                            }"
                            @change="onQueryParamsChanged"></ui-entities>
                    </ui-sidebar-collapse>

                    <ui-sidebar-collapse
                        icon="variable"
                        v-bind="{
                            loading: datasetInfo.isLoading,
                            disabled: !hasVariables,
                            ...(hasVariables || { open: false })
                        }">
                        <template #header>
                            <span>Переменные</span>
                        </template>
                        <template #tools>
                            <ui-tooltip-error
                                v-if="isQuerySectionHasError(EntityType.VARIABLE)"
                                message="Есть ошибки"></ui-tooltip-error>
                            <span class="text-xsmall" v-if="queryModel.variables.length">
                                {{ queryModel.variables.length }}
                            </span>
                        </template>
                        <ui-variables
                            v-bind="{
                                variables: queryModel.variables,
                                availableVariables: datasetInfo.variables
                            }"
                            @change="onVariablesChanged">
                        </ui-variables>
                    </ui-sidebar-collapse>

                    <ui-sidebar-collapse icon="filter" :loading="datasetInfo.isLoading">
                        <template #header>Фильтры</template>
                        <template #tools>
                            <ui-tooltip-error
                                v-if="isQuerySectionHasError(EntityType.FILTER)"
                                message="Есть ошибки"></ui-tooltip-error>
                            <span class="text-xsmall" v-if="queryModel.filters.length">
                                {{ queryModel.filters.length }}
                            </span>
                        </template>
                        <ui-filters
                            v-bind="{
                                filters: queryModel.filters,
                                names: [...metricAndDimensionNameOptions, ...fieldNameOptions],
                                operators: QueryFilterOperatorOptions,
                                placeholders: QueryFilterPlaceholders
                            }"
                            @change="onFiltersChanged"></ui-filters>
                    </ui-sidebar-collapse>

                    <ui-sidebar-collapse icon="sort" :loading="datasetInfo.isLoading">
                        <template #header>Сортировка</template>
                        <template #tools>
                            <ui-tooltip-error
                                v-if="isQuerySectionHasError(EntityType.SORT)"
                                message="Есть ошибки"></ui-tooltip-error>
                            <span class="text-xsmall" v-if="queryModel.sort.length">
                                {{ queryModel.sort.length }}
                            </span>
                        </template>
                        <ui-sort
                            v-bind="{
                                sort: queryModel.sort,
                                names: metricAndDimensionNameOptions,
                                directions: QuerySortDirectionOptions
                            }"
                            @change="onSortChange"></ui-sort>
                    </ui-sidebar-collapse>

                    <ui-sidebar-collapse icon="content-copy" :loading="datasetInfo.isLoading">
                        <template #header>
                            <div class="collapse-header">Пагинация</div>
                        </template>
                        <template #tools>
                            <span class="text-xsmall" v-if="limit > 0" :title="`По ${limit} записей`">
                                {{ limit }}
                            </span>
                        </template>
                        <ui-pagination :limit="limit" @change="onLimitChange"></ui-pagination>
                    </ui-sidebar-collapse>
                </div>
            </ui-sidebar>
        </template>
        <template #center>
            <div class="dataset-preview">
                <ui-preview
                    v-bind="{
                        ...datasetPreview.result,
                        isLoading: datasetPreview.isLoading,
                        limit: datasetPreview.limit,
                        sort: queryModel.sort,
                        filters: queryModel.filters,
                        columns: previewColumns
                    }"
                    @filter-change="onDatasetPreviewFilterChange"
                    @sort-change="onDatasetPreviewSortChange"
                    @page-change="onDatasetPreviewPageChange">
                    <template #header-cell="{ isLoading, column, letter, onSortChange, onFilterChange }">
                        <ui-preview-header-cell
                            v-bind="{ isLoading, letter, ...column }"
                            @sort-change="(direction) => onSortChange(direction)"
                            @filter-change="(target) => onFilterChange(target)">
                            <template #default="{ isSorted, isSortable, toggleSort }">
                                <ui-entity-badge-error
                                    v-if="getQueryEntityError(['metrics', 'dimensions', 'drilldowns'], column.name)">
                                    {{ column.name }}
                                </ui-entity-badge-error>
                                <ui-entity-badge
                                    v-else
                                    v-bind="{
                                        type: getQueryEntityType(column.name),
                                        multiline: false
                                    }"
                                    :clickable="isSortable">
                                    <ui-icon
                                        v-if="hasEntityTemplate(column.name)"
                                        name="library-shelves"
                                        size="small"
                                        :box="false"
                                        class="mar-right-2 color-grey"></ui-icon>
                                    <span :class="{ link: isSorted }" @click="toggleSort">{{ column.name }}</span>
                                </ui-entity-badge>
                                <span class="mar-left-1 text-xsmall" v-if="column.name !== column.alias">
                                    ({{ column.alias }})
                                </span>
                            </template>
                            <template #type v-if="column.type">{{ column.type }}</template>
                        </ui-preview-header-cell>
                    </template>
                    <template #footer>
                        <span role="button" class="link" @click="datasetInfo.isDebug = true">
                            Отладочная информация
                        </span>
                        <span
                            role="button"
                            class="badge badge-error mar-left-3 text-xsmall cursor-pointer"
                            :class="{ 'is-hidden': datasetPreview.error == null }"
                            @click="datasetPreview.isErrorDebug = true">
                            ошибка
                        </span>
                        <ui-popup :visible.sync="datasetInfo.isDebug">
                            <template #body>
                                <div class="debug-info">
                                    <code>датасет.def</code>
                                    <div class="pos-rel p">
                                        <pre class="debug-info__code text-xsmall">{{ datasetInfo.dataset }}</pre>
                                        <div
                                            class="btn btn-secondary btn-icon btn-small pos-abs pos-bot-right mar-1"
                                            @click="$writeToClipboard(datasetInfo.dataset)">
                                            <i class="mdi mdi-content-copy"></i>
                                        </div>
                                    </div>
                                    <div class="pos-rel">
                                        <code>датасет.sql</code>
                                        <pre class="debug-info__code text-xsmall text-preline">{{
                                            datasetPreview.result.sql
                                        }}</pre>
                                        <div
                                            class="btn btn-secondary btn-icon btn-small pos-abs pos-bot-right mar-1"
                                            @click="$writeToClipboard(datasetPreview.result.sql)">
                                            <i class="mdi mdi-content-copy"></i>
                                        </div>
                                    </div>
                                </div>
                            </template>
                        </ui-popup>

                        <ui-popup :visible.sync="datasetPreview.isErrorDebug">
                            <template #body>
                                <div class="debug-info">
                                    <h3>Ошибка</h3>
                                    <div class="alert alert-error">
                                        <div class="alert-body">
                                            <div>Возможные причины:</div>
                                            <ul>
                                                <li>отсутствие агрегаций у метрик;</li>
                                                <li>неправильные названия полей;</li>
                                                <li>опечатки.</li>
                                            </ul>
                                            <div class="p">Проверьте настройки запроса.</div>
                                            <pre class="debug-info__code text-xsmall text-preline">
<span class="link"
      @click="datasetPreview.isErrorShortMode = !datasetPreview.isErrorShortMode">подробности</span>
{{ previewErrorMessageAdaptive }}</pre>
                                        </div>
                                        <div
                                            class="btn btn-secondary btn-icon btn-small pos-abs pos-bot-right mar-1"
                                            @click="$writeToClipboard(datasetPreview.error.toString())">
                                            <i class="mdi mdi-content-copy"></i>
                                        </div>
                                    </div>
                                </div>
                            </template>
                        </ui-popup>
                    </template>
                </ui-preview>
            </div>

            <ui-float-panel
                position="bottom"
                :target="filterEditor.target"
                @close="filterEditor.isShown = false"
                v-if="filterEditor.isShown">
                <ui-filter-panel
                    v-bind="{
                        deletable: true,
                        filter: filterEditor.filter,
                        filters: queryModel.filters,
                        nameDefault: filterEditor.name,
                        names: [...metricAndDimensionNameOptions, ...fieldNameOptions],
                        operators: QueryFilterOperatorOptions,
                        placeholders: QueryFilterPlaceholders
                    }"
                    @save="onFilterEditorSave"
                    @delete="onFilterEditorDelete"></ui-filter-panel>
            </ui-float-panel>
        </template>
    </ui-grid-layout>
</template>
<script>
import { isEqual } from 'lodash';
import {
    QuerySortDirection,
    QueryFilterOperator,
    QueryFilterOperatorLabel,
    QueryFilterPlaceholder,
    DatasetRequestFactory,
    QueryModelExtended,
    DatasetEditorMessages
} from '@goodt-common/data';
import { DatasetManager } from '@goodt-wcore/managers';
import { ApiServiceError } from '@goodt-common/api';

import { DatasetEntityType, compareEntityType } from '../../../services/service';
import { EntityType, ToastMessage } from '../../const';

import { Popup as UiPopup } from '@goodt-wcore/components';
import { UiIcon, UiPreloader, UiShim, UiSidebar, UiHeroPlaceholder } from '@goodt-wcore/components';

import UiGridLayout from '../shared/GridLayout.vue';
import UiFloatPanel from '../shared/FloatPanel.vue';
import UiEntityBadge from '../shared/EntityBadge.vue';
import UiEntityBadgeError from '../shared/EntityBadgeError.vue';
import UiTooltipError from '../shared/TooltipError.vue';

import UiSidebarCollapse from './SidebarCollapse.vue';
import UiEntities from './entities/index.vue';
import UiSort from './sort/index.vue';
import UiFilters from './filter/index.vue';
import UiVariables from './variables/index.vue';
import UiPagination from './pagination/index.vue';
import UiPreview from './preview/index.vue';
import UiPreviewHeaderCell from './preview/HeaderCell.vue';
import UiFilterPanel from './filter/FilterPanel.vue';

import ValidationMixin from './mixins/ValidationMixin';

/**
 * @typedef {import('@goodt-common/domain').ValidationError} ValidationError
 * @typedef {import('@goodt-common/api').ApiServiceError} ApiServiceError
 * @typedef {import('@goodt-common/data').IProjectDataProviderConnector} IProjectDataProviderConnector
 * @typedef {import('@goodt-common/data').IDatasetRequestProps} IDatasetRequestProps
 * @typedef {import('@goodt-common/data').IDatasetQuery} IDatasetQuery
 * @typedef {import('@goodt-common/data').IDataset} IDataset
 * @typedef {import('@goodt-common/data').IDatasetEntity} IDatasetEntity
 * @typedef {import('@goodt-common/data').IDatasetVariable} IDatasetVariable
 * @typedef {import('@goodt-common/data').IQueryFilterInfo} IQueryFilterInfo
 * @typedef {import('@goodt-common/data').IQueryVariableInfo} IQueryVariableInfo
 * @typedef {import('@goodt-common/data').IQuerySortInfo} IQuerySortInfo
 * @typedef {import('@goodt-common/data').IDatasetResult} IDatasetResult
 * @typedef {import('@goodt-common/data').Request} DatasetRequest
 * @typedef {import('@goodt-common/data').QueryModelExtended} QueryModelExtended
 * @typedef {import('@goodt-common/data').DataClient} DataClient
 * @typedef {import('@goodt-common/data').DataClientService} DataClientService
 * @typedef {import('@goodt-common/utils').MessageI18n} MessageI18n
 * @typedef {import('@goodt-wcore/components').ISelectOption} ISelectOption
 * @typedef {typeof import('../../const').EntityType} EntityTypeEnum
 * @typedef {EntityTypeEnum[keyof EntityTypeEnum]} EntityTypeEnumKeys
 */
export default {
    components: {
        UiFilters,
        UiVariables,
        UiSort,
        UiPreview,
        UiPreviewHeaderCell,
        UiFilterPanel,
        UiFloatPanel,
        UiGridLayout,
        UiEntities,
        UiHeroPlaceholder,
        UiEntityBadge,
        UiEntityBadgeError,
        UiTooltipError,
        UiSidebarCollapse,
        UiSidebar,
        UiPagination,
        UiPopup,
        UiIcon,
        UiPreloader,
        UiShim
    },
    mixins: [ValidationMixin],
    provide() {
        const {
            hasEntityTemplate: $hasEntityTemplate,
            getQueryEntityType: $getQueryEntityType
        } = this;
        return {
            $hasEntityTemplate,
            $getQueryEntityType
        };
    },
    inject: ['$handleError', '$showToast', '$service', '$writeToClipboard'],
    props: {
        /** @type {import('vue').PropOptions<IDatasetRequestProps>} */
        datasetProps: {
            type: Object,
            default: null
        },
        /** @type {import('vue').PropOptions<IProjectDataProviderConnector['url']>} */
        dataProviderUrl: {
            type: String,
            default: null
        }
    },
    static() {
        return {
            EntityType,
            QuerySortDirectionOptions: Object.values(QuerySortDirection).map((value) => ({ label: value, value })),
            QueryFilterOperatorOptions: Object.values(QueryFilterOperator).map((value) => ({
                label: QueryFilterOperatorLabel[value],
                value
            })),
            QueryFilterPlaceholders: Object.values(QueryFilterPlaceholder)
        };
    },
    data() {
        return {
            /** @type {QueryModelExtended|null} */
            queryModel: null,
            /** @type {DatasetRequest|null} */
            request: null,
            /** @type {number} */
            limit: 0,
            /**
             * @type {{
             *     isDebug: boolean,
             *     isLoading: boolean
             *     error: null | Error,
             *     name: string,
             *     dataset: null | IDataset
             *     metrics: IDatasetEntity[],
             *     dimensions: IDatasetEntity[],
             *     variables: IDatasetVariable[]
             * }}
             */
            datasetInfo: {
                isDebug: false,
                isLoading: false,
                error: null,
                name: '',
                dataset: null,
                metrics: [],
                dimensions: [],
                variables: []
            },
            /**
             * @type {{
             *     isErrorDebug: boolean,
             *     isErrorShortMode: boolean
             *     isLoading: boolean
             *     error: null | Error,
             *     limit: number,
             *     offset: number,
             *     result: Partial<IDatasetResult>
             * }}
             */
            datasetPreview: {
                isErrorDebug: false,
                isErrorShortMode: true,
                isLoading: false,
                limit: 20,
                offset: 0,
                result: {
                    rowCount: 0,
                    rows: []
                },
                error: null
            },
            /**
             * @type {{
             *     isShown: boolean,
             *     filter: null | IQueryFilterInfo,
             *     index: number,
             *     name: string,
             *     target: string
             * }}
             */
            filterEditor: {
                isShown: false,
                filter: null,
                index: -1,
                name: '',
                target: ''
            }
        };
    },
    computed: {
        /**
         *
         * @return {IDatasetRequestProps}
         */
        datasetRequestPropsInner() {
            const { datasetInfo, queryModel, datasetProps } = this;
            return {
                name: datasetInfo.name,
                dataProviderId: datasetProps.dataProviderId,
                query: queryModel?.raw,
                limit: this.limit
            };
        },
        /**
         * @return {(ISelectOption & { type: string, entityType: EntityType.FIELD })[]}
         */
        fieldNameOptions() {
            const { queryModel, datasetInfo } = this;
            if (datasetInfo.dataset == null) {
                return [];
            }
            const { fields } = queryModel;
            const { fields: fieldsSchema } = datasetInfo.dataset.schema;
            return fields.map((value) => {
                const typeInfo = fieldsSchema.find(({ name }) => name === value);
                return { label: value, value, type: typeInfo?.type ?? '', entityType: EntityType.FIELD };
            });
        },
        /**
         * @return {{ name:string, alias:string }[]}
         */
        previewColumns() {
            const { errorEntityNames } = this;
            const { drilldowns, order } = this.queryModel;
            const drilldownDimensions = drilldowns.reduce(
                (acc, { name, dimensions }) => ({ ...acc, [name]: dimensions[0] }),
                {}
            );

            return order
                .filter((name) => !errorEntityNames.includes(name))
                .map((name) => ({
                    name,
                    alias: drilldownDimensions[name] ?? name
                }));
        },
        /**
         * @return {(ISelectOption & { type: string, entityType: EntityType.DIMENSION | EntityType.METRIC })[]}
         */
        metricAndDimensionNameOptions() {
            const { queryModel, datasetPreview, errorEntityNames } = this;
            const { metrics, dimensions } = queryModel;
            const { schema = [] } = datasetPreview.result;
            return [
                ...dimensions.map((name) => ({
                    name,
                    entityType: EntityType.DIMENSION
                })),
                ...metrics.map((name) => ({
                    name,
                    entityType: EntityType.METRIC
                }))
            ]
                .filter(({ name }) => !errorEntityNames.includes(name))
                .map(({ name: entityName, entityType }) => {
                    const typeInfo = schema.find(({ name }) => name === entityName);
                    return { label: entityName, value: entityName, type: typeInfo?.type ?? '', entityType };
                });
        },
        /**
         * @return {string}
         */
        previewErrorMessage() {
            return this.datasetPreview.error ? this.$t(this.datasetPreview.error.message) : '';
        },
        /**
         * @return {string}
         */
        previewErrorMessageAdaptive() {
            const { datasetPreview, previewErrorMessage } = this;
            const { isErrorShortMode } = datasetPreview;
            return isErrorShortMode ? previewErrorMessage.split('\n')[0] : previewErrorMessage;
        },
        /**
         * @return {boolean}
         */
        hasVariables() {
            const { datasetInfo, queryModel } = this;
            return datasetInfo.variables.length + queryModel.variables.length > 0;
        }
    },
    watch: {
        'datasetInfo.dataset'(dataset) {
            if (dataset != null) {
                const { browseDataset } = this;
                this.$emit('api', {
                    browseDataset: browseDataset.bind(this)
                });
            }
        },
        dataProviderUrl: {
            handler(dataProviderUrl) {
                if (dataProviderUrl == null) {
                    this.datasetInfo.error = new Error(
                        DatasetEditorMessages.DATASET_DATAPROVIDER_NOT_EXISTS_IN_PROJECT
                    );
                    return;
                }
                // non-blocking async call
                this.fetchDatasetInfo(this.queryModel.from);
            }
        },
        datasetProps: {
            /**
             *
             * @param {IDatasetRequestProps|null} datasetProps
             */
            handler(datasetProps) {
                if (isEqual(datasetProps, this.datasetRequestPropsInner)) {
                    return;
                }
                this.limit = datasetProps.limit;
                this.request = DatasetRequestFactory(datasetProps, { clientConfig: { isAdmin: true } });
                this.queryModel = new QueryModelExtended(datasetProps.query);
                if (this.dataProviderUrl != null) {
                    // non-blocking async call
                    this.fetchDatasetInfo(this.queryModel.from);
                }
            },
            immediate: true
        },
        datasetRequestPropsInner: {
            handler(options, oldOptions) {
                if (isEqual(options, oldOptions)) {
                    return;
                }

                this.request.options = options;
                this.updatePreview();
            },
            deep: true
        }
    },
    methods: {
        getQueryEntityType(name) {
            const { metrics, fields, dimensions, drilldowns } = this.queryModel;
            if (dimensions.includes(name)) {
                return EntityType.DIMENSION;
            }
            if (metrics.includes(name)) {
                return EntityType.METRIC;
            }
            const drilldownFound = drilldowns.find((item) => item.name === name);
            if (drilldownFound != null) {
                return EntityType.DRILLDOWN;
            }
            if (fields.includes(name)) {
                return EntityType.FIELD;
            }
            return null;
        },
        /**
         * @public
         * @param {{ connectorId: IProjectDataProviderConnector['id'] }} options
         */
        async browseDataset({ connectorId }) {
            const { datasetInfo } = this;
            const { id: datasetId } = datasetInfo.dataset;

            const result = await DatasetManager.instance.browse({
                connectorId,
                datasetId
            });
            if (result != null) {
                // non-blocking async call
                await this.setDatasetFromCode(result.datasetCode);
            }
        },
        /**
         * @param {string} code
         */
        async setDatasetFromCode(code) {
            // need to fetch and sync local dataset meta
            await this.fetchDatasetInfo(code, true);
        },
        /**
         * @return {DataClientService}
         */
        getService() {
            /** @type {{ $service: DataClientService, dataProviderUrl: string }} */
            const { $service, dataProviderUrl: url } = this;
            return $service.context({ url });
        },
        /**
         *
         * @param {{ dataset:IDataset, entities:IDatasetEntity[], variables: IDatasetVariable[] }} options
         * @effect {datasetInfo}
         */
        setDatasetInfo({ dataset, entities, variables }) {
            const { datasetInfo } = this;
            datasetInfo.name = dataset.name;
            datasetInfo.dataset = dataset;
            datasetInfo.metrics = entities.filter((entity) => compareEntityType(entity, DatasetEntityType.METRIC));
            datasetInfo.dimensions = entities.filter((entity) =>
                compareEntityType(entity, DatasetEntityType.DIMENSION)
            );
            datasetInfo.variables = variables;
        },
        /**
         * @param {boolean} invalidateQuery
         */
        syncQueryModel(invalidateQuery = false) {
            const { queryModel, datasetInfo } = this;
            const {
                metrics,
                dimensions,
                dataset: {
                    code,
                    schema: { fields }
                }
            } = datasetInfo;
            const fieldNames = fields.map(({ name }) => name);
            const metricNames = metrics.map(({ name }) => name);
            const dimensionNames = dimensions.map(({ name }) => name);

            // sync, might've changed
            queryModel.from = code;
            // sync, might've changed
            queryModel.fields = fieldNames;

            // invalidate entities (they might've changed); if all entities are gone -> select all avail
            if (invalidateQuery) {
                queryModel.dimensions = queryModel.dimensions.filter((name) => dimensionNames.includes(name));
                queryModel.metrics = queryModel.metrics.filter((name) => metricNames.includes(name));
            }
            this.validateQueryModel();
        },
        /**
         * @param {string} code
         * @param {boolean} [invalidateQuery=false]
         * @effect {datasetInfo}
         */
        async fetchDatasetInfo(code, invalidateQuery = false) {
            const { datasetInfo, datasetPreview } = this;
            datasetInfo.error = null;
            datasetInfo.isLoading = true;

            const service = this.getService();
            const datasetSR = await service.dataset.getByCode({ code });
            if (datasetSR.isError) {
                /*** @type { error: ApiServiceError }*/
                let { error } = datasetSR;
                if (error instanceof ApiServiceError && error.code === ApiServiceError.Code.NOT_FOUND) {
                    error = new Error(DatasetEditorMessages.DATASET_NOT_FOUND_IN_DATA_PROVIDER);
                }
                this.$handleError(error);
                datasetInfo.error = error;
                datasetInfo.isLoading = false;
                datasetPreview.isLoading = false;
                return;
            }
            /** @type {IDataset} */
            const dataset = datasetSR.result;
            const entitiesSR = await service.datasetEntity.getAll({ datasetId: dataset.id });
            if (entitiesSR.isError) {
                /*** @type { error: ApiServiceError }*/
                const { error } = entitiesSR;
                this.$handleError(error);
                datasetInfo.isLoading = false;
                datasetInfo.error = error;
                return;
            }
            const variablesSR = await service.variable.getAll({ datasetId: dataset.id });
            if (variablesSR.isError) {
                /*** @type { error: ApiServiceError }*/
                const { error } = variablesSR;
                this.$handleError(error);
                datasetInfo.isLoading = false;
                datasetInfo.error = error;
                return;
            }
            /** @type {{result: IDatasetEntity[] }} */
            const { result: entities } = entitiesSR;
            /** @type {{ result: IDatasetVariable[] }} */
            const { result: variables } = variablesSR;
            this.setDatasetInfo({ dataset, entities, variables });
            this.syncQueryModel(invalidateQuery);
            this.emitDatasetPropsChanged();
            this.$handleError([], true);
            datasetInfo.isLoading = false;
        },
        ensureFetchDataCancel() {
            const { request } = this;
            if (request?.isLoading) {
                request.cancel();
            }
        },
        /**
         * @param {{ offset:number, limit:number }} options
         * @return {Promise<IDatasetResult>}
         */
        fetchPreviewData({ offset, limit }) {
            const request = this.request;
            request.limit = limit;
            request.offset = offset;
            this.ensureFetchDataCancel();

            return request.send({ debug: true });
        },
        async updatePreview() {
            const { queryModel, datasetPreview } = this;
            const { offset, limit } = datasetPreview;
            const { metrics, dimensions } = queryModel;
            if (metrics.length === 0 && dimensions.length === 0) {
                return;
            }

            datasetPreview.error = null;
            datasetPreview.isLoading = true;
            try {
                const result = await this.fetchPreviewData({ offset, limit });
                // bug when empty result – 'schema' interface changed
                if (result.rowCount === 0) {
                    result.schema = this.datasetPreview.result.schema;
                }
                this.datasetPreview.result = result;
            } catch (error) {
                if (error.isCancel) {
                    return;
                }
                datasetPreview.result = {
                    rowCount: 0,
                    rows: []
                };
                datasetPreview.error = error;
                this.$showToast({ text: ToastMessage.ERROR_OCCURED() });
            } finally {
                datasetPreview.isLoading = false;
            }
        },
        emitDatasetPropsChanged() {
            this.$emit('change', this.datasetRequestPropsInner);
        },
        /**
         * @param {Pick<import('@goodt-common/data').QueryModelExtended, 'metrics'|'dimensions'|'drilldowns'|'order'>} model
         */
        onQueryParamsChanged({ metrics, dimensions, drilldowns, order }) {
            const { queryModel } = this;
            queryModel.dimensions = dimensions;
            queryModel.metrics = metrics;
            queryModel.drilldowns = drilldowns;
            queryModel.order = order;

            this.validateQueryModel();
            this.emitDatasetPropsChanged();
        },
        /**
         * @param {IQueryFilterInfo[]} filters
         */
        onFiltersChanged(filters) {
            this.queryModel.filters = filters;

            this.validateQueryModel();
            this.emitDatasetPropsChanged();
        },
        /**
         * @param {IQueryVariableInfo[]} variables
         */
        onVariablesChanged(variables) {
            this.queryModel.variables = variables;
            this.validateQueryModel();
            this.emitDatasetPropsChanged();
        },
        /**
         * @param {IQuerySortInfo[]} sort
         */
        onSortChange(sort) {
            this.queryModel.sort = sort;

            this.validateQueryModel();
            this.emitDatasetPropsChanged();
        },
        /**
         * @param {number} limit
         */
        onLimitChange(limit) {
            this.limit = limit;
            this.emitDatasetPropsChanged();
        },
        /**
         *
         * @param {{ target:string, name:string }} options
         */
        onDatasetPreviewFilterChange({ target, name }) {
            const { filterEditor, queryModel } = this;
            const { filters } = queryModel;

            if (filterEditor.isShown) {
                filterEditor.isShown = false;
                return;
            }
            const filterIndex = filters.findIndex((filter) => filter.name === name);

            filterEditor.target = target;
            filterEditor.index = filterIndex;
            filterEditor.name = name;
            filterEditor.filter = filters[filterIndex];
            filterEditor.target = target;
            filterEditor.isShown = true;
        },
        /**
         * @param {{ name:string, direction: string }} options
         */
        onDatasetPreviewSortChange({ name, direction }) {
            const { queryModel } = this;
            const { sort, drilldowns } = queryModel;
            const drilldown = drilldowns.find((item) => item.name === name);
            const entityName = drilldown ? drilldown.dimensions[0] : name;
            const sortItemIndex = sort.findIndex((item) => item.name === entityName);

            if (sortItemIndex < 0) {
                const newSort = queryModel.createBlankSort();
                newSort.name = entityName;
                newSort.direction = direction;
                this.onSortChange([...sort, newSort]);
                return;
            }

            if (direction == null) {
                sort.splice(sortItemIndex, 1);
            } else {
                sort[sortItemIndex].direction = direction;
            }
            this.onSortChange(sort);
        },
        /**
         * @param {{ page:number, offset: number }} options
         */
        onDatasetPreviewPageChange({ offset }) {
            this.datasetPreview.offset = offset;
            this.updatePreview();
        },
        /**
         *
         * @param {{ filter:IQueryFilterInfo, isNew:boolean }} options
         */
        onFilterEditorSave({ filter, isNew }) {
            const { index } = this.filterEditor;
            const { filters } = this.queryModel;
            if (isNew) {
                filters.push(filter);
            } else {
                filters.splice(index, 1, filter);
            }
            this.onFiltersChanged(filters);
            this.filterEditor.isShown = false;
        },
        onFilterEditorDelete() {
            const { index } = this.filterEditor;
            const { filters } = this.queryModel;

            filters.splice(index, 1);
            this.onFiltersChanged(filters);
            this.filterEditor.isShown = false;
        },
        /**
         * @param {string} entityName
         * @return {boolean}
         */
        hasEntityTemplate(entityName) {
            const { dimensions, metrics } = this.datasetInfo;
            const foundEntity = [...dimensions, ...metrics].find(({ name }) => entityName === name);
            return foundEntity?.templateId != null;
        }
    }
};
</script>
<style lang="pcss" scoped>
.aside {
    display: grid;
    gap: 1rem;
    width: 25rem;
    height: 100%;
    grid-auto-rows: max-content;
}

.dataset-preview {
    width: 0;
    min-width: 100%;
    height: 100%;
}

.collapse-header {
    display: grid;
    grid-template-columns: 1fr auto;
    align-items: center;

    &__title--error {
        color: var(--color-red);
        font-weight: 500;
    }
}

.debug-info {
    min-width: 60vw;
    min-height: 40vh;

    &__code {
        max-width: 60vw;
        max-height: 40vh;
        overflow: auto;
        padding-bottom: 3rem;
        border-radius: var(--border-radius);
    }
}

.text-preline {
    white-space: pre-line;
}
</style>
