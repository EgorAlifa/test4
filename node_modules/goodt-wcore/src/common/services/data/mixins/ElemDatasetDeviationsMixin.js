import { CoreError } from '@goodt-wcore/errors';
import { DEVIATIONS_PROP } from '../consts';
import { DatasetRequestFactory } from '../models';
import { DeviationContext, DEVIATION_DEFAULT_VALUE } from '../utils';
import { ElemDatasetBaseMixin } from './ElemDatasetBaseMixin';
import { ElemDatasetMixin } from './ElemDatasetMixin';
import { CancelToken } from './utils';
/**
 * @typedef {import('@goodt-common/data').Request} IRequest
 * @typedef {import('@goodt-common/data').IDatasetResultExtended} IResult
 * @typedef {import('@goodt-common/data').IDeviationDatasetProps} IDeviationDatasetProps
 * @typedef {import('@goodt-common/data').IDeviationRule} IDeviationRule
 */

export const ElemDatasetDeviationsMixin = {
    _name: 'ElemDatasetDeviationsMixin',
    static: {
        DEVIATIONS_PROP
    },
    computed: {
        /**
         * @return {{ rows: Record<string, any>[], schema: { name: string }[] }}
         */
        deviations() {
            const { results, props } = this;
            const { refDatasetIndex, rules } = props[DEVIATIONS_PROP];
            const deviations = { rows: [], schema: rules.map(({ name }) => ({ name })) };
            
            if (results[refDatasetIndex] == null) {
                return deviations;
            }
            
            const resultsRows = results.map(({ rows }) => rows);
            return new Array(results[refDatasetIndex].rowCount).fill(null).reduce((acc, _, index) => {
                const rowsSlice = resultsRows.reduce((rows, arr) => [...rows, arr[index]], []);
                const context = this.createContext(rowsSlice);
                const deviationRow = rules.reduce((rowAcc, rule) => ({ ...rowAcc, ...this.calcDeviation(rule, context) }), {});
                acc.rows = [...acc.rows, deviationRow];
                return acc;
            }, deviations);
        }
    },
    methods: {
        /**
         * @public
         * @param {(IRequest|null)[]} requests
         */
        async loadData(requests = this.requests) {
            // implicit check of availability ElemDatasetMixin mixin is used bc otherwise
            // user may do smth like this: useElemDatasetBASEMixin({ deviations: { hasDatasetMixin: true } })
            const hasDatasetMixin = this.$options.mixins
                .flatMap(({ mixins = [] }) => mixins)
                .some(({ _name }) => _name === 'ElemDatasetMixin');
            const { refDatasetIndex, datasets } = this.props[DEVIATIONS_PROP];
            
            if (refDatasetIndex == null) {
                const loadDataMethod = this.super(hasDatasetMixin ? ElemDatasetMixin: ElemDatasetBaseMixin).loadData;
                loadDataMethod.call(this, requests);
                return;
            }
            
            const refRequest = requests[refDatasetIndex];
            
            this.$requestCancel(refRequest);
            
            if (this.loadDataHooks.before != null) {
                const cancelToken = new CancelToken();
                this.loadDataHooks.before.call(this, cancelToken.cancel.bind(cancelToken));
                if (cancelToken.isCancelled === true) {
                    return;
                }
            }
            
            if (refRequest == null) {
                const deviationRequests = requests.toSpliced(refDatasetIndex, 1, null);
                const refResult = this.results[refDatasetIndex];
                this.isLoading = true;
                this.results = await this.loadDeviationsData(deviationRequests, refResult);
                this.isLoading = false;
                return;
            }
            
            try {
                this.isLoading = true;
                const refResult = await refRequest.send();
                if (hasDatasetMixin) {
                    this.result = refResult;
                }
                const deviationRequests = this.datasetRequests.map((requestProps, requestIndex) => {
                    const isDeviationRequest = datasets.find(({ index }) => index === requestIndex) != null;
                    return isDeviationRequest ? DatasetRequestFactory(requestProps) : null;
                });
                this.results = await this.loadDeviationsData(deviationRequests, refResult);
                this.loadDataHooks.then?.call(this, hasDatasetMixin ? this.result : this.results);
            } catch (error) {
                this.results = [];
                if (hasDatasetMixin) {
                    this.result = null;
                }
                this.$handleError(error);
                this.loadDataHooks.catch?.call(this, error);
            } finally {
                this.isLoading = false;
                this.loadDataHooks.finally?.call(this);
            }
        },
        /**
         * @param {(IRequest|null)[]} requests
         * @param {IResult} refResult
         * @return {Promise<(IResult|null)[]>}
         */
        async loadDeviationsData(requests, refResult) {
            this.$requestCancel(requests);
            
            const { props, QueryFilterOperator } = this;
            const { refDatasetKey, datasets } = props[DEVIATIONS_PROP];
            const refFilterValues = refResult.rows.map(({ [refDatasetKey]: value }) => value);
            try {
                const results = await Promise.all(
                    requests.map((request, rIndex) => {
                        if (request == null) {
                            return Promise.resolve(this.results?.[rIndex] ?? null);
                        }
                        const datasetKey = datasets.find(({ index }) => index === rIndex)?.key ?? refDatasetKey;
                        request.query.filterAdd({
                            name: datasetKey,
                            operator: QueryFilterOperator.IN,
                            value: refFilterValues
                        });
                        request.limit = 0;
                        return request.send();
                    })
                );
                return this.postprocessDeviationResults(results, refResult);
            } catch (error) {
                this.$handleError(error);
                return [];
            }
        },
        /**
         * @param {(IResult|null)[]} results
         * @param {IResult} refResult
         * @return {(IResult|null)[]}
         */
        postprocessDeviationResults(results, refResult) {
            const { props } = this;
            const { refDatasetIndex, refDatasetKey, datasets } = props[DEVIATIONS_PROP];
            const datasetsPropsExtended = datasets
                .map(({ index, key }) => results[index] == null ? null : {
                    index,
                    result: results[index],
                    key: key ?? refDatasetKey
                })
                .filter(Boolean);
            refResult.rows.forEach(({ [refDatasetKey]: refKeyValue }, rowIndex) => {
                datasetsPropsExtended.forEach(({ key, result }) => {
                    const { schema, rows } = result;
                    const foundRow = rows.find(({ [key]: value }) => value === refKeyValue);
                    if (foundRow == null) {
                        const fieldNames = schema.map(({ name }) => name);
                        const createdRow = fieldNames.reduce((acc, fieldName) => ({
                            [fieldName]: null,
                            ...acc,
                        }), { [key]: refKeyValue });
                        rows.splice(rowIndex, 0, createdRow);
                    }
                });
            });
            results.forEach((result) => {
                if (result != null) {
                    result.rowCount = refResult.rowCount;
                }
            });
            return results.toSpliced(refDatasetIndex, 1, refResult);
        },
        /**
         * @param {Record<string, any>[]} rows
         * @return {Record<string, Function: number>}
         */
        createContext(rows) {
            const { datasets: datasetsProps } = this.props[DEVIATIONS_PROP];
            return {
                [DeviationContext.GET_BY_PATH.name]: (key) => {
                    const dotIndex = key.indexOf('.');
                    const [index, name] = [key.slice(0, dotIndex), key.slice(dotIndex + 1)];
                    const { index: datasetIndex } = datasetsProps[index];
                    return Number(rows[datasetIndex][name] ?? DEVIATION_DEFAULT_VALUE);
                },
                [DeviationContext.ABS.name]: DeviationContext.ABS.func,
                [DeviationContext.SQUARE.name]: DeviationContext.SQUARE.func,
                [DeviationContext.SQRT.name]: DeviationContext.SQRT.func,
                [DeviationContext.PCT.name]: DeviationContext.PCT.func
            };
        },
        /**
         * @param {IDeviationRule} rule
         * @param {Record<string, Function: number>} context
         * @return {Record<string, any>}
         */
        calcDeviation({ name, formula }, context) {
            try {
                const calcFunction = new Function(...Object.keys(context), `return ${formula}`);
                const result = calcFunction(...Object.values(context));
                return { [name]: String(result) };
            } catch (error) {
                this.$handleError(new CoreError(error.toString()));
                return { [name]: null };
            }
        }
    }
};
