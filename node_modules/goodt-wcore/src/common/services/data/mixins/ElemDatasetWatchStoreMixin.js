import { isEqual, pick, zipObject } from 'lodash';
import {
    createDatasetQueryFilterInfo,
    createDatasetQueryVariableInfo,
    extractQueryModelsParams,
    extractQueryModelsVariables,
    resolveAddedAndDeleted
} from './utils';
import { ElemDatasetBaseMixinTypes } from './types';
import { QueryModelExtended } from '../models';

/**
 * @typedef {import('@goodt-common/data').Request} DatasetRequest
 * @typedef {import('@goodt-wcore/managers').StoreElemState} StoreElemState
 */

export const ElemDatasetWatchStoreMixin = {
    _name: 'ElemDatasetWatchStoreMixin',
    data() {
        return {
            /**
             * If store state changes watching
             * and store filter applying required
             * @type {boolean}
             */
            watchStoreState: true,
            /**
             * Query params list available to be watched from store state
             * used to change query filters in runtime
             * @type {WeakMap<DatasetRequest, string[]>}
             */
            queryParamsByRequest: new WeakMap(),
            // extra typings
            ...ElemDatasetBaseMixinTypes
        };
    },

    computed: {
        /**
         * @return {string[]}
         */
        $storeWatchHandlerQueryParams() {
            const queryParams = this.requests
                .filter(Boolean)
                .flatMap((request) => this.queryParamsByRequest.get(request));
            return [...new Set(queryParams)];
        },
        /**
         *
         * @return {string[]}
         */
        $storeWatchHandlerVars() {
            const {
                $storeMeta: {
                    vars: { read }
                }
            } = this;
            return this.$storeWatchHandlerQueryParams.filter((param) => read.includes(param));
        }
    },

    watchEditor: {
        // when local variables read/write mapping changed
        /**
         * @param {string[]} newParams
         * @param {string[]} [oldParams=[]]
         */
        $storeWatchHandlerVars(newParams, oldParams) {
            // nothing to delete from varAliases
            if (oldParams.length === 0) {
                return;
            }
            const [_, deletedVars] = resolveAddedAndDeleted(newParams, oldParams);
            if (deletedVars.length === 0) {
                return;
            }
            const changedRequests = this.$queryRemoveParamsStoreFilters(deletedVars);
            if (changedRequests.length > 0) {
                this.$requestChanged(changedRequests);
            }
        },
        /**
         * @param {WeakMap<DatasetRequest, string[]>} queryParamsByRequest
         */
        queryParamsByRequest(queryParamsByRequest) {
            this.$storeUpdateDescriptorVars(queryParamsByRequest);
        }
    },
    watch: {
        requests: {
            /**
             * @public
             * @param {(DatasetRequest|null)[]} newRequests
             * @param {(DatasetRequest|null)[]} [oldRequests=[]]
             */
            handler(newRequests, oldRequests) {
                this.$queryUpdateParamsByRequest(newRequests, oldRequests);
                this.$queryInitParamsStoreFilters(newRequests, oldRequests);
            }
        }
    },

    created() {
        if (this.watchStoreState) {
            this.$watchStore({
                vars() {
                    return this.$storeWatchHandlerVars;
                },
                handler: (_, state) => this.$storeWatchHandler(state)
            });
        }
    },

    methods: {
        /**
         * @public
         * @param {(DatasetRequest|null)[]} requests
         * @param {(DatasetRequest|null)[]} [oldRequests=[]]
         */
        $queryInitParamsStoreFilters(requests, oldRequests = []) {
            const paramsState = pick(this.$storeState, this.$storeWatchHandlerVars);
            this.$storeApplyQueryFilters(paramsState);
        },
        /**
         * Handle props.varAliases changes
         * to remove query filters if var mapping to store is changed
         *
         * @param {string[]} deletedVars
         * @return {DatasetRequest[]}
         */
        $queryRemoveParamsStoreFilters(deletedVars) {
            const deletedVarsState = zipObject(deletedVars, Array(deletedVars.length).fill(undefined));
            const changedRequests = this.$storeApplyQueryFilters(deletedVarsState);
            return changedRequests.filter(Boolean);
        },
        /**
         * Handle this.$storeState changes
         * to add/remove query filters if state changed
         * @public
         * @param {StoreElemState} state
         */
        $storeWatchHandler(state) {
            const requests = this.$storeApplyQueryFilters(state);
            this.$requestChanged(requests);
        },
        /**
         * Applies filters from 'filterParams'
         * @public
         * @param {StoreElemState} storeQueryParams
         * @return {(DatasetRequest|null)[]} list of changed requests
         */
        $storeApplyQueryFilters(storeQueryParams) {
            // eslint-disable-next-line no-param-reassign
            if (Object.keys(storeQueryParams).length === 0) {
                return Array(this.requests.length).fill(null);
            }

            const requestFilterApplyMapper = (request, index) => {
                if (request == null) {
                    return null;
                }
                const { query } = request;
                // filters before applied
                const { filters: filtersBefore, variables: variablesBefore } = query;

                /**
                 * @var {string[]} requestQueryParams
                 */
                const requestQueryParams = this.queryParamsByRequest.get(request);
                const { variables, filters } = Object.groupBy(requestQueryParams, (paramName) => {
                    return query.variableNames.includes(paramName) ? 'variables' : 'filters';
                });

                // add query filters
                const requestFilterParams = pick(storeQueryParams, filters);
                Object.entries(requestFilterParams).forEach(([name, value]) => {
                    const shouldRemoveFilter = value == null;
                    if (shouldRemoveFilter) {
                        if (query.filterRemove(name) === false) {
                            return;
                        }
                        // query model from 'props.dataset' with no runtime modifications
                        const originalQueryModel = new QueryModelExtended(this.datasetRequests[index].query);
                        const filterInfo = originalQueryModel.filterGetInfo(name);
                        if (filterInfo != null) {
                            // try restore static filter from dataset request props 'query'
                            query.filterAdd(filterInfo);
                        }
                    } else {
                        const filterInfo = createDatasetQueryFilterInfo(name, value);
                        const isAddedOrUpdated = filterInfo == null ? false : query.filterAdd(filterInfo);
                        if (isAddedOrUpdated === false) {
                            this.$debugMessage(`Dataset Query filter "${name}" add failed: ${JSON.stringify(value)}`, {
                                scope: '$storeApplyQueryFilters'
                            });
                        }
                    }
                });

                // add query variables
                const requestVariableParams = pick(storeQueryParams, variables);
                Object.entries(requestVariableParams).forEach(([name, value]) => {
                    const shouldRemoveVariable = value == null;
                    if (shouldRemoveVariable) {
                        if (query.variableRemove(name) === false) {
                            return;
                        }
                        // query model from 'props.dataset' with no runtime modifications
                        const originalQueryModel = new QueryModelExtended(this.datasetRequests[index].query);
                        const variableInfo = originalQueryModel.variableGetInfo(name);
                        if (variableInfo != null) {
                            // try restore static variable from dataset request props 'query'
                            query.variableAdd(variableInfo);
                        }
                    } else {
                        const variableInfo = createDatasetQueryVariableInfo(name, value);
                        query.variableAdd(variableInfo);
                    }
                });

                const { filters: filtersAfter, variables: variablesAfter } = query;
                const isChanged = [
                    isEqual(filtersBefore, filtersAfter),
                    isEqual(variablesBefore, variablesAfter)
                ].every(Boolean) === false;

                return isChanged ? request : null;
            };

            return this.requests.map(requestFilterApplyMapper);
        },
        /**
         * Update this.descriptor.vars
         *
         * @param {WeakMap<DatasetRequest, string[]>} queryParamsByRequest
         */
        $storeUpdateDescriptorVars(queryParamsByRequest) {
            const getParamScopes = (paramName) => {
                const paramDescriptor = this.descriptor.vars[paramName];
                return paramDescriptor?.scopes ?? [];
            };

            const createDefinition = (paramName, scopes) =>
                Object.freeze({
                    description: paramName,
                    scopes
                });

            // delete all scopes
            Object.entries(this.descriptor.vars).forEach(([key, { scopes }]) => {
                if (scopes !== undefined) {
                    this.$delete(this.descriptor.vars, key);
                }
            });

            this.requests.filter(Boolean).forEach((request) => {
                const scope = request.name;
                const queryParams = queryParamsByRequest
                    .get(request)
                    // фильтруем только доступные
                    .filter((paramName) => this.$storeWatchHandlerQueryParams.includes(paramName));

                queryParams.forEach((paramName) => {
                    const scopes = [...new Set([...getParamScopes(paramName), scope])];
                    const definition = createDefinition(paramName, scopes);
                    this.$set(this.descriptor.vars, paramName, definition);
                });
            });
        },
        /**
         * Update this.queryParamsByRequest
         * if they were changed
         * @param {(DatasetRequest|null)[]} requests
         * @param {(DatasetRequest|null)[]} [oldRequests=[]]
         */
        $queryUpdateParamsByRequest(requests, oldRequests = []) {
            const queryParamsByRequest = new WeakMap();
            const isEmptyRequests = requests.length === 0;

            if (isEmptyRequests) {
                this.queryParamsByRequest = queryParamsByRequest;
                return;
            }

            const wasUpdated = requests.reduce((isUpdated, request, currentIndex) => {
                if (request == null) {
                    const wasDeleted = this.queryParamsByRequest.has(oldRequests[currentIndex]);
                    return wasDeleted || isUpdated;
                }
                const baseQueryModels = [request.query.getBaseModel()];
                const queryParams = [
                    ...extractQueryModelsVariables(baseQueryModels),
                    ...extractQueryModelsParams(baseQueryModels, ['metrics', 'dimensions', 'fields'])
                ];
                queryParamsByRequest.set(request, queryParams);

                return isEqual(queryParams, this.queryParamsByRequest.get(request)) ? isUpdated : true;
            }, false);

            // eslint-disable-next-line no-restricted-syntax
            if (wasUpdated) {
                this.queryParamsByRequest = queryParamsByRequest;
            }
        }
    }
};
