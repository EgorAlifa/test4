import './option-hooks';
import { isEqual } from 'lodash';
import { DATASET_PROP } from '../consts';
import { DatasetRequestFactory, createDatasetQueryFilterStoreable } from '../models';
import * as QueryConst from '../utils/query-const';
import { ElemDatasetBaseMixinTypes } from './types';
import { bindComponentContext, CancelToken, extractQueryModelsParams, extractQueryModelsVariables } from './utils';
import { ElemDatasetWatchStoreMixin } from './ElemDatasetWatchStoreMixin';
import { DataClientRequestError } from '../services';

/**
 *
 * @typedef {import('@goodt-common/data').Request} DatasetRequest
 * @typedef {import('@goodt-common/data').IDatasetResult} IDatasetResult
 * @typedef {import('@goodt-common/data').DataClientRequestError} DataClientRequestError
 * @typedef {import('@goodt-common/data').IDatasetRequestProps} IDatasetRequestProps
 * @typedef {import('@goodt-common/data').IDatasetEntity} IDatasetEntity
 * @typedef {import('@goodt-common/data').IDatasetVariable} IDatasetVariable
 * @typedef {import('@goodt-common/data').IDatasetVariable} IDatasetVariable
 * @typedef {import('@goodt-common/data').IQueryFilterInfo} IQueryFilterInfo
 * @typedef {import('@goodt-common/data').DatasetQueryFilterInfoStoreable} DatasetQueryFilterInfoStoreable
 */

export const ElemDatasetBaseMixin = {
    _name: 'ElemDatasetBaseMixin',
    mixins: [ElemDatasetWatchStoreMixin],
    /**
     * User-defined datasets load data lifecycle hooks
     */
    hooks: {},
    static(){
        const vm = this;
        return {
            DATASET_PROP,
            loadDataHooks: {
                // before: (cancel) => {},
                // then: (result) => {},
                // catch: (error) => {}},
                // finally: () => {},
                /**
                 * back compatibility with dremio-based widgets
                 */
                ...vm.loadDataHooks,
                /**
                 * options 'hooks' import
                 */
                ...bindComponentContext(vm.$options.hooks, vm)
            },
            ...QueryConst
        };
    },
    data: () => ({
        /**
         * @type {boolean}
         */
        isLoading: false,
        /**
         * @type {(IDatasetResult|null)[]}
         */
        results: [],
        /**
         * @type {(DatasetRequest|null)[]}
         */
        requests: [],
        /**
         * @type {DataClientRequestError|Error|null}
         */
        error: null,
        /**
         *
         */
        ...ElemDatasetBaseMixinTypes
    }),
    computedEditor: {
        // default placeholder options for <w-elem></w-elem>
        $placeholder() {
            return {
                show: !this.hasDataset,
                toggle: true,
                content: 'No dataset selected'
            };
        },
        hasDataset() {
            return this.datasetRequests.filter(Boolean).length > 0;
        },
        /**
         * @return {(IDatasetRequestProps|null)[]}
         */
        datasetRequests() {
            return this.props[this.DATASET_PROP] ?? [];
        },
        /**
         * @return {IDatasetEntity['name'][]}
         */
        dimensions() {
            return this.$queryGetParams(['dimensions']);
        },
        /**
         * @return {IDatasetEntity['name'][]}
         */
        metrics() {
            return this.$queryGetParams(['metrics']);
        },
        /**
         * @return {string[]}
         */
        fields() {
            return this.$queryGetParams(['fields']);
        },
        /**
         * @return {IDatasetVariable['name'][]}
         */
        variables() {
            return this.$queryGetVariables();
        }
    },

    watch: {
        datasetRequests: {
            /**
             * @param {(DatasetRequest|null)[]} newRequests
             * @param {(DatasetRequest|null)[]} [oldRequests=[]]
             */
            handler: 'onDatasetRequestsChanged',
            immediate: true
        },
        requests: {
            /**
             *
             * @param {(DatasetRequest|null)[]} newRequests
             * @param {(DatasetRequest|null)[]} [oldRequests=[]]
             */
            handler(newRequests, oldRequests = []) {
                // eslint-disable-next-line no-restricted-syntax
                const changedRequests = newRequests.filter(
                    (newRequest, index) => newRequest != null && newRequest !== oldRequests[index]
                );
                this.$requestChanged(changedRequests);
            }
        }
    },

    destroyed() {
        this.$requestCancel();
    },

    methods: {
        /**
         * Updates this.requests with new Request instances when this.props[this.DATASET_PROP] changed
         * @param {(IDatasetRequestProps|null)[]} [newDatasetRequests]
         * @param {(IDatasetRequestProps|null)[]} [oldDatasetRequests=[]]
         */
        onDatasetRequestsChanged(newDatasetRequests, oldDatasetRequests = []) {
            let isChanged = newDatasetRequests.length !== oldDatasetRequests.length;
            // вариант с reduce плохо читается, поэтому используем map + сайд-эффект
            const requests = newDatasetRequests.map((requestProps, index) => {
                // if request not changed reuse from this.requests
                // make sense for multiple dataset requests list
                if (isEqual(requestProps, oldDatasetRequests[index])) {
                    return this.requests[index];
                }
                isChanged = true;
                if (requestProps == null) {
                    return null;
                }
                return DatasetRequestFactory(requestProps);
            });
            if (isChanged) {
                this.requests = requests;
            }
        },
        /**
         *
         * @param {(DatasetRequest|null)[]} requests
         */
        $requestChanged(requests) {
            // eslint-disable-next-line no-param-reassign
            requests = [requests].flat();
            const [shouldLoad, orderedRequests] = this.requests.reduce(
                ([_shouldLoad, _orderedRequests], request) => {
                    const isChanged = request != null && requests.includes(request);
                    // prettier-ignore
                    return [
                            _shouldLoad || isChanged,
                            [..._orderedRequests, isChanged ? request : null]
                        ];
                },
                [false, []]
            );
            if (shouldLoad) {
                orderedRequests.forEach((request) => {
                    if (request != null) {
                        request.offset = 0;
                        request.cancel();
                    }
                });
                this.loadData(orderedRequests);
            }
        },
        /**
         * @public
         * @param {(DatasetRequest|null)[]} requests
         */
        async loadData(requests = this.requests) {
            this.$requestCancel(requests);

            if (this.loadDataHooks.before != null) {
                const cancelToken = new CancelToken();
                this.loadDataHooks.before.call(this, cancelToken.cancel.bind(cancelToken));
                if (cancelToken.isCancelled === true) {
                    return;
                }
            }

            try {
                this.isLoading = true;
                const results = await Promise.all(requests.map((request) => request?.send() ?? null));
                // обновить результаты только тех запросов, которые не null
                this.results = results.map((result, i) => result ?? this.results?.[i] ?? null); // ?? []
                this.loadDataHooks.then?.call(this, this.results);
            } catch (error) {
                this.results = [];
                this.$handleError(error);
                this.loadDataHooks.catch?.call(this, error);
            } finally {
                this.isLoading = false;
                this.loadDataHooks.finally?.call(this);
            }
        },

        /**
         * @deprecated use this.$requestCancel instead
         * @param {(DatasetRequest|null)[]} [requests]         */
        cancelRequests(requests) {
            this.$requestCancel(requests);
        },
        /**
         *
         * @param {(DatasetRequest|null|DatasetRequest|null)[]} [requests]
         */
        $requestCancel(requests = this.requests) {
            [requests].flat().filter(Boolean).forEach((request) => request.cancel());
        },
        /**
         * Extended ElemBase.$handleError dataset BL specific behaviour
         * @param {Error} error
         */
        $handleError(error) {
            if (error instanceof DataClientRequestError) {
                error.context = this;
            }
            this.super().$handleError.call(this, error);
            if (error instanceof DataClientRequestError === false) {
                return;
            }
            if (this.isEditorMode === false) {
                return;
            }
            this.error = error;
        },
        /**
         *
         * @param {string[]} params
         * @param {(DatasetRequest|null)[]} [requests]
         * @return {string[]}
         */
        $queryGetParams(params, requests = this.requests) {
            return extractQueryModelsParams(
                [requests]
                    .flat()
                    .filter(Boolean)
                    .map(({ query }) => query),
                params
            );
        },
        /**
         *
         * @param {(DatasetRequest|null)[]} [requests]
         * @return {string[]}
         */
        $queryGetVariables(requests = this.requests) {
            return extractQueryModelsVariables(
                [requests]
                    .flat()
                    .filter(Boolean)
                    .map(({ query }) => query)
            );
        },
        /**
         *
         * @param {string} param
         * @param {(DatasetRequest|null)[]} [requests]
         * @return {null|string}
         */
        $queryGetParamName(param, requests = this.requests) {
            const request = [requests]
                .flat()
                .filter(Boolean)
                .find(({ query }) => query.getParamName(param) != null);
            return request?.query.getParamName(param) ?? null;
        },
        /**
         *
         * @param {string} param
         * @param {(DatasetRequest|null)[]} [requests]
         * @return {boolean}
         */
        $queryHasFilter(param, requests = this.requests) {
            return [requests]
                .flat()
                .filter(Boolean)
                .some(({ query }) => query.hasFilter(param));
        },
        /**
         * @param {IQueryFilterInfo} options
         * @return {DatasetQueryFilterInfoStoreable}
         */
        $queryCreateStoreFilter(options) {
            return createDatasetQueryFilterStoreable(options);
        }
    }
};