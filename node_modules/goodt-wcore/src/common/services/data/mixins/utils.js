import { difference, get } from 'lodash';
import { QueryFilterOperator } from '../utils/query-const';

/**
 * @typedef {import('@goodt-common/data').IQueryVariableInfo} IQueryVariableInfo
 * @typedef {import('@goodt-common/data').IQueryFilterInfo} IQueryFilterInfo
 * @typedef {import('@goodt-common/data').QueryModel} QueryModel
 * @typedef {import('@goodt-common/data').QueryModelBase} QueryModelBase
 */

export const bindComponentContext = (methods, vm) =>
    Object.entries(methods).reduce(
        (acc, [name, fn]) => ({
            ...acc,
            [name]: fn.bind(vm)
        }),
        {}
    );

export class CancelToken {
    isCancelled = false;

    cancel() {
        this.isCancelled = true;
    }
}

/**
 * Creates dataset  query filter info
 * @param {IQueryFilterInfo['name']} name metric/dimension/field name
 * @param {IQueryFilterInfo['value']} value filter value
 * @return {IQueryFilterInfo}
 */
export const createDatasetQueryFilterInfo = (name, value) => {
    // eslint-disable-next-line id-length
    const { IN, EQ } = QueryFilterOperator;
    const isPrimitive = ['number', 'string', 'boolean'].includes(typeof value);
    if (isPrimitive) {
        return {
            name,
            operator: EQ,
            value
        };
    }

    const isArray = Array.isArray(value);
    if (isArray) {
        return {
            name,
            operator: IN,
            value
        };
    }

    // eslint-disable-next-line no-underscore-dangle
    if (typeof value === 'object' && value.__t != null) {
        return {
            ...value,
            name
        };
    }
    // eslint-disable-next-line no-nested-ternary
    return null;
};

/**
 * @param {IQueryVariableInfo['name']} name
 * @param {IQueryVariableInfo['value']} value
 * @return {IQueryVariableInfo}
 */
export const createDatasetQueryVariableInfo = (name, value) => {
    return {
        name,
        value
    }
}

/**
 * @param {(QueryModel|QueryModelBase)[]} queryModels
 * @param {string[]} params
 * @return {string[]}
 */
export const extractQueryModelsParams = (queryModels, params = ['metrics', 'dimensions', 'fields']) => {
    const datasetsQueriesParams = queryModels
        .filter(Boolean)
        .flatMap((queryModel) =>
            params
                .flatMap((param) => get(queryModel, param, []))
                // sorting by queryModel.order
                .sort((a, b) => {
                    let aIndex = queryModel.order.indexOf(a);
                    let bIndex = queryModel.order.indexOf(b);
                    if (aIndex === -1) {
                        aIndex = Number.POSITIVE_INFINITY;
                    }
                    if (bIndex === -1) {
                        bIndex = Number.POSITIVE_INFINITY;
                    }
                    return aIndex - bIndex;
                })
        );
    return [...new Set(datasetsQueriesParams)];
};

/**
 * @param {(QueryModel|QueryModelBase)[]} queryModels
 * @return {string[]}
 */
export const extractQueryModelsVariables = (queryModels) => {
    const datasetsQueriesVariables = queryModels
        .filter(Boolean)
        .flatMap((queryModel) => queryModel.variableNames);
    return [...new Set(datasetsQueriesVariables)];
};

/**
 *
 * @param arrayA
 * @param arrayB
 * @return {[*[],*[]]}
 */
export const resolveAddedAndDeleted = (arrayA, arrayB) => [
    difference(arrayA ?? [], arrayB ?? []),
    difference(arrayB ?? [], arrayA ?? [])
];
