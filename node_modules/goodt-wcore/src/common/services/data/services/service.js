/* eslint-disable max-classes-per-file */
import { ApiClientMethod, ApiServiceError, BaseApiService, buildRequest } from '@goodt-common/api';
import { SafeResult, success, fail } from '@goodt-common/utils';

/**
 * @typedef {import('@goodt-common/utils').ISafeResult} ISafeResult
 * @typedef {import('../types').IAdapter} IAdapter
 * @typedef {import('../types').IAdapterManager} IAdapterManager
 * @typedef {import('../types').IConnection} IConnection
 * @typedef {import('../types').IDataset} IDataset
 * @typedef {import('../types').IDatasetMeta} IDatasetMeta
 * @typedef {import('../types').IDatasetFolder} IDatasetFolder
 * @typedef {import('../types').IDatasetEntity} IDatasetEntity
 * @typedef {import('../types').IDatasetQuery} IDatasetQuery
 * @typedef {import('../types').IDatasetVariable} IDatasetVariable
 * @typedef {import('../types').IDatasetOrder} IDatasetOrder
 * @typedef {import('../types').IDatasetEntityTemplate} IDatasetEntityTemplate
 * @typedef {import('../types').IDatasetEntityTemplateProject} IDatasetEntityTemplateProject
 * @typedef {import('../types').IDatasetEntityTemplateFolder} IDatasetEntityTemplateFolder
 * @typedef {import('../types').IDatasetResultExtended} IDatasetResultExtended
 * @typedef {import('../types').IExternalSourceTable} IExternalSourceTable
 * @typedef {import('../types').IExternalSourceSchema} IExternalSourceSchema
 * @typedef {import('../types').IExternalSourceFieldSchema} IExternalSourceFieldSchema
 * @typedef {import('../types').IDatasetMaterialization} IDatasetMaterialization
 * @typedef {import('../types').IDatasetMaterializationPlannerSchedule} IDatasetMaterializationPlannerSchedule
 * @typedef {import('../types').IFolderChildCount} IFolderChildCount
 */

/**
 * Service actions
 */
const ServiceAction = {
    datasetMeta: {
        ALL: {
            url: 'api/dataset-meta',
            options: { method: ApiClientMethod.GET }
        },
        SEARCH: {
            url: 'api/dataset-meta/search',
            options: { method: ApiClientMethod.GET }
        },
        COUNT_BY_FOLDER: {
            url: 'api/dataset-meta/count',
            options: { method: ApiClientMethod.GET }
        }
    },
    dataset: {
        GET: {
            url: 'api/dataset/:id',
            options: { method: ApiClientMethod.GET }
        },
        SEARCH: {
            url: 'api/dataset/search',
            options: { method: ApiClientMethod.GET }
        },
        UPLOAD: {
            url: 'api/dataset/upload',
            options: { method: ApiClientMethod.POST }
        },
        CLONE: {
            url: 'api/dataset/:id/clone',
            options: { method: ApiClientMethod.POST }
        },
        CREATE: {
            url: 'api/dataset',
            options: { method: ApiClientMethod.POST }
        },
        UPDATE: {
            url: 'api/dataset/:id',
            options: { method: ApiClientMethod.PUT }
        },
        DELETE: {
            url: 'api/dataset/:id',
            options: { method: ApiClientMethod.DELETE }
        },
        CHANGE_OWNER: {
            url: 'api/dataset/:id/object-owner-change',
            options: { method: ApiClientMethod.PUT }
        },
        PREVIEW: {
            url: 'api/dataset/preview',
            options: { method: ApiClientMethod.POST }
        },
        CODE_EXISTS: {
            url: '/api/dataset/code/:code',
            options: { method: ApiClientMethod.GET }
        }
    },
    folder: {
        ALL: {
            url: 'api/folder',
            options: { method: ApiClientMethod.GET }
        },
        GET: {
            url: 'api/folder/:id',
            options: { method: ApiClientMethod.GET }
        },
        CREATE: {
            url: 'api/folder',
            options: { method: ApiClientMethod.POST }
        },
        UPDATE: {
            url: 'api/folder/:id',
            options: { method: ApiClientMethod.PUT }
        },
        DELETE: {
            url: 'api/folder/:id',
            options: { method: ApiClientMethod.DELETE }
        },
        CHANGE_OWNER: {
            url: 'api/folder/:id/object-owner-change',
            options: { method: ApiClientMethod.PUT }
        },
        CODE_EXISTS: {
            url: '/api/folder/code/:code',
            options: { method: ApiClientMethod.GET }
        },
        COUNT_BY_FOLDER: {
            url: 'api/folder/children-count',
            options: { method: ApiClientMethod.GET }
        }
    },
    entity: {
        ALL: {
            url: 'api/dataset-entity',
            options: { method: ApiClientMethod.GET }
        },
        BATCH_UPDATE: {
            url: 'api/dataset-entity/batch-update',
            options: { method: ApiClientMethod.POST }
        }
    },
    variable: {
        ALL: {
            url: 'api/variable',
            options: { method: ApiClientMethod.GET }
        },
        BATCH_UPDATE: {
            url: 'api/variable/batch-update',
            options: { method: ApiClientMethod.POST }
        }
    },
    entityTemplate: {
        ALL: {
            url: 'api/dataset-entity-template',
            options: { method: ApiClientMethod.GET }
        },
        SEARCH: {
            url: 'api/dataset-entity-template/search',
            options: { method: ApiClientMethod.GET }
        },
        GET: {
            url: 'api/dataset-entity-template/:id',
            options: { method: ApiClientMethod.GET }
        },
        CLONE: {
            url: 'api/dataset-entity-template/:id/clone',
            options: { method: ApiClientMethod.POST }
        },
        CREATE: {
            url: 'api/dataset-entity-template',
            options: { method: ApiClientMethod.POST }
        },
        UPDATE: {
            url: 'api/dataset-entity-template/:id',
            options: { method: ApiClientMethod.PUT }
        },
        DELETE: {
            url: 'api/dataset-entity-template/:id',
            options: { method: ApiClientMethod.DELETE }
        },
        CHANGE_OWNER: {
            url: 'api/dataset-entity-template/:id/object-owner-change',
            options: { method: ApiClientMethod.PUT }
        },
        CODE_EXISTS: {
            url: '/api/dataset-entity-template/code/:code',
            options: { method: ApiClientMethod.GET }
        },
        COUNT_BY_FOLDER: {
            url: 'api/dataset-entity-template/count',
            options: { method: ApiClientMethod.GET }
        }
    },
    entityTemplateFolder: {
        ALL: {
            url: 'api/dataset-entity-template-folder',
            options: { method: ApiClientMethod.GET }
        },
        GET: {
            url: 'api/dataset-entity-template-folder/:id',
            options: { method: ApiClientMethod.GET }
        },
        CREATE: {
            url: 'api/dataset-entity-template-folder',
            options: { method: ApiClientMethod.POST }
        },
        UPDATE: {
            url: 'api/dataset-entity-template-folder/:id',
            options: { method: ApiClientMethod.PUT }
        },
        DELETE: {
            url: 'api/dataset-entity-template-folder/:id',
            options: { method: ApiClientMethod.DELETE }
        },
        CHANGE_OWNER: {
            url: 'api/dataset-entity-template-folder/:id/object-owner-change',
            options: { method: ApiClientMethod.PUT }
        },
        CODE_EXISTS: {
            url: '/api/dataset-entity-template-folder/code/:code',
            options: { method: ApiClientMethod.GET }
        },
        COUNT_BY_FOLDER: {
            url: 'api/dataset-entity-template-folder/count',
            options: { method: ApiClientMethod.GET }
        }
    },
    entityTemplateProject: {
        ALL: {
            url: 'api/dataset-entity-template-project',
            options: { method: ApiClientMethod.GET }
        }
    },
    externalSource: {
        GET_TABLE_SCHEMA: {
            url: 'api/external-source/table-schema',
            options: { method: ApiClientMethod.GET }
        },
        GET_FIELD_SCHEMA: {
            url: '/api/external-source/field-schema',
            options: { method: ApiClientMethod.GET }
        }
    },
    adapter: {
        ALL: {
            url: 'api/v1/adapters',
            options: { method: ApiClientMethod.GET }
        }
    },
    adapterManager: {
        ALL: {
            url: 'api/adapter-manager',
            options: { method: ApiClientMethod.GET }
        }
    },
    connection: {
        ALL: {
            url: 'api/v1/connections',
            options: { method: ApiClientMethod.GET }
        },
        GET: {
            url: 'api/v1/connections/:id',
            options: { method: ApiClientMethod.GET }
        },
        CREATE: {
            url: 'api/v1/connections',
            options: { method: ApiClientMethod.POST }
        },
        UPDATE: {
            url: 'api/v1/connections/:id',
            options: { method: ApiClientMethod.PUT }
        },
        DELETE: {
            url: 'api/v1/connections/:id',
            options: { method: ApiClientMethod.DELETE }
        },
        CHANGE_OWNER: {
            url: 'api/v1/connections/:id/object-owner-change',
            options: { method: ApiClientMethod.PUT }
        },
        CLONE: {
            url: 'api/v1/connections/:id/clone',
            options: { method: ApiClientMethod.POST }
        },
        CODE_EXISTS: {
            url: '/api/v1/connections/code/:code',
            options: { method: ApiClientMethod.GET }
        }
    },
    materialization: {
        ALL: {
            url: 'api/dataset-materialization',
            options: { method: ApiClientMethod.GET }
        },
        CREATE: {
            url: 'api/dataset-materialization',
            options: { method: ApiClientMethod.POST }
        },
        UPDATE: {
            url: 'api/dataset-materialization/:id',
            options: { method: ApiClientMethod.PUT }
        },
        DELETE: {
            url: 'api/dataset-materialization/:id',
            options: { method: ApiClientMethod.DELETE }
        }
    },
    materializationPlanner: {
        GET_SCHEDULE: {
            url: 'api/dataset-materialization-planner/schedule',
            options: { method: ApiClientMethod.GET }
        },
        UPDATE_SCHEDULE: {
            url: 'api/dataset-materialization-planner/batch-update',
            options: { method: ApiClientMethod.POST }
        },
        REFRESH: {
            url: 'api/dataset-materialization-planner/refresh',
            options: { method: ApiClientMethod.POST }
        }
    }
};

export const DatasetType = {
    DATASET: 1,
    REST: 2
};

export const DatasetEntityType = {
    METRIC: 1,
    DIMENSION: 2
};

export const MaterializationType = {
    DEFAULT: 1
};

export const MaterializationStatus = {
    INPROGRESS: 'INPROGRESS',
    COMPLETED: 'COMPLETED',
    FAILED: 'FAILED'
};

export const MaterializationPlannerCronType = {
    RAW: 1,
    INTERVAL: 2,
    TIMESTAMP: 3
};

/**
 * @param {IDatasetEntityTemplateProject|IDatasetEntityTemplate} entity
 * @param {number} type
 * @return {boolean}
 */
export const compareEntityType = (entity, type) => entity.typeId === type;

/**
 * @param {IDataset} dataset
 * @return {IDataset}
 */
const normalizeDataset = (dataset) => {
    const { schema: schemaSource } = dataset;
    let schema = schemaSource;
    if (typeof schemaSource === 'string') {
        try {
            schema = JSON.parse(schemaSource);
        } catch (e) {
            // noop
        }
    }
    return { ...dataset, schema };
};

/**
 * DataClientService class
 */
export class DataClientService extends BaseApiService {
    /**
     * @param {{ url:string }} options
     * @return {DataClientService}
     */
    context({ url }) {
        this._client.baseURL = url;
        return this;
    }

    get adapter() {
        /**
         * @return {Promise<ISafeResult<IAdapter[]>>}
         */
        const getAll = () => {
            const action = ServiceAction.adapter.ALL;
            const request = buildRequest({ action });
            return this.request(request);
        };

        return { getAll };
    }

    get adapterManager() {
        /**
         * @return {Promise<ISafeResult<IAdapterManager[]>>}
         */
        const getAll = () => {
            const action = ServiceAction.adapterManager.ALL;
            const request = buildRequest({ action });
            return this.request(request);
        };

        return { getAll };
    }

    get connection() {
        /**
         * @return {Promise<ISafeResult<IConnection[]>>}
         */
        const getAll = () => {
            const action = ServiceAction.connection.ALL;
            const request = buildRequest({ action });
            return this.request(request);
        };

        /**
         * @param {string|number} id
         * @return {Promise<ISafeResult<IConnection>>}
         */
        const get = (id) => {
            const action = ServiceAction.connection.GET;
            const request = buildRequest({ action, pathParams: { id } });
            return this.request(request);
        };

        /**
         * @param {IConnection} connection
         * @return {Promise<ISafeResult<IConnection>>}
         */
        const create = (connection) => {
            const action = ServiceAction.connection.CREATE;
            const request = buildRequest({ action, params: connection });
            return this.request(request);
        };

        /**
         * @param {IConnection} connection
         * @return {Promise<ISafeResult<IConnection>>}
         */
        const update = (connection) => {
            const action = ServiceAction.connection.UPDATE;
            const request = buildRequest({ action, params: connection, pathParams: { id: connection.id } });
            return this.request(request);
        };

        /**
         * @param {string|number} id
         * @return {Promise<ISafeResult>}
         */
        const deleteFn = (id) => {
            const action = ServiceAction.connection.DELETE;
            const request = buildRequest({ action, pathParams: { id } });
            return this.request(request);
        };

        /**
         * @param {{ id:number|string, ownerGroupId:number|string }} options
         * @return {Promise<ISafeResult>}
         */
        const changeOwner = ({ id, ownerGroupId: assignedOwnerGroupId }) => {
            const action = ServiceAction.connection.CHANGE_OWNER;
            const request = buildRequest({ action, pathParams: { id }, params: { assignedOwnerGroupId } });
            return this.request(request);
        };

        /**
         * @param {string|number} id
         * @return {Promise<ISafeResult<IConnection>>}
         */
        const clone = (id) => {
            const action = ServiceAction.connection.CLONE;
            const request = buildRequest({ action, pathParams: { id } });
            return this.request(request);
        };

        /**
         * @param {{ code:string, excludeId:string|number }} options
         * @return {Promise<ISafeResult<boolean>>}
         */
        const codeExists = async ({ code, excludeId }) => {
            const action = ServiceAction.connection.CODE_EXISTS;
            const { error, isSuccess } = await super.request(
                buildRequest({
                    action,
                    pathParams: { code },
                    params: { excludeId }
                })
            );
            if (isSuccess) {
                return success(true);
            }
            if (error instanceof ApiServiceError && error.code === ApiServiceError.Code.NOT_FOUND) {
                return success(false);
            }
            return fail(error);
        };

        /**
         * @param {string|number} id
         * @return {Promise<ISafeResult>}
         */
        const restore = (id) => {
            const error = new Error(`Method not yet implemented`);
            return SafeResult.fail(error);
        };

        return {
            getAll,
            get,
            create,
            update,
            delete: deleteFn,
            clone,
            restore,
            codeExists,
            changeOwner
        };
    }

    get dataset() {
        /**
         * @param {{ code:string }} options
         * @return {Promise<ISafeResult<IDataset>>}
         */
        const getByCode = async ({ code }) => {
            const action = ServiceAction.dataset.SEARCH;
            const request = buildRequest({ action, params: { query: code, field: 'code', exact: true } });
            const safeResult = await this.request(request);
            if (safeResult.isError) {
                return safeResult;
            }
            if (safeResult.result.length === 0) {
                return SafeResult.fail(
                    new ApiServiceError(`Dataset with code "${code}" not found in "${request.url}"`, {
                        code: ApiServiceError.Code.NOT_FOUND
                    })
                );
            }
            return SafeResult.success(normalizeDataset(safeResult.result[0]));
        };

        /**
         * @param {{ id:string }} options
         * @return {Promise<ISafeResult<IDataset>>}
         */
        const get = async ({ id }) => {
            const action = ServiceAction.dataset.GET;
            const request = buildRequest({ action, pathParams: { id } });
            const safeResult = await this.request(request);
            if (safeResult.isSuccess) {
                return SafeResult.success(normalizeDataset(safeResult.result));
            }
            return safeResult;
        };

        /**
         * @param {{ name:string, file:File, folderId:string|number, config:object, onUploadProgress:(event:ProgressEvent):void  }} options
         * @return {Promise<ISafeResult<IDataset>>}
         */
        const upload = async ({ name, file, folderId, config, onUploadProgress }) => {
            const meta = {
                folderId,
                name,
                config: JSON.stringify(config)
            };
            const action = ServiceAction.dataset.UPLOAD;
            const params = new FormData();
            params.append('file', new File([file], file.name, { type: file.type }));
            params.append(
                'res',
                new Blob([JSON.stringify(meta)], {
                    type: 'application/json'
                })
            );

            const request = buildRequest({ action, params, options: { onUploadProgress } });
            const safeResult = await this.request(request);
            if (safeResult.isSuccess) {
                return SafeResult.success(normalizeDataset(safeResult.result));
            }
            return safeResult;
        };

        /**
         * @param {{ id:string|number, name:string, folderId:string|number }} options
         * @return {Promise<ISafeResult<IDataset>>}
         */
        const clone = async ({ id, name, folderId }) => {
            const action = ServiceAction.dataset.CLONE;
            const request = buildRequest({ action, params: { name, folderId }, pathParams: { id } });
            const safeResult = await this.request(request);
            if (safeResult.isSuccess) {
                return SafeResult.success(normalizeDataset(safeResult.result));
            }
            return safeResult;
        };

        /**
         * @param {IDataset} dataset
         * @return {Promise<ISafeResult<IDataset>>}
         */
        const create = async (dataset) => {
            const action = ServiceAction.dataset.CREATE;
            const request = buildRequest({ action, params: dataset });
            const safeResult = await this.request(request);
            if (safeResult.isSuccess) {
                return SafeResult.success(normalizeDataset(safeResult.result));
            }
            return safeResult;
        };

        /**
         * @param {IDataset} dataset
         * @return {Promise<ISafeResult<IDataset>>}
         */
        const update = async ({ id, schema, ...rest }) => {
            const action = ServiceAction.dataset.UPDATE;
            const request = buildRequest({ action, params: { ...rest, schema: '' }, pathParams: { id } });
            const safeResult = await this.request(request);
            if (safeResult.isSuccess) {
                return SafeResult.success(normalizeDataset(safeResult.result));
            }
            return safeResult;
        };

        /**
         * @param {{ id:string }} options
         * @return {Promise<ISafeResult<IDataset>>}
         */
        const deleteFn = async ({ id }) => {
            const action = ServiceAction.dataset.DELETE;
            const request = buildRequest({ action, pathParams: { id } });
            const safeResult = await this.request(request);
            if (safeResult.isSuccess) {
                return SafeResult.success(normalizeDataset(safeResult.result));
            }
            return safeResult;
        };

        /**
         * @param {{ id:number|string, ownerGroupId:number|string }} options
         * @return {Promise<ISafeResult>}
         */
        const changeOwner = ({ id, ownerGroupId: assignedOwnerGroupId }) => {
            const action = ServiceAction.dataset.CHANGE_OWNER;
            const request = buildRequest({ action, pathParams: { id }, params: { assignedOwnerGroupId } });
            return this.request(request);
        };

        /**
         * @param {{ dataset:IDataset, metrics:IDatasetEntity[], dimensions:IDatasetEntity[], variables: IDatasetVariable[], order:IDatasetQuery['$order'], limit:number, offset:number }} options
         * @return {Promise<ISafeResult<IDatasetResultExtended>>}
         */
        const preview = async ({
            dataset,
            metrics = [],
            dimensions = [],
            variables = [],
            order = [],
            limit,
            offset
        }) => {
            const params = {
                query: {
                    $sql: dataset.definition,
                    $metrics: metrics.map(({ name, definition }) => ({ name, definition })),
                    $dimensions: dimensions.map(({ name, definition }) => ({ name, definition })),
                    $variables: variables.map(({ name, defaultValue, typeId, isNullable }) => ({
                        [name]: {
                            defaultValue,
                            typeId,
                            isNullable
                        }
                    })),
                    $order: order
                },
                limit,
                offset
            };
            const action = ServiceAction.dataset.PREVIEW;
            const request = buildRequest({ action, params });
            const safeResult = await this.request(request);
            if (safeResult.isSuccess) {
                const { result } = safeResult;
                return SafeResult.success({ ...result, limit, offset });
            }
            return safeResult;
        };

        /**
         * @param {{ code:string, excludeId: number|null }} options
         * @return {Promise<SafeResult<boolean>>}
         */
        const codeExists = async ({ code, excludeId = null }) => {
            const action = ServiceAction.dataset.CODE_EXISTS;
            const { error, isSuccess } = await super.request(buildRequest({ action, pathParams: { code }, params: { excludeId } }));
            if (isSuccess) {
                return success(true);
            }
            if (error instanceof ApiServiceError && error.code === ApiServiceError.Code.NOT_FOUND) {
                return success(false);
            }
            return fail(error);
        };

        return {
            codeExists,
            getByCode,
            get,
            upload,
            clone,
            create,
            update,
            delete: deleteFn,
            preview,
            changeOwner
        };
    }

    get datasetMeta() {
        /**
         * @param {{ id: IDataset['id'] }} options
         * @return {Promise<ISafeResult<IDatasetMeta>>}
         */
        const get = ({ id }) =>
            Promise.all([
                this.dataset.get({ id }),
                this.datasetEntity.getAll({ datasetId: id }),
                this.variable.getAll({ datasetId: id })
            ]).then(
                /**
                 *
                 * @param {IDataset} dataset
                 * @param {IDatasetEntity[]} entities
                 * @param {IDatasetVariable[]} variables
                 * @return {SafeResult<IDatasetMeta>}
                 */
                ([{ result: dataset }, { result: entities }, { result: variables}]) =>
                    SafeResult.success({
                        dataset,
                        variables,
                        metrics: entities.filter((entity) => compareEntityType(entity, DatasetEntityType.METRIC)),
                        dimensions: entities.filter((entity) => compareEntityType(entity, DatasetEntityType.DIMENSION))
                    })
            );

        /**
         * @param {{ folderId:string|number }} options
         * @return {Promise<ISafeResult<IDatasetMeta[]>>}
         */
        const getAll = async ({ folderId }) => {
            const action = ServiceAction.datasetMeta.ALL;
            const request = buildRequest({ action, params: { folderId } });
            const safeResult = await this.request(request);
            if (safeResult.isSuccess) {
                const values = safeResult.result.map(({ dataset, datasetEntity }) => ({
                    dataset: normalizeDataset(dataset),
                    metrics: datasetEntity.filter((entity) => compareEntityType(entity, DatasetEntityType.METRIC)),
                    dimensions: datasetEntity.filter((entity) => compareEntityType(entity, DatasetEntityType.DIMENSION))
                }));
                return SafeResult.success(values);
            }
            return safeResult;
        };

        /**
         * @param {{ query:string, templateId:string|number }} options
         * @return {Promise<ISafeResult<IDatasetMeta[]>>}
         */
        const search = async ({ query, templateId }) => {
            const action = ServiceAction.datasetMeta.SEARCH;
            const request = buildRequest({ action, params: { query, templateId } });
            const safeResult = await this.request(request);
            if (safeResult.isSuccess) {
                const values = safeResult.result.map(({ dataset, datasetEntity }) => ({
                    dataset: normalizeDataset(dataset),
                    metrics: datasetEntity.filter((entity) => compareEntityType(entity, DatasetEntityType.METRIC)),
                    dimensions: datasetEntity.filter((entity) => compareEntityType(entity, DatasetEntityType.DIMENSION))
                }));
                return SafeResult.success(values);
            }
            return safeResult;
        };

        /**
         * @param {{ folderIds: (string|number)[] }} options
         * @return {Promise<ISafeResult<IFolderChildCount[]>>}
         */
        const countChildren = ({ folderIds = [] }) => {
            const action = ServiceAction.datasetMeta.COUNT_BY_FOLDER;
            const request = buildRequest({ action, params: { folderIds } });
            return this.request(request);
        };

        return { get, getAll, search, countChildren };
    }

    get datasetFolder() {
        /**
         * @param {{ parentFolderId?: string|number|null }} [options]
         * @return {Promise<ISafeResult.<IDatasetFolder[]>>}
         */
        const getAll = ({ parentFolderId: parentId = null } = {}) => {
            const action = ServiceAction.folder.ALL;
            const request = buildRequest({ action, params: { parentId } });
            return this.request(request);
        };

        /**
         * @param {{ id:string|number }} options
         * @return {Promise<ISafeResult<IDatasetFolder>>}
         */
        const get = ({ id }) => {
            const action = ServiceAction.folder.GET;
            const request = buildRequest({ action, pathParams: { id } });
            return this.request(request);
        };

        /**
         * @param {IDatasetFolder} folder
         * @return {Promise<ISafeResult<IDatasetFolder>>}
         */
        const create = (folder) => {
            const action = ServiceAction.folder.CREATE;
            const request = buildRequest({ action, params: folder });
            return this.request(request);
        };

        /**
         * @param {IDatasetFolder} folder
         * @return {Promise<ISafeResult<IDatasetFolder>>}
         */
        const update = (folder) => {
            const action = ServiceAction.folder.UPDATE;
            const request = buildRequest({ action, params: folder, pathParams: { id: folder.id } });
            return this.request(request);
        };

        /**
         * @param {{ id:string|number }} options
         * @return {Promise<ISafeResult<IDatasetFolder>>}
         */
        const deleteFn = ({ id }) => {
            const action = ServiceAction.folder.DELETE;
            const request = buildRequest({ action, pathParams: { id } });
            return this.request(request);
        };

        /**
         * @param {{ id:number|string, ownerGroupId:number|string }} options
         * @return {Promise<ISafeResult>}
         */
        const changeOwner = ({ id, ownerGroupId: assignedOwnerGroupId }) => {
            const action = ServiceAction.folder.CHANGE_OWNER;
            const request = buildRequest({ action, pathParams: { id }, params: { assignedOwnerGroupId } });
            return this.request(request);
        };

        /**
         * @param {{ code:string, excludeId: number|null }} options
         * @return {Promise<SafeResult<boolean>>}
         */
        const codeExists = async ({ code, excludeId = null }) => {
            const action = ServiceAction.folder.CODE_EXISTS;
            const { error, isSuccess } = await super.request(buildRequest({ action, pathParams: { code }, params: { excludeId } }));
            if (isSuccess) {
                return success(true);
            }
            if (error instanceof ApiServiceError && error.code === ApiServiceError.Code.NOT_FOUND) {
                return success(false);
            }
            return fail(error);
        };

        /**
         * @param {{ parentIds: (string|number)[] }} options
         * @return {Promise<ISafeResult<IFolderChildCount[]>>}
         */
        const countChildren = ({ parentIds = [] } = {}) => {
            const action = ServiceAction.folder.COUNT_BY_FOLDER;
            const request = buildRequest({ action, params: { parentIds } });
            return this.request(request);
        };

        return {
            getAll,
            get,
            create,
            update,
            delete: deleteFn,
            codeExists,
            countChildren,
            changeOwner
        };
    }

    get datasetEntity() {
        /**
         * @param {{ datasetId:string }} options
         * @return {Promise<ISafeResult<IDatasetEntity[]>>}
         */
        const getAll = ({ datasetId }) => {
            const action = ServiceAction.entity.ALL;
            const request = buildRequest({ action, params: { datasetId } });
            return this.request(request);
        };

        /**
         * @param {{ datasetId:string|number, metrics:IDatasetEntity[], dimensions:IDatasetEntity[] }} options
         * @return {Promise<{ metrics:IDatasetEntity[], dimensions:IDatasetEntity[] }>}
         */
        const batchUpdate = async ({ datasetId, metrics, dimensions }) => {
            const action = ServiceAction.entity.BATCH_UPDATE;
            const params = {
                datasetId: datasetId,
                datasetEntity: [...metrics, ...dimensions]
            };
            const request = buildRequest({ action, params });
            const safeResult = await this.request(request);
            if (safeResult.isSuccess) {
                /** @type {{ result:IDatasetEntity[] }} */
                const { result } = safeResult;

                return SafeResult.success({
                    metrics: result.filter((entity) => compareEntityType(entity, DatasetEntityType.METRIC)),
                    dimensions: result.filter((entity) => compareEntityType(entity, DatasetEntityType.DIMENSION))
                });
            }
            return safeResult;
        };

        return {
            getAll,
            batchUpdate
        };
    }

    get variable() {
        /**
         * @param {Pick<>} options
         * @return {Promise<ISafeResult<IDatasetEntity[]>>}
         */
        const getAll = ({ datasetId }) => {
            const action = ServiceAction.variable.ALL;
            const request = buildRequest({ action, params: { datasetId } });
            return this.request(request);
        };

        /**
         * @param {{ datasetId: IDatasetVariable['datasetId'], variables: IDatasetVariable[]  }} options
         * @return {Promise<IDatasetVariable[]>}
         */
        const batchUpdate = async ({ datasetId, variables }) => {
            const action = ServiceAction.variable.BATCH_UPDATE;
            const params = {
                datasetId: datasetId,
                datasetVariable: variables
            };
            const request = buildRequest({ action, params });
            return this.request(request);
        };

        return {
            getAll,
            batchUpdate
        }
    }

    get datasetEntityTemplate() {
        /**
         * @param {{ query: string }} options
         * @return {Promise<ISafeResult<IDatasetEntityTemplate[]>>}
         */
        const search = ({ query }) => {
            const action = ServiceAction.entityTemplate.SEARCH;
            const request = buildRequest({ action, params: { query } });
            return this.request(request);
        };

        /**
         * @param {{ folderId?: string|number|null }} [options]
         * @return {Promise<ISafeResult<IDatasetEntityTemplate[]>>}
         */
        const getAll = ({ folderId = null } = {}) => {
            const action = ServiceAction.entityTemplate.ALL;
            const request = buildRequest({ action, params: { folderId } });
            return this.request(request);
        };

        /**
         * @param {{ id:string }} options
         * @return {Promise<ISafeResult<IDatasetEntityTemplate>>}
         */
        const get = ({ id }) => {
            const action = ServiceAction.entityTemplate.GET;
            const request = buildRequest({ action, pathParams: { id } });
            return this.request(request);
        };

        /**
         * @param {{ id:string|number, name:string, folderId:string|number }} options
         * @return {Promise<ISafeResult<IDatasetEntityTemplate>>}
         */
        const clone = ({ id, name, folderId }) => {
            const action = ServiceAction.entityTemplate.CLONE;
            const request = buildRequest({ action, params: { name, folderId }, pathParams: { id } });
            return this.request(request);
        };

        /**
         * @param {IDatasetEntityTemplate} entityTemplate
         * @return {Promise<ISafeResult<IDatasetEntityTemplate>>}
         */
        const create = (entityTemplate) => {
            const action = ServiceAction.entityTemplate.CREATE;
            const request = buildRequest({ action, params: entityTemplate });
            return this.request(request);
        };

        /**
         * @param {IDatasetEntityTemplate} entityTemplate
         * @return {Promise<ISafeResult<IDatasetEntityTemplate>>}
         */
        const update = (entityTemplate) => {
            const action = ServiceAction.entityTemplate.UPDATE;
            const request = buildRequest({ action, params: entityTemplate, pathParams: { id: entityTemplate.id } });
            return this.request(request);
        };

        /**
         * @param {{ id:string }} options
         * @return {Promise<ISafeResult<IDatasetEntityTemplate>>}
         */
        const deleteFn = ({ id }) => {
            const action = ServiceAction.entityTemplate.DELETE;
            const request = buildRequest({ action, pathParams: { id } });
            return this.request(request);
        };

        /**
         * @param {{ id:number|string, ownerGroupId:number|string }} options
         * @return {Promise<ISafeResult>}
         */
        const changeOwner = ({ id, ownerGroupId: assignedOwnerGroupId }) => {
            const action = ServiceAction.entityTemplate.CHANGE_OWNER;
            const request = buildRequest({ action, pathParams: { id }, params: { assignedOwnerGroupId } });
            return this.request(request);
        };

        /**
         * @param {{ code: string, excludeId: number|null }} options
         * @return {Promise<SafeResult<boolean>>}
         */
        const codeExists = async ({ code, excludeId = null }) => {
            const action = ServiceAction.entityTemplate.CODE_EXISTS;
            const { error, isSuccess } = await super.request(buildRequest({ action, pathParams: { code }, params: { excludeId } }));
            if (isSuccess) {
                return success(true);
            }
            if (error instanceof ApiServiceError && error.code === ApiServiceError.Code.NOT_FOUND) {
                return success(false);
            }
            return fail(error);
        };

        /**
         * @param {{ folderIds: (string|number)[] }} options
         * @return {Promise<ISafeResult<IFolderChildCount[]>>}
         */
        const countChildren = ({ folderIds = [] }) => {
            const action = ServiceAction.entityTemplate.COUNT_BY_FOLDER;
            const request = buildRequest({ action, params: { folderIds } });
            return this.request(request);
        };

        return {
            search,
            getAll,
            get,
            clone,
            create,
            update,
            delete: deleteFn,
            codeExists,
            countChildren,
            changeOwner
        };
    }

    get datasetEntityTemplateFolder() {
        /**
         * @param {{  parentFolderId:string|number }} options
         * @return {Promise<ISafeResult<IDatasetEntityTemplateFolder[]>>}
         */
        const getAll = ({ parentFolderId: parentId }) => {
            // @NOTE projectId -- unused
            const action = ServiceAction.entityTemplateFolder.ALL;
            const isRoot = parentId == null;
            const request = buildRequest({ action, params: { parentId, isRoot } });
            return this.request(request);
        };

        /**
         * @param {{ id:string }} options
         * @return {Promise<ISafeResult<IDatasetEntityTemplateFolder>>}
         */
        const get = ({ id }) => {
            const action = ServiceAction.entityTemplateFolder.GET;
            const request = buildRequest({ action, pathParams: { id } });
            return this.request(request);
        };

        /**
         * @param {IDatasetEntityTemplateFolder} folder
         * @return {Promise<ISafeResult<IDatasetEntityTemplateFolder>>}
         */
        const create = (folder) => {
            const action = ServiceAction.entityTemplateFolder.CREATE;
            const request = buildRequest({ action, params: folder });
            return this.request(request);
        };

        /**
         * @param {IDatasetEntityTemplateFolder} folder
         * @return {Promise<ISafeResult<IDatasetEntityTemplateFolder>>}
         */
        const update = (folder) => {
            const action = ServiceAction.entityTemplateFolder.UPDATE;
            const request = buildRequest({ action, params: folder, pathParams: { id: folder.id } });
            return this.request(request);
        };

        /**
         * @param {{ id:string }} options
         * @return {Promise<ISafeResult<IDatasetEntityTemplateFolder>>}
         */
        const deleteFn = ({ id }) => {
            const action = ServiceAction.entityTemplateFolder.DELETE;
            const request = buildRequest({ action, pathParams: { id } });
            return this.request(request);
        };

        /**
         * @param {{ id:number|string, ownerGroupId:number|string }} options
         * @return {Promise<ISafeResult>}
         */
        const changeOwner = ({ id, ownerGroupId: assignedOwnerGroupId }) => {
            const action = ServiceAction.entityTemplateFolder.CHANGE_OWNER;
            const request = buildRequest({ action, pathParams: { id }, params: { assignedOwnerGroupId } });
            return this.request(request);
        };

        /**
         * @param {{ code:string, excludeId: number|null }} options
         * @return {Promise<SafeResult<boolean>>}
         */
        const codeExists = async ({ code, excludeId = null }) => {
            const action = ServiceAction.entityTemplateFolder.CODE_EXISTS;
            const { error, isSuccess } = await super.request(buildRequest({ action, pathParams: { code }, params: { excludeId } }));
            if (isSuccess) {
                return success(true);
            }
            if (error instanceof ApiServiceError && error.code === ApiServiceError.Code.NOT_FOUND) {
                return success(false);
            }
            return fail(error);
        };

        /**
         * @param {{ parentIds: (string|number)[] }} options
         * @return {Promise<ISafeResult<IFolderChildCount[]>>}
         */
        const countChildren = ({ parentIds = [] }) => {
            const action = ServiceAction.entityTemplateFolder.COUNT_BY_FOLDER;
            const request = buildRequest({ action, params: { parentIds } });
            return this.request(request);
        };

        return {
            getAll,
            get,
            create,
            update,
            delete: deleteFn,
            codeExists,
            countChildren,
            changeOwner
        };
    }

    get datasetEntityProject() {
        /**
         * @return {Promise<ISafeResult<IDatasetEntityTemplateProject[]>>}
         */
        const getAll = () => {
            const action = ServiceAction.entityTemplateProject.ALL;
            const request = buildRequest({ action });
            return this.request(request);
        };
        return { getAll };
    }

    get externalSource() {
        /**
         * @param {{ connectionId:string|number, schema?: string[] }} options
         * @return {Promise<ISafeResult<{ schemas:IExternalSourceSchema[], tables:IExternalSourceTable[] }[]>>}
         */
        const getTableSchema = ({ connectionId, schema = [] }) => {
            const action = ServiceAction.externalSource.GET_TABLE_SCHEMA;
            const request = buildRequest({ action, params: { connectionId, schema } });
            return this.request(request);
        };

        /**
         * @param {{ connectionId:string|number, path?: string[] }} options
         * @return {Promise<ISafeResult<{ fields:IExternalSourceFieldSchema[] }[]>>}
         */
        const getFieldSchema = ({ connectionId, path = [] }) => {
            const action = ServiceAction.externalSource.GET_FIELD_SCHEMA;
            const request = buildRequest({ action, params: { connectionId, path } });
            return this.request(request);
        };

        return { getTableSchema, getFieldSchema };
    }

    get materialization() {
        const { materialization: Action } = ServiceAction;

        /**
         * @param {IDatasetMaterialization} item
         * @return {IDatasetMaterialization}
         */
        const patchMaterialization = (item) =>
            typeof item.schema === 'string' ? { ...item, schema: JSON.parse(item.schema) } : item;

        /**
         * @param {{ datasetId:string|number }} options
         * @return {Promise<ISafeResult<IDatasetMaterialization[]>>}
         */
        const getAll = async ({ datasetId }) => {
            const action = Action.ALL;
            const request = buildRequest({ action, params: { datasetId } });
            /** @type {SafeResult<IDatasetMaterialization[]>} */
            const safeResult = await this.request(request);
            if (safeResult.isError) {
                return safeResult;
            }
            return SafeResult.success(safeResult.result.map((item) => patchMaterialization(item)));
        };

        /**
         * @param {Partial<IDatasetMaterialization>} materialization
         * @return {Promise<ISafeResult<IDatasetMaterialization>>}
         */
        const create = async (materialization) => {
            const action = Action.CREATE;
            /** @type {SafeResult<IDatasetMaterialization>} */
            const request = buildRequest({ action, params: materialization });
            /** @type {SafeResult<IDatasetMaterialization>} */
            const safeResult = await this.request(request);
            if (safeResult.isError) {
                return safeResult;
            }
            return SafeResult.success(patchMaterialization(safeResult.result));
        };

        /**
         * @param {Partial<IDatasetMaterialization>} materialization
         * @return {Promise<ISafeResult<IDatasetMaterialization>>}
         */
        const update = async (materialization) => {
            const { id } = materialization;
            const action = Action.UPDATE;
            const request = buildRequest({ action, params: materialization, pathParams: { id } });
            /** @type {SafeResult<IDatasetMaterialization>} */
            const safeResult = await this.request(request);
            if (safeResult.isError) {
                return safeResult;
            }
            return SafeResult.success(patchMaterialization(safeResult.result));
        };

        /**
         * @param {IDatasetMaterialization} materialization
         * @return {Promise<ISafeResult<IDatasetMaterialization>>}
         */
        const deleteFn = async ({ id }) => {
            const action = Action.DELETE;
            const request = buildRequest({ action, pathParams: { id } });
            /** @type {SafeResult<IDatasetMaterialization>} */
            const safeResult = await this.request(request);
            if (safeResult.isError) {
                return safeResult;
            }
            return SafeResult.success(patchMaterialization(safeResult.result));
        };

        return {
            getAll,
            create,
            update,
            delete: deleteFn
        };
    }

    get materializationPlanner() {
        const { materializationPlanner: Action } = ServiceAction;
        /**
         * @param {{ materializationId:string|number }} options
         * @return {Promise<ISafeResult<IDatasetMaterializationPlannerSchedule[]>>}
         */
        const getSchedule = ({ materializationId }) => {
            const action = Action.GET_SCHEDULE;
            const request = buildRequest({ action, params: { materializationId } });
            return this.request(request);
        };

        /**
         * @param {{ materializationId:string|number, schedule:IDatasetMaterializationPlannerSchedule[] }} options
         * @return {Promise<ISafeResult<IDatasetMaterializationPlannerSchedule[]>>}
         */
        const updateSchedule = ({ materializationId, schedule }) => {
            const action = Action.UPDATE_SCHEDULE;
            const request = buildRequest({ action, params: { materializationId, schedule } });
            return this.request(request);
        };

        /**
         * @param {{ materializationId:string|number }} options
         * @return {Promise<ISafeResult<IDatasetMaterializationPlannerSchedule[]>>}
         */
        const refresh = ({ materializationId }) => {
            const action = Action.REFRESH;
            const request = buildRequest({ action, params: { materializationId } });
            return this.request(request);
        };

        return { getSchedule, updateSchedule, refresh };
    }
}

/**
 * Service factory
 * @param {{ client:import('@goodt-common/api').ApiHttpClient, options:import('@goodt-common/api').IApiServiceOptions, transport:import('@goodt-common/net').ITransport }} options service options
 * @return {DataClientService} service instance
 */
export const createDataClientService = ({ client, options, transport } = {}) =>
    new DataClientService({ client, options, transport });
