import { cloneDeep } from 'lodash';
import { Url } from '@goodt-common/utils';

import { complement as isNot, isNil, both, isEmpty } from 'ramda';

const normalizeParams = (params) => {
    return Object.fromEntries(
        Object.entries(params)
            .map(([key, value]) => {
                const withoutNilItems = [value].flat().filter(both(isNot(isNil), isNot(isEmpty)));
                return [key, withoutNilItems];
            })
            .filter(([, values]) => values.length > 0)
            // order by param keys
            .sort(([keyA], [keyB]) => keyA.localeCompare(keyB))
    );
};

const resolveUrl = (url, baseURL) => (url.startsWith('http') ? url : Url.join(baseURL, url));

class HttpTransportWithCache {
    /**
     * Wrapped delegate ITransport
     *
     * @type {import('@goodt-common/net').ITransport}
     * @private
     */
    _http;

    /**
     * Wrapped delegate ITransport
     *
     * @type {HttpTransportCacheService}
     * @private
     */
    _cacheService;

    constructor({ http, cacheService }) {
        this._http = http;
        this._cacheService = cacheService;
    }

    // PROXY
    /**
     *
     * @return {string}
     */
    get baseURL() {
        return this._http.baseURL;
    }

    /**
     * @param {string} baseUrl
     */
    set baseURL(baseUrl) {
        this._http.baseURL = baseUrl;
    }

    dispose() {
        this._http.dispose();
    }

    /**
     * Process request with caching service
     * Serve from cache or pass request to ITransport delegate and then cache
     *
     * @param {import('@goodt-common/net').ITransportRequest} request
     * @return {Promise<import('@goodt-common/net').ITransportResponse>}
     */
    async request(request) {
        const { baseURL } = this._http;

        if (this._cacheService.isCachingRequired(request, { baseURL }) === false) {
            const response = this._http.request(request);
            return this._cacheService.wrapResponse(request, response, { baseURL });
        }

        const serializedRequest = this._cacheService.serializeRequest(request, { baseURL });
        const cachedResponse = this._cacheService.getResponseFromCache(serializedRequest);

        if (cachedResponse != null) {
            this._cacheService.log(`${serializedRequest}: CACHE`);
            return cachedResponse;
        }

        const response = this._http.request(request);
        this._cacheService.log(`${serializedRequest}: NETWORK`);
        this._cacheService.putResponseToCache(serializedRequest, response, request);

        return response;
    }
}

/**
 * @class HttpTransportCacheService
 */
export class HttpTransportCacheService {
    /**
     * Service should cache
     *
     * @type {boolean}
     */
    _isEnabled = false;

    /**
     * Debug mode is enabled
     *
     * @type {boolean}
     * @private
     */
    _isDebugMode = false;

    /**
     * Cached response lifetime
     *
     * @type {number}
     */
    lifetime = 1000;

    /**
     * Caching urls set
     *
     * @type {Set<string>}
     * @private
     */
    _cachingUrls = new Set();

    /**
     * Cached responses map stored by serialized request
     *
     * @type {Map<string, { response: import('@goodt-common/net').ITransportResponse, expire: number }>}
     * @private
     */
    _cachedResponses = new Map();

    constructor() {
        this.log(this._isEnabled ? 'ON' : 'OFF');
    }

    /**
     * @return {boolean}
     */
    get isEnabled() {
        return this._isEnabled;
    }

    /**
     * @param {boolean} isEnabled
     */
    set isEnabled(isEnabled) {
        this._isEnabled = isEnabled;
        this.log(this._isEnabled ? 'ON' : 'OFF');
    }

    // IApiCacheService interface methods

    /**
     * @param {boolean} isDebugMode
     */
    setDebugMode(isDebugMode) {
        this._isDebugMode = Boolean(isDebugMode);
    }

    /**
     * Adds caching url to service
     *
     * @param {string} url
     */
    addUrl(url) {
        this._cachingUrls.add(url);
    }

    /**
     * Removes caching from service
     *
     * @param {string} url
     */
    removeUrl(url) {
        this._cachingUrls.delete(url);
    }

    /**
     * Clears all caching urls from service
     */
    clearUrls() {
        this._cachingUrls.clear();
    }

    /**
     * Clears all cached responses
     */
    clearCache() {
        this._cachedResponses.clear();
    }

    // OWN
    /**
     * Wraps ITransport instance with response caching service
     *
     * @param {import('@goodt-common/net').ITransport} http
     * @return {HttpTransportWithCache}
     */
    wrap(http) {
        return new HttpTransportWithCache({ http, cacheService: this });
    }

    /**
     * Checks if caching required
     *
     * @param {import('@goodt-common/net').ITransportRequest} request
     * @param {string} baseURL
     *
     * @return {boolean}
     */
    isCachingRequired(request, { baseURL }) {
        if (this.isEnabled === false) {
            return false;
        }

        const { url, method = 'get', options: { cache } = {} } = request;
        const resolvingUrl = resolveUrl(url, baseURL);

        if (cache === false) {
            return false;
        }

        if ([...this._cachingUrls].some((cachingUrl) => resolvingUrl === cachingUrl)) {
            return true;
        }

        if (method.toLowerCase() !== 'get' && [false, undefined, null].includes(cache)) {
            return false;
        }

        return [...this._cachingUrls].some((cachingUrl) => resolvingUrl.startsWith(cachingUrl));
    }

    /**
     * Для мутирующих апи запросов (не GET) и не указанных принудительно как кешируемые,
     * но при этом относящихся к baseURL апи, который указан как кешируемый
     * откладывать возвращение промиса ответа на одну макрозадачу,
     * чтобы предыдущий закешированный промис запроса на чтение успел зарезолвиться
     * и удалиться из кеша
     *
     * @param {import('@goodt-common/net').ITransportRequest} request
     * @param {Promise<import('@goodt-common/net').ITransportResponse>} response
     * @param {string} baseURL
     */
    wrapResponse(request, response, { baseURL }) {
        const { method = 'get', url } = request;
        // is requesting url in caching
        const isCachingUrl = [...this._cachingUrls].some((cachingUrl) =>
            resolveUrl(url, baseURL).startsWith(cachingUrl)
        );

        // если HTTP-метод не 'GET' и при этом url этого апи подпадает под кеширование
        if (method.toLowerCase() !== 'get' && isCachingUrl) {
            return new Promise((resolve) => {
                setTimeout(() => resolve(response));
            });
        }

        return response;
    }

    /**
     * Try serve response from cache with lifetime checking and cache invalidating
     *
     * @param {string} serializedRequest
     * @return {null|Promise<import('@goodt-common/net').ITransportResponse>}
     */
    getResponseFromCache(serializedRequest) {
        const cacheData = this._cachedResponses.get(serializedRequest);
        if (cacheData == null) {
            return null;
        }
        if (cacheData.expire > Date.now()) {
            return cacheData.response.then(cloneDeep);
        }
        this._cachedResponses.delete(serializedRequest);

        return null;
    }

    /**
     * Put response to cache
     *
     * @param {string} serializedRequest
     * @param {Promise<import('@goodt-common/net').ITransportResponse>} response
     * @param {import('@goodt-common/net').ITransportRequest} request
     */
    putResponseToCache(serializedRequest, response, request) {
        const { options: { cache = {} } = {} } = request;
        const { lifetime = null } = cache;

        this._cachedResponses.set(serializedRequest, {
            response,
            // если указан lifetime request.options.cache.lifetime используем его
            // в противном случае используем this.lifetime
            expire: Date.now() + 60 * 1000
        });

        response
            .then(() => {
                const cachedResponse = this._cachedResponses.get(serializedRequest);
                cachedResponse.expire = Date.now() + (lifetime == null ? this.lifetime : lifetime);
            })
            .catch(() => {
                this._cachedResponses.delete(serializedRequest);
            });

        // удалять response промис
        // когда он был зарезолвлен, в случае если не указан
        // lifetime в request.options.cache.lifetime
    }

    /**
     * Serialize ITransportRequest request object to string to use as cache map key
     *
     * @param {import('@goodt-common/net').ITransportRequest} request
     * @param {string} baseURL
     * @return {string}
     */
    serializeRequest(request, { baseURL }) {
        const { url, params, options: { params: queryParams } = {} } = request;
        const query = { ...queryParams, ...params };
        const href = resolveUrl(url, baseURL);

        const serializedUrl = Url.create({
            href,
            query: normalizeParams(query)
        });

        return decodeURIComponent(serializedUrl.toString());
    }

    /**
     * @param {string|string[]} message
     */
    log(...args) {
        if (this._isDebugMode) {
            console.log('HTTP CACHE', ...args);
        }
    }
}

export const HttpTransportCacheServiceSymbol = Symbol('HttpClientCacheServiceSymbol');
export const createHttpTransportCacheService = () => new HttpTransportCacheService();
