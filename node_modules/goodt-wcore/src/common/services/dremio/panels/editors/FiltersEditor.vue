<template>
    <div class="pad-l1">
        <div class="btn btn-primary w-100 p" @click="openNewEditor">Добавить фильтр</div>
        <div v-for="(filter, i) in filtersEdit" :key="i">
            <hr v-if="i" class="mar-v-l1" />
            <filter-item-editor
                v-bind="{
                    filter: {
                        name: getFilterName(filter),
                        type: getFilterType(filter),
                        value: getFilterValue(filter)
                    },
                    filterTypes,
                    filterNamesAvailable: [...filterNamesAvailable, getFilterName(filter)]
                }"
                @change="(info) => onFilterChange(i, info)"
                @delete="() => onFilterDelete(i)" />
        </div>

        <div v-if="showNewEditor" class="popup" style="z-index: 10; align-items: safe start">
            <div class="popup-dialog w-11-12 mar-top-l1">
                <div class="popup-dialog-body">
                    <filter-item-editor
                        v-bind="{
                            filterTypes,
                            filterNamesAvailable,
                            deletable: false
                        }"
                        @change="(info) => onNewFilterChange(info)" />
                </div>
                <div class="popup-dialog-footer pad-top-none text-right">
                    <button class="btn btn-ghost btn-small mar-right-3" @click="showNewEditor = false">Отмена</button>
                    <button
                        class="btn btn-primary btn-small"
                        :class="{ disabled: newFilter == null }"
                        @click="onNewFilterAdd">
                        Сохранить
                    </button>
                </div>
            </div>
        </div>
    </div>
</template>
<script>
import { cloneDeep } from 'lodash';
import { Query } from 'goodt-dremio-sdk';
import FilterItemEditor from './FilterItemEditor.vue';

const { FILTER_TYPE, FILTER_TYPE_VALUE_VALIDATION } = Query;
const filterNames = {
    [FILTER_TYPE.EQ]: '=',
    [FILTER_TYPE.EQ_NOT]: '!=',
    [FILTER_TYPE.LESS]: '<',
    [FILTER_TYPE.LESS_EQ]: '<=',
    [FILTER_TYPE.GREATER]: '>',
    [FILTER_TYPE.GREATER_EQ]: '>=',
    [FILTER_TYPE.IS]: 'is',
    [FILTER_TYPE.IS_NOT]: 'is not',
    [FILTER_TYPE.IN]: 'in',
    [FILTER_TYPE.IN_NOT]: 'not in',
    [FILTER_TYPE.BETWEEN]: 'between',
    [FILTER_TYPE.BETWEEN_NOT]: 'not between',
    [FILTER_TYPE.LIKE]: 'like'
};
const filterNameKeys = Object.keys(filterNames);
const filterTypes = Object.entries(FILTER_TYPE)
    .sort(([ka, a], [kb, b]) => filterNameKeys.indexOf(a) - filterNameKeys.indexOf(b))
    .reduce((acc, [key, val]) => {
        const name = filterNames[val] || key;
        const validator = FILTER_TYPE_VALUE_VALIDATION[val];
        return {
            ...acc,
            [val]: {
                name,
                validator
            }
        };
    }, {});

export default {
    components: {
        FilterItemEditor
    },
    static: {
        filterTypes
    },
    props: {
        metrics: {
            type: Array,
            default() {
                return [];
            }
        },
        dimensionList: {
            type: Object,
            default() {
                return {};
            }
        },
        fields: {
            type: Object,
            default() {
                return {};
            }
        },
        filters: {
            type: Array,
            default() {
                return [];
            }
        }
    },
    data() {
        return {
            showNewEditor: false,
            newFilter: null,
            filtersEdit: []
        };
    },
    computed: {
        filterNames() {
            return this.filtersEdit.map((el) => this.getFilterName(el));
        },
        filterNamesAvailable() {
            return [...this.metricNames, ...Object.keys(this.dimensionList), ...Object.keys(this.fields)].filter(
                (el, i, a) => a.indexOf(el) === i && this.filterNames.indexOf(el) < 0
            );
        },
        metricNames() {
            return this.metrics.map((el) => Query.getMetricName(el));
        }
    },
    watch: {
        filters: {
            handler(val) {
                this.filtersEdit = cloneDeep(val);
            },
            immediate: true
        }
    },
    methods: {
        openNewEditor() {
            this.newFilter = null;
            this.showNewEditor = true;
        },
        filtersChanged() {
            this.$emit('change', this.filtersEdit);
        },
        getFilterName(filter) {
            return Query.getFilterName(filter);
        },
        getFilterType(filter) {
            return Query.getFilterType(filter);
        },
        getFilterValue(filter) {
            return Query.getFilterValue(filter);
        },
        onNewFilterAdd() {
            const filter = Query.createFilter(this.newFilter);
            this.filtersEdit.push(filter);
            this.filtersChanged();
            this.showNewEditor = false;
        },
        onNewFilterChange({ name, type, value }) {
            this.newFilter = { name, type, value };
        },
        onFilterChange(i, { name, type, value }) {
            const filter = Query.createFilter({ name, type, value });
            this.filtersEdit.splice(i, 1, filter);
            this.filtersChanged();
        },
        onFilterDelete(i) {
            this.filtersEdit.splice(i, 1);
            this.filtersChanged();
        }
    }
};
</script>