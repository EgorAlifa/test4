import { cloneDeep } from 'lodash';
import { Query, SDK } from 'goodt-dremio-sdk';
import { useFetchDataEventMixin } from '@goodt-common/mixins';
import { DremioPresentableError } from './errors';
import { DREMIO_CONFIG_DESCRIPTOR_PROPS_ACCESSOR, useSDKFactory } from './sdk';

class CancelToken {
    isCancelled = false;

    cancel() {
        this.isCancelled = true;
    }
}

/**
 * (dremio) Widget component mixin
 */
const mixin = {
    mixins: [useFetchDataEventMixin({ methodName: 'loadData' })],
    data() {
        return {
            /**
             * Dremio query 'offset'
             *
             * @property {number}
             */
            offset: 0,
            /**
             * @property {DremioResult}
             */
            result: null,
            /**
             * @property {Query}
             */
            queryHelper: null,
            /**
             * @property {boolean}
             */
            watchStoreState: true,
            /**
             * loadData() method hooks
             *
             * @see loadData()
             * @property {Record<string, any>}
             */
            loadDataHooks: {
                defaults: {
                    before: (/* cancel */) => {
                        this.loading = true;
                    },
                    catch: (error) => this.handleError(error),
                    finally: () => {
                        this.loading = false;
                    }
                },
                before: (cancel) => this.loadDataHooks.defaults.before(cancel),
                then: (result) => result,
                catch: (error) => this.loadDataHooks.defaults.catch(error),
                finally: () => this.loadDataHooks.defaults.finally()
            },
            loading: false,
            error: null
        };
    },
    computed: {
        /**
         * alias ~ props.dremio.limit
         *
         * @return {number}
         */
        limit() {
            const { [DREMIO_CONFIG_DESCRIPTOR_PROPS_ACCESSOR]: dremio } = this.props;
            return dremio && dremio.limit != null ? dremio.limit : 0;
        },
        /**
         * alias ~ result.rowCount
         *
         * @return {number}
         */
        rowCount() {
            return this.result ? this.result.rowCount : 0;
        },
        page: {
            /**
             * @param {number} val
             */
            set(val) {
                this.offset = (val - 1) * this.limit;
            },
            /**
             * @return {number}
             */
            get() {
                return this.limit ? this.offset / this.limit + 1 : 1;
            }
        },
        /**
         * @return {number}
         */
        pages() {
            // @ts-ignore
            return this.limit ? Math.ceil(this.rowCount / this.limit) : 1;
        },
        /**
         * @return {?string}
         */
        // eslint-disable-next-line unicorn/prevent-abbreviations
        dremioStr() {
            try {
                return JSON.stringify(this.props[DREMIO_CONFIG_DESCRIPTOR_PROPS_ACCESSOR]);
            } catch {
                return null;
            }
        }
    },
    created() {
        /**
         * @property {SDK}
         */
        this.dremioSdk = useSDKFactory(this.props[DREMIO_CONFIG_DESCRIPTOR_PROPS_ACCESSOR]);
        /**
         * @property {string[]}
         */
        this.dremioVars = [];

        this.dremioHandler();

        // watch store state if enabled
        if (this.watchStoreState) {
            this.$watchStore({ handler: (_, state) => this.storeStateWatcher(state) });
        }
        if (this.isEditorMode) {
            this.$watch(
                () => this.props[DREMIO_CONFIG_DESCRIPTOR_PROPS_ACCESSOR]?.dataProviderId,
                this.dataProviderChangeHandler
            );
            this.$watch('dremioStr', this.dremioHandler);
        }
    },
    destroyed() {
        this.dremioSdk.cancelActiveRequests();
    },
    methods: {
        dataProviderChangeHandler() {
            this.dremioSdk = useSDKFactory(this.props[DREMIO_CONFIG_DESCRIPTOR_PROPS_ACCESSOR]);
        },
        /**
         * Loads data via dremio sdk
         */
        loadData() {
            this.dremioSdk.cancelActiveRequests();

            const cancelToken = new CancelToken();
            this.loadDataHooks.before(cancelToken.cancel.bind(cancelToken));
            if (cancelToken.isCancelled === true) {
                return;
            }

            const query = this.queryHelper.buildQuery();

            this.dremioSdk
                .getData(query, this.offset, this.limit)
                .then((result) => {
                    this.result = result;
                    this.loadDataHooks.then(result);
                })
                .catch(this.loadDataHooks.catch)
                .finally(this.loadDataHooks.finally);
        },
        /**
         * Inits queryHelpher, injects dremio vars, reloads data
         */
        dremioHandler() {
            const { [DREMIO_CONFIG_DESCRIPTOR_PROPS_ACCESSOR]: dremio } = this.props;
            if (dremio == null) {
                this.result = null;
                return;
            }
            this.queryHelper = new Query(cloneDeep(dremio));
            this.setDremioVars();
            this.loadData();
        },
        /**
         * Injects dremio.query metrics/dimensions/fields in descriptor.vars
         */
        setDremioVars() {
            const dremioParams = this.getDremioQueryParamNames();

            this.dremioVars = this.dremioVars.reduce((varsAcc, name) => {
                if (dremioParams.includes(name)) {
                    varsAcc.push(name);
                    return varsAcc;
                }
                this.$delete(this.descriptor.vars, name);
                return varsAcc;
            }, []);

            dremioParams.forEach((name) => {
                const variable = { description: name };
                this.$set(this.descriptor.vars, name, variable);
                this.dremioVars.push(name);
            });
        },
        /**
         * Applies dremio filters
         *
         * @param {Record<string, any>} params   params to be injected
         * @return {boolean}
         */
        applyDremioFilters(params) {
            if (this.queryHelper == null) {
                return false;
            }

            let { query } = this.queryHelper;
            let anyFilterApplied = false;
            const dremioParams = this.getDremioQueryParamNames();

            Object.entries(params)
                .filter(([paramName]) => dremioParams.includes(paramName))
                .forEach(([paramName, paramValue]) => {
                    const { [Query.KEY.FILTERS]: queryFilters } = query;
                    const filter = this.createDremioFilter(paramName, paramValue);

                    if (
                        (paramValue == null || Query.validateFilter(filter) === false) &&
                        queryFilters.some((filters) =>
                            Object.keys(filters).some((filterName) => filterName === paramName)
                        )
                    ) {
                        query = Query.queryRemoveFilter(query, paramName);
                        anyFilterApplied = true;
                    }

                    if (paramValue != null) {
                        query = Query.queryInsertUpdateFilter(query, filter);
                        anyFilterApplied = true;
                    }
                });

            return anyFilterApplied;
        },
        /**
         * Creates a new dremio query filter
         *
         * @param {string} filterName                           metric/dimension/field name
         * @param {string|string[]} value                       filter value
         * @return {Filter}
         */
        createDremioFilter(filterName, value) {
            const isArray = Array.isArray(value);
            const filterValue = [value].flat();
            const isNull = filterValue.includes(null);
            const { FILTER_TYPE } = Query;
            // eslint-disable-next-line no-nested-ternary
            const filterType = isNull ? FILTER_TYPE.IS : isArray ? FILTER_TYPE.IN : FILTER_TYPE.EQ;

            return Query.createFilter({
                name: filterName,
                type: filterType,
                value: filterValue
            });
        },
        /**
         * Returns dremio query metric/dimension/field names
         *
         * @return {string[]}
         */
        getDremioQueryParamNames() {
            if (this.queryHelper == null) {
                return [];
            }

            const { query, dimensionList } = this.queryHelper;
            const metrics = Query.queryMetricNames(query);
            const dimensions = Object.keys(dimensionList);
            const fields = Query.queryFieldNames(query);
            return [...metrics, ...dimensions, ...fields];
        },
        /**
         * Store state watcher handler
         * @param {object} state
         */
        storeStateWatcher(state) {
            if (Object.keys(state).length === 0) {
                return;
            }
            this.$nextTick(() => {
                if (this.applyDremioFilters(state)) {
                    this.offset = 0;
                    this.loadData();
                }
            });
        },
        handleError(error) {
            this.super().handleError.call(this, error);
            /**
             * @todo вынести обработку ошибок в стратегию ErrorManager
             */
            if (error instanceof DremioPresentableError === false) {
                return;
            }
            if (this.isEditorMode === false) {
                return;
            }
            this.error = error;
        }
    }
};

export const useDremio = () => ({
    mixin
});

export { mixin };
