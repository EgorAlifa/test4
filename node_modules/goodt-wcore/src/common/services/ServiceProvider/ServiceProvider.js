import { CoreWarning } from '@goodt-wcore/errors';
import { ServiceContainer } from '../ServiceContainer';

/**
 * @typedef {object} ServiceSetupConfig
 * @property {symbol} id
 * @property {any} value
 * @property {symbol} lifetime
 * @property {symbol} type
 */
/**
 * @typedef {object} ServiceOptionsRecord
 * @property {string} id
 * @property {boolean} [merge]
 * @property {Record<string, any>} options
 */
/**
 * @typedef {object} ServiceSetupOptions
 * @property {ServiceSetupConfig[]} services
 */

export class ServiceProvider {
    /**
     * @type {ServiceContainer}
     */
    static container = ServiceContainer.create();

    /**
     * @type {Map<symbol, object>}
     */
    static meta = new Map();

    /**
     *
     * @param {?ServiceSetupConfig[]} [configs=ServiceSetupConfigs]
     * @return {typeof ServiceProvider}
     */
    static setup({ configs = [] } = {}) {
        configs.forEach(({ id, value, config, meta }) => {
            this.container.register(id, value, config);
            if (meta != null) {
                this.meta.set(id, meta);
            }
        });

        return this;
    }

    /**
     *
     * @param {ServiceOptionsRecord[]} serviceOptionsRecords
     * @param force
     * @return {typeof ServiceProvider}
     */
    static init(serviceOptionsRecords, { force = true } = {}) {
        serviceOptionsRecords.forEach(({ id, merge, options }) => {
            const serviceId = Symbol.for(id);
            if (force === false && this.container.has(serviceId)) {
                return;
            }
            try {
                this.container.setOptions(serviceId, options, merge);
            } catch (error) {
                window.requestIdleCallback(() => {
                    throw new CoreWarning(error.message, { reason: error });
                });
            }
        });

        return this;
    }

    /**
     * @param {string|symbol} serviceId
     * @param {Record<any, string>} [customOptions={}]
     * @return {any|null}
     */
    static get(serviceId, customOptions) {
        return this.container.get(serviceId, customOptions);
    }
}

/**
 *
 * @draft need to be reviewed
 * @param {ServiceContainer} container
 * @return {function(serviceId: Symbol): object}
 */
const wrapContainer = (container) => (serviceId) => {
    const context = {
        setOptions: (options, useMerge) => {
            container.setOptions(serviceId, options, useMerge);
            return context;
        },
        get: () => container.get(serviceId),
        withOptions: (options) => ({
            get: () => container.get(serviceId, options)
        })
    };

    return context;
};

ServiceProvider.use = function (serviceId) {
    return wrapContainer(this.container)(serviceId);
};
