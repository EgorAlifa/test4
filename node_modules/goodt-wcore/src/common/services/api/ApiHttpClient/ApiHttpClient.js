import { complement as isNot, isNil, both, isEmpty } from 'ramda';
import { SilentError } from '@goodt-wcore/errors';
import { HttpTransportError } from '@goodt-common/net';
import { ApiHttpClientError } from './errors/ApiClientError';
import { HttpTransportToApiClientErrorCodeMap } from './constants';

const HEADERS_WIDGET_UID = 'x-widget-uid';
/**
 * @typedef {import('@goodt-common/net').ITransport} ITransport
 * @typedef {import('./ApiHttpClient').TransportRequestCancel} TransportRequestCancel
 */

/**
 * @class ApiHttpClient
 */
class ApiHttpClient {
    /**
     * Transport client instance
     * @private
     * @member {ITransport}
     */
    _transport;

    /**
     * @param {ITransport} transport
     * @constructs ApiHttpClient
     */
    constructor(transport) {
        if (transport == null) {
            throw new ApiHttpClientError('Required `transport` instance is not provided', {
                code: ApiHttpClientError.Code.INTERNAL
            });
        }
        this._transport = transport;
    }

    /**
     *
     * @return {string}
     */
    get baseURL() {
        return this._transport.baseURL;
    }

    /**
     *
     * @param baseURL
     */
    set baseURL(baseURL) {
        this._transport.baseURL = baseURL;
    }

    /**
     * @public
     * @async
     * @method ApiHttpClient#request
     * @param {ITransportRequest} request
     *
     * @throw {ApiHttpClientError|Error}
     * @return {Promise<*>}
     */
    async request(request) {
        const requestConfig = this._buildTransportRequest(request);
        try {
            const response = await this._transport.request(requestConfig);
            return this._processTransportResponse(response);
        } catch (error) {
            const exception = this._processTransportError(error);
            throw exception;
        }
    }

    /**
     * return cancel function which could be used to cancel next transport request
     * @return {TransportRequestCancel}
     */
    getNextRequestCancel() {
        return this._transport.getNextRequestCancel();
    }

    dispose() {
        if (typeof this._transport.dispose === 'function') {
            this._transport.dispose();
        }
    }

    /**
     * Создаёт конфиг реквеста для совершения запроса транспортом ITransportRequest
     * Особенность: знает формат запроса к серверу, дополнительные HTTP заголовки
     *
     * @param {import('./ApiHttpClient').IApiClientRequest} request
     * @return {import('./ApiHttpClient').IApiClientRequest} 
     * @private
     */
    // eslint-disable-next-line class-methods-use-this
    _buildTransportRequest(request) {
        if (request == null || typeof request !== 'object') {
            throw new ApiHttpClientError('Invalid `request` method input argument type');
        }

        const { url, params, options: { context, ...options } = {} } = request;
        if (url === '' || url == null) {
            throw new ApiHttpClientError('Empty url or pathname');
        }

        const { method, ...resultTransportOptions } = this._buildTransportOptions(options, { context });

        return {
            url,
            method,
            ...(params && { params }),
            options: resultTransportOptions
        };
    }

    /**
     * Создаёт/дополняет объект опций для транспорта ITransportOptions
     *
     * @param {import('../types').ITransportOptions} transportOptions
     * @param {import('./ApiHttpClient').IClientRequestExtraOptions} [clientExtraOptions=null]
     * @return {ITransportOptions}
     */
    // eslint-disable-next-line class-methods-use-this
    _buildTransportOptions(transportOptions, clientExtraOptions = null) {
        const extraOptions = {};

        extraOptions.paramsSerializer = (params) => {
            const notEmptyParams = Object.fromEntries(
                Object.entries(params)
                    .map(([key, value]) => {
                        const withoutNilItems = [value].flat().filter(both(isNot(isNil), isNot(isEmpty)));
                        return [key, withoutNilItems];
                    })
                    .filter(([ , values ]) => values.length > 0)
            );

            return decodeURIComponent(new URLSearchParams(notEmptyParams).toString());
        };

        if (clientExtraOptions != null) {
            const {
                context: { elemId } = {}
            } = clientExtraOptions;
            if (elemId != null) {
                // eslint-disable-next-line no-param-reassign
                transportOptions.headers = {
                    ...transportOptions.headers,
                    [HEADERS_WIDGET_UID]: elemId
                };
            }
        }

        return {
            ...extraOptions,
            ...transportOptions
        };
    }

    /**
     * Обрабатывает ответа транспорта и возвращает целевые данные для HttpApiClient
     * Особенность: знает формат ответа сервера
     *
     * @param {ITransportResponse} transportResponse
     * @return {*}
     */
    // eslint-disable-next-line class-methods-use-this
    _processTransportResponse(transportResponse) {
        const { data } = transportResponse;
        return data;
    }

    /**
     * Обрабатывает ошибку от транспорта и трансформирует в инфраструктурную ошибку
     * Особенность: знает формат ошибки сервера, какие статус коды являются ошибочными
     *
     * @param {Error|null} reason
     * @return {ApiHttpClientError|SilentError}
     */
    _processTransportError(reason) {
        if (reason instanceof SilentError) {
            return reason;
        }
        const { message } = reason;
        if (reason instanceof HttpTransportError) {
            const { code: transportErrorCode } = reason;
            const code = HttpTransportToApiClientErrorCodeMap[transportErrorCode];
            return new ApiHttpClientError(message, {
                code,
                reason
            });
        }
        // Something happened in setting up the request that triggered an Error
        return new ApiHttpClientError(message, {
            reason
        });
    }
}

/**
 * Creates ApiHttpClient instance
 *
 * @param {ITransport} [transport] Transport client instance
 * @return {ApiHttpClient}
 */
const createApiHttpClient = (transport) => new ApiHttpClient(transport);

export { ApiHttpClient, createApiHttpClient };
