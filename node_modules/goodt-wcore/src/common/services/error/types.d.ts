import { ComponentOptions } from 'vue/types/options';
import { Console } from 'console';

export enum ErrorInfoTypeEnum {
    WidgetDebug = 'WidgetDebug', // goodt-wcore usage error
    CoreError = 'CoreError', // goodt-wcore usage error
    CoreWarning = 'CoreWarning', // goodt-wcore usage error
    DremioError = 'DremioError', // Dremio service usage error
    ApiServiceError = 'ApiServiceError', // Api service usage error
    InfrastructureError = 'InfrastructureError', // Generally Infrastructure error in Transport or Client
    ServerError = 'ServerError', // Transport error with 500 status code
    SilentError = 'SilentError' // SilentError should not be handled, used as signal or to represent
}

export type ErrorStrategy = (errorInfo: ErrorInfo) => ErrorInfo | null;

export type Subscriber<T = unknown> = (value: T) => any;

export function useErrorInfoSubscriber(options: { priority: number }): ComponentOptions;

export type ErrorInfoType = {
    error: Error;
    scope?: string;
    context?: any;
    type?: keyof typeof ErrorInfoTypeEnum;
    message?: string;
};

interface ILogger extends Console {}

export class ErrorInfoHandleStrategyAbstract {
    /**
     *
     * @type {Console | console}
     */
    logger: ILogger;

    /**
     *
     * @private
     * @return {ErrorInfo | null}
     * @param errorInfo
     */
    private _handler: (errorInfo: ErrorInfoType) => ErrorInfo;

    constructor({ handler }: { handler: Subscriber<ErrorInfo> });

    /**
     *
     * @param {ErrorInfo} errorInfo
     * @return {ErrorInfo} errorInfo
     */
    handle(errorInfo: ErrorInfo): ErrorInfo;
}

export class ErrorInfo {
    constructor({ error, scope, context, type }: ErrorInfoType);

    /**
     *
     * @type {string}
     */
    public error: Error;

    /**
     *
     * @type {string}
     */
    public scope: string | undefined;

    /**
     *
     * @type {*|null}
     */
    public context: object | undefined;

    /**
     *
     * @type {string}
     */
    public type: ErrorInfoType;
}

export class ErrorManager {
    static ErrorInfoType: ErrorInfoTypeEnum;

    private _subscribers: Map<(errorInfo: ErrorInfo) => void, { priority: number }>;

    private _hasPrioritySubscribers: Boolean = false;

    /**
     *
     * @private
     * @type {import('./types').ErrorStrategy}
     */
    private _errorHandleStrategy: ErrorStrategy;

    private _logger: ILogger = window.console;

    public static create(): ErrorManager;

    public static instance: ErrorManager;

    /**
     *
     * @param {import('./types').ErrorStrategy} strategy
     */
    setErrorHandleStrategy(strategy: ErrorStrategy);

    /**
     *
     * @param {{ error: (function(error: Error): void) }} logger
     */
    setLogger(logger: ILogger);

    /**
     *
     * @param error
     * @param context
     * @param scope
     * @return {import('./types').ErrorInfo}
     * @private
     */
    private _buildErrorInfo({ error, context, scope }): ErrorInfo;

    /**
     *
     * @param {ConstructorParameters<ErrorInfo>} errorInfo
     */
    handle({ error, context, scope }: ErrorInfoType): Promise<void>;

    /**
     *
     * @param {ErrorInfo} errorInfo
     */
    notify(errorInfo: ErrorInfo);

    /**
     *
     * @param {import('./types').Subscriber<import('./types').ErrorInfo>} newHandler
     * @param {Record<string, any>} options
     * @return {function(): boolean}
     */
    subscribe(newHandler: (errorInfo: ErrorInfo) => void, options: Record<string, any>): () => boolean;
}

export class ErrorService {
    static Scope: Record<string, string>;

    /**
     *
     * @type {{on(callback: () => any): {off(): void}, off(callback: () => any): void, trigger(param: any): void}}
     * @private
     */
    private _errorHook: EventHook;

    /**
     *
     * @type {[]}
     * @private
     */
    public _disposals: (() => void)[];

    /**
     * Constructor
     *
     * @param {symbol} theEnforcer singleton enforcer
     */
    constructor(theEnforcer: Symbol);

    /**
     * @return {ErrorService}
     */
    static instance: ErrorService;

    /**
     *
     * @param errorHandler
     * @return {*}
     */
    addHandler(errorHandler: () => void): void;

    /**
     * @private
     * @param {Error} error
     * @param {*} context
     * @param {string} scope
     */
    handleError({ error, context, scope }: ConstructorParameters<ErrorInfo>): void;

    /**
     * @param {import('./types').Subscriber<import('./types').ErrorInfoType>|function(): any} subscriber
     * @return {function(): void}
     */
    subscribe(subscriber: Subscriber): () => void;

    /**
     */
    dispose(): void;
}

export function throwGlobal(error: Error, { context }?: { context?: ObjectConstructor }): void;

export class ConsoleLogger extends Console {
    constructor(logger: ILogger, { isEnabled }: { isEnabled: () => boolean });

    errorAlways: (error: Error) => void;
}

export function createErrorInfoHandleStrategy({
    handler
}: {
    handler: (errorInfo: ErrorInfoType) => ErrorInfo;
}): ErrorInfoHandleStrategyAbstract;
