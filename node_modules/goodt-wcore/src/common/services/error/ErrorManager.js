import { ErrorInfoBuilder } from './ErrorInfoBuilder';
import { ErrorManagerException } from './ErrorManagerException';
import { ConsoleLogger, errorAlways } from './ConsoleLogger';

/**
 *
 */
const enforcer = Symbol('ErrorManager');

export class ErrorManager {
    static ErrorInfoType = ErrorInfoBuilder.ErrorInfoType;

    _subscribers = new Map();

    _hasPrioritySubscribers = false;

    /**
     *
     * @private
     * @type {import('./types').ErrorStrategy}
     */
    _errorHandleStrategy;

    _logger = new ConsoleLogger(window.console);

    /**
     * Constructor
     *
     * @param {symbol} theEnforcer singleton enforcer
     */
    constructor(theEnforcer) {
        if (theEnforcer !== enforcer) {
            throw new Error(`Instantiation failed: use ErrorService.instance`);
        }
    }

    /**
     *
     * @return {ErrorManager}
     */
    static create() {
        return new ErrorManager(enforcer);
    }

    /**
     * @return {ErrorManager}
     */
    static get instance() {
        if (this[enforcer] === undefined) {
            this[enforcer] = new this(enforcer);
        }
        return this[enforcer];
    }

    /**
     *
     * @param {import('./types').ErrorStrategy} strategy
     */
    setStrategy(strategy) {
        this._errorHandleStrategy = strategy;
        this._assignErrorHandleStrategyLogger();
    }

    /**
     *
     * @param {{ error: (function(error: Error): void) }} logger
     */
    setLogger(logger) {
        this._logger = logger;
        this._assignErrorHandleStrategyLogger();
    }

    /**
     *
     */
    _assignErrorHandleStrategyLogger() {
        // @todo back compatibility for editor/player
        if (this._logger.errorAlways == null) {
            this._logger.errorAlways = errorAlways;
        }
        if (this._errorHandleStrategy != null) {
            this._errorHandleStrategy.logger = this._logger;
        }
    }

    /**
     *
     * @param {Error} error
     * @param {any} context
     * @param {string} scope
     * @param {string} message
     * @return {import('./types').ErrorInfo}
     * @private
     */
    _buildErrorInfo({ error, context, scope, message }) {
        return ErrorInfoBuilder.build({ error, context, scope, message });
    }

    /**
     *
     * @param {import('./ErrorInfo').ErrorInfo} errorInfo
     */
    async handle({ error, context, scope, message }) {
        let errorInfo = this._buildErrorInfo({ error, context, scope, message });
        if (this._errorHandleStrategy != null) {
            /* externally defined strategy could fail */
            /* so catching possible exceptions */
            try {
                errorInfo = this._errorHandleStrategy.handle(errorInfo);
            } catch (exception) {
                /* do nothing if strategy fails */
                /* leave errorInfo without error handle strategy processing */
                /* only logging */
                const selfError = new ErrorManagerException('ErrorInfo handle strategy exception', {
                    reason: exception
                });
                this._logger.errorAlways(selfError);
            }
        }
        if (errorInfo != null) {
            this.notify(errorInfo);
        }
    }

    /**
     *
     * @param {ErrorInfo} errorInfo
     */
    notify(errorInfo) {
        this._subscribers.forEach((_, handler) => {
            /* externally subscribed handler could fail */
            /* so catching possible exceptions */
            try {
                handler(errorInfo);
            } catch (exception) {
                /* do nothing if handler call fails */
                /* only logging */
                const selfError = new ErrorManagerException('Error manager subscriber exception', {
                    reason: exception
                });
                this._logger.errorAlways(selfError);
            }
        });
    }

    /**
     *
     * @param {import('./types').Subscriber<import('./types').ErrorInfo>} newHandler
     * @param {{ priority: number }} [options]
     * @return {function(): boolean} un-subscribe function
     */
    subscribe(newHandler, options = { priority: -1 }) {
        if (options.priority < 0 && this._hasPrioritySubscribers) {
            return () => {};
        }
        this._subscribers.set(newHandler, options);
        if (options.priority > 0 && this._hasPrioritySubscribers === false) {
            this._subscribers.forEach(({ priority }, handler, map) => {
                if (priority < 0) {
                    map.delete(handler);
                }
            });
            this._hasPrioritySubscribers = true;
        }
        return () => this._subscribers.delete(newHandler);
    }
}
