import { merge } from 'lodash';
import { useFormElemOptions } from './const';

const UiErrors = {
    functional: true,
    render(h, { parent: { errors = [], isTouched } }) {
        if (!errors.length || !isTouched) {
            return null;
        }
        const content = errors.map((e) => h('div', [e]));
        return h(
            'div',
            { class: 'alert alert-error text-xsmall pos-abs pad-3', style: { 'max-width': '100%', 'z-index': 1 } },
            content
        );
    }
};

/**
 * Form element mixin, used for form element widgets
 * A form element is: 'user-input' widget (input,select,checkbox etc)
 * @depends useFormElemDescriptor()
 * @strat form-element
 */
export const useFormElem = () => ({
    components: { UiErrors },
    inject: {
        [useFormElemOptions.inject.FORM]: {
            default: null
        }
    },
    data: () => ({
        /** @type {FormModelFieldOption[]?} */
        options: []
    }),
    computed: {
        /**
         * @return {Form}
         */
        form() {
            return this[useFormElemOptions.inject.FORM];
        },
        /**
         * @return {string?}
         */
        field() {
            return this.props[useFormElemOptions.props.FIELD] ?? null;
        },
        /**
         * @return {string[]}
         */
        fieldNames() {
            const { form } = this;
            return Object.keys(form?.context?.schema ?? {});
        },
        /** @return {FormModelFieldSchema?} */
        schema() {
            const { field, form } = this;
            if (field == null || form == null) {
                return null;
            }
            return form.context.schema?.[field];
        },
        /**
         * @return {FormModelFieldValidation}
         */
        validation() {
            const { field, form } = this;
            if (field == null || form == null) {
                return null;
            }
            return form.context.validation?.[field] ?? null;
        },
        value: {
            /**
             * @return {any}
             */
            get() {
                const { field, form } = this;
                if (field == null || form == null) {
                    return null;
                }
                return form.context.model?.[field];
            },
            /**
             * @param {any} val
             */
            set(val) {
                const { field, form, isDisabled, isReadOnly } = this;
                if (field == null || form == null || isDisabled || isReadOnly) {
                    return;
                }
                form.setValue(field, val);
            }
        },
        /**
         * @return {boolean}
         */
        isFormLoading() {
            const { form } = this;
            if (form == null) {
                return false;
            }
            return form.context.isLoading;
        },
        /**
         * @return {boolean}
         */
        hasFormErrors() {
            const { form } = this;
            if (form == null) {
                return false;
            }
            return form.context.hasErrors;
        },
        /**
         * @return {boolean}
         */
        hasErrors() {
            return this.errors.length > 0;
        },
        /**
         * @return {boolean}
         */
        isTouched() {
            const { validation } = this;
            if (validation == null) {
                return false;
            }
            return validation.touched ?? false;
        },
        /**
         * @return {boolean}
         */
        isMultiple() {
            const { schema } = this;
            if (schema == null) {
                return false;
            }
            return schema.isMultiple;
        },
        /**
         * @return {boolean}
         */
        isRequired() {
            const { schema } = this;
            if (schema == null) {
                return false;
            }
            return schema.isRequired;
        },
        /**
         * @return {boolean}
         */
        isReadOnly() {
            const { [useFormElemOptions.props.READONLY]: isReadOnly } = this.props;
            const { schema } = this;
            if (schema == null) {
                return isReadOnly;
            }
            // schema may force 'readonly' state
            return isReadOnly || schema.isReadOnly;
        },
        /**
         * @return {boolean}
         */
        isDisabled() {
            const { [useFormElemOptions.props.DISABLED]: isDisabled } = this.props;
            return isDisabled;
        },
        /**
         * @return {array}
         */
        errors() {
            const { validation } = this;
            if (validation == null) {
                return [];
            }
            return validation.errors ?? [];
        }
    },
    watch: {
        field: {
            handler(val, valOld) {
                const { form } = this;
                if (!form) {
                    return;
                }
                if (valOld) {
                    form.setValidators(valOld, []);
                }
                if (val) {
                    form.setValidators(val, this.getValidators());
                }
            },
            immediate: true
        },
        schema: {
            async handler(schema) {
                if (schema == null) {
                    return;
                }
                const { options } = schema;
                this.options = options ? await options() : [];
            },
            immediate: true
        }
    },
    methods: {
        /**
         * Returns validators, which are piped while validating value
         * @return {((val:any) => string?)[]}
         */
        getValidators() {
            return [];
        }
    }
});

/**
 * Form-elem descriptor factory
 * @param {() => object} descriptor         custom descriptor factory to merge with
 * @return {() => object}
 */
export const useFormElemDescriptor = (descriptor) => () =>
    merge(
        {
            props: {
                [useFormElemOptions.props.DISABLED]: {
                    type: Boolean,
                    default: false,
                    label: 'disabled'
                },
                [useFormElemOptions.props.READONLY]: {
                    type: Boolean,
                    default: false,
                    label: 'read-only'
                },
                [useFormElemOptions.props.FIELD]: {
                    type: String,
                    default: null,
                    label: 'Поле'
                }
            }
        },
        descriptor()
    );

/**
 * Form elem panel factory
 * @return {() => () => Promise.<import('vue').AsyncComponent>}
 */
export const useFormElemPanel = () => () => import('../panels/FormElemPanel.vue');
