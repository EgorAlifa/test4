import { store, ValueObject } from '@goodt-wcore/managers';
import { useNavigate } from '@goodt-wcore/utils';
import { merge, isEqual, cloneDeep } from 'lodash';
import { useFormOptions, formModelFieldValidationFactory } from './const';

const { navigate } = useNavigate();
/**
 * Form mixin, used for form-container widget
 * @strat form
 */
export const useForm = () => ({
    provide() {
        const {
            context,
            setModelValue: setValue,
            setModelErrors: setErrors,
            setModelValidators: setValidators,
            submit,
            cancel,
            reset
        } = this;
        /** @type {import('./form').Form} */
        const form = { context, setValue, setErrors, setValidators, submit, cancel, reset };
        return { [useFormOptions.provide.FORM]: form };
    },
    validators: {
        isRequired(val) {
            const hasError = val == null || val == '';
            return hasError ? 'field is required' : null;
        }
    },
    data: (vm) => ({
        /**
         * Original immutable model should stay outside the 'context'
         * @type {object}
         */
        modelOrigin: null,
        /** @type {import('./form').FormContext} */
        context: {
            /** @type {object} */
            model: null,
            schema: null,
            validation: null,
            isLoading: false,
            isResetAvailable: false,
            isSubmitAvailable: false,
            hasErrors: false
        },
        validators: {},
        /**
         * @tobe implemented
         * @type {boolean}
         */
        isCreateAction: true,
        modelId: null
    }),
    computed: {
        /**
         * @returns {boolean}
         */
        isReady() {
            const { schema, validation } = this.context;
            return schema != null && validation != null;
        },
        /**
         * @returns {boolean}
         */
        isLoading: {
            get() {
                return this.context.isLoading;
            },
            set(val) {
                this.context.isLoading = val;
            }
        },
        /**
         * @returns {boolean}
         */
        isResetAvailable: {
            get() {
                return this.context.isResetAvailable;
            },
            set(val) {
                this.context.isResetAvailable = val;
            }
        },
        /**
         * @returns {boolean}
         */
        isSubmitAvailable() {
            const {
                hasErrors,
                context: { model }
            } = this;
            return !hasErrors && model != null && Object.keys(model).length > 0;
        },
        /**
         * @returns {boolean}
         */
        hasErrors() {
            const { validation } = this.context;
            if (!validation) {
                return false;
            }
            return Object.values(validation).some(({ errors }) => errors.length > 0);
        },
        /**
         * @returns {object}
         */
        modelDefaults() {
            /** @type {Object.<string, import('./form').DescriptorFieldValue>} */
            const fields = this.props[useFormOptions.props.FIELDS];
            return Object.entries(fields).reduce((acc, [key, { value, type }]) => {
                const valueFinal = type === FieldValueType.VALUE ? value : ValueObject.getValue(store.state[value]);
                return { ...acc, [key]: valueFinal };
            }, {});
        }
    },
    watch: {
        hasErrors(val) {
            this.context.hasErrors = val;
        },
        isSubmitAvailable(val) {
            this.context.isSubmitAvailable = val;
        },
        modelDefaults: {
            handler(val) {
                const { model } = this.context;
                const { modelOrigin } = this;

                if (val != null && model != null) {
                    Object.assign(model, val);
                    Object.assign(modelOrigin, val);
                }
            }
        }
    },
    watchStore: [
        {
            vars: [useFormOptions.vars.MODEL_ID],
            handler([modelId]) {
                // prevent 2nd load after `mount`
                if (modelId === this.modelId) {
                    return;
                }
                this.resolveCreateMode();
                // only if mounted
                if (this.$el == null) {
                    return;
                }
                this.load();
            }
        }
    ],
    mounted() {
        this.resolveCreateMode();
        this.load();
    },
    methods: {
        /**
         *
         * @return {{modelId: useForm.methods.modelId, isCreateAction: useForm.methods.isCreateAction}}
         */
        resolveCreateMode() {
            this.modelId = this.$storeState[useFormOptions.vars.MODEL_ID];
            this.isCreateAction = this.modelId == null;
        },
        /**
         * Fetches the model schema
         * @async
         * @return {Promise.<Object.<string, import('./form').FormModelFieldSchema>>}
         */
        fetchSchema() {
            return Promise.resolve(null);
        },
        /**
         * Fetches the model
         * @async
         * @param {string} modelId
         * @return {Promise.<object?>}
         */
        fetchModel(modelId) {
            return Promise.resolve({});
        },
        /**
         * Create/update new model
         * @async
         * @param {object} model
         * @return {Promise.<object?>}
         */
        saveModel(model) {
            return Promise.resolve(model);
        },
        /**
         * Create a new model
         * @return {object}
         */
        createModel() {
            const { schema } = this.context;
            return Object.keys(schema).reduce((acc, field) => ({ ...acc, [field]: null }), {});
        },
        /**
         * Validates the model before submit
         * @tobe implemented
         * @param {object} model
         */
        async validateModel(model) {},
        /**
         * @param {string} field
         * @return {string[]}
         */
        validateModelField(field) {
            const { model, schema, validation } = this.context;
            if (!model || !schema || !validation || model[field] === undefined || schema[field] === undefined) {
                return [];
            }
            const { isRequired } = schema[field];
            const { validators = [] } = validation[field];
            const fieldValidators = [...validators];
            if (isRequired) {
                fieldValidators.unshift(this.$options.validators.isRequired);
            }
            return fieldValidators.map((fn) => fn(model[field])).filter((item) => item != null);
        },
        /**
         * @effect context.model, context.validation
         * @param {string} field
         * @param {any} value
         */
        setModelValue(field, value) {
            const { model, schema, validation } = this.context;
            if (!model || model[field] === undefined || !schema || schema[field] === undefined || !validation) {
                return;
            }
            const { isReadOnly, isRequired } = schema[field];
            if (isReadOnly) {
                return;
            }
            const hasValueChanged = !isEqual(model[field], value);
            model[field] = value;
            validation[field].touched = true;
            validation[field].errors = this.validateModelField(field);
            if (hasValueChanged) {
                this.isResetAvailable = true;
            }
        },
        /**
         * @effect context.validation
         * @param {string} field
         * @param {array} errors
         */
        setModelErrors(field, errors) {
            const { validation } = this.context;
            if (!validation) {
                return;
            }
            const fieldValidation = validation[field];
            if (fieldValidation) {
                fieldValidation.errors = errors;
            }
        },
        /**
         * @effect context.validation
         * @param {string} field
         * @param {import('./form').FieldValidator[]} validators
         */
        setModelValidators(field, validators) {
            const { validation } = this.context;
            this.validators[field] = validators ?? [];

            if (!validation || !validation[field]) {
                return;
            }
            validation[field].validators = validators ?? [];
        },
        /**
         * @effect context.model, modelOrigin
         * @param {object} model
         */
        setModel(model) {
            const { context, modelDefaults } = this;
            const { schema, validation } = context;
            // sync model with schema
            const modelSynced = Object.entries(model).reduce((acc, [key, val]) => {
                if (schema == null || schema[key] == null) {
                    return acc;
                }
                return { ...acc, [key]: val };
            }, {});
            Object.assign(modelSynced, modelDefaults);
            context.model = cloneDeep(modelSynced);
            this.isResetAvailable = false;
            this.modelOrigin = modelSynced;
            //
            Object.keys(schema).forEach((field) => {
                if (!validation[field]) {
                    return;
                }
                const fieldValidation = validation[field];
                fieldValidation.touched = false;
                fieldValidation.errors = this.validateModelField(field);
            });
        },
        /**
         * @effect context.schema, context.validation
         * @param {object} schema
         */
        setSchema(schema) {
            const { validators } = this;
            const { context } = this;
            context.schema = schema;
            context.validation = Object.keys(schema).reduce(
                (acc, field) => ({
                    ...acc,
                    [field]: formModelFieldValidationFactory({ validators: validators?.[field] ?? [] })
                }),
                {}
            );
        },
        /**
         * Fetches the model/schema
         * @effect {context}, {modelOrigin}
         */
        async load() {
            this.isLoading = true;
            try {
                // fetch schema
                const schema = await this.fetchSchema();
                this.setSchema(schema ?? {});
                const model = this.isCreateAction ? this.createModel() : await this.fetchModel(this.modelId);
                this.setModel(model ?? {});
            } finally {
                this.isLoading = false;
            }
        },
        /**
         * Submit handler
         */
        async submit(e) {
            const {
                context: { model }
            } = this;
            // fields validation failed
            if (this.hasErrors) {
                return;
            }
            // custom form validation
            this.isLoading = true;
            await this.validateModel(model);
            this.isLoading = false;
            // custom form validation failed
            if (this.hasErrors) {
                return;
            }
            try {
                const modelNew = await this.saveModel(model);
                // re-set the mutable/immutable models
                this.setModel(modelNew);
                await this.postSubmit();
                this.onSubmitSuccess();
            } finally {
                this.isLoading = false;
            }
        },
        postSubmit() {
            [this.postSubmitApplyStoreFilters, this.postSubmitTriggerEvent, this.postSubmitNavigateUrl].forEach(
                (handler) => handler.call(this)
            );
        },
        /**
         * @tobe implemented
         */
        onSubmitSuccess() {},
        /**
         * Resets the model to origin model
         */
        reset() {
            const { modelOrigin } = this;
            this.setModel(modelOrigin);
        },
        /**
         * Cancel action
         */
        cancel() {
            // @tobe implemented
        },
        /**
         * @private
         * Applies store filters
         */
        postSubmitApplyStoreFilters() {
            const { [useFormOptions.props.STORE_FILTERS]: filters } = this.props;
            if (filters.length > 0) {
                const statePartial = filters.reduce(
                    (acc, { key, value }) => ({ ...acc, [key]: new ValueObject(value, store.state[key]?.meta) }),
                    {}
                );
                store.commit(statePartial, { context: this });
            }
        },
        /**
         * @private
         * Triggers custom event
         */
        postSubmitTriggerEvent() {
            const { [useFormOptions.props.EVENT]: event } = this.props;
            if (event) {
                this.$eventTrigger(event);
            }
        },
        /**
         * @private
         * Navigates to a spec. route
         */
        postSubmitNavigateUrl() {
            const { [useFormOptions.props.URL]: url, [useFormOptions.props.ROUTE]: route } = this.props;
            if (url !== '' || route !== '') {
                navigate({ url, route });
            }
        }
    }
});

const FieldValueType = { VALUE: 0, STORE_KEY: 1 };

/**
 * Form descriptor factory
 * @param {() => object} descriptor   custom descriptor factory to merge with
 * @return {() => object}
 */
export const useFormDescriptor = (descriptor) => () =>
    merge(
        {
            props: {
                [useFormOptions.props.URL]: {
                    type: String,
                    default: '',
                    label: 'URL для перехода'
                },
                [useFormOptions.props.ROUTE]: {
                    type: String,
                    default: '',
                    label: 'Роут для перехода'
                },
                [useFormOptions.props.EVENT]: {
                    type: String,
                    default: '',
                    label: 'Событие для отправки'
                },
                [useFormOptions.props.STORE_FILTERS]: {
                    type: Object,
                    default() {
                        return [];
                    },
                    label: 'Фильтрация state',
                    /** @return {import('./form').StoreFilterItem} */
                    factory: () => ({ key: '', value: '' })
                },
                [useFormOptions.props.FIELDS]: {
                    type: Object,
                    default: () => ({}),
                    label: 'Поля',
                    valueType: FieldValueType,
                    valueTypeOptions: Object.entries(FieldValueType).map(([label, value]) => ({ label, value })),
                    /** @return {import('./form').DescriptorFieldValue} */
                    valueFactory: () => ({ value: '', type: FieldValueType.VALUE }),
                    hasConst: true
                }
            },
            vars: Object.values(useFormOptions.vars).reduce(
                (acc, varName) => ({ ...acc, [varName]: { description: varName } }),
                {}
            )
        },
        descriptor()
    );

/**
 * Form panel factory
 * @return {() => () => Promise.<import('vue').AsyncComponent>}
 */
export const useFormPanel = () => () => import('../panels/FormPanel.vue');
