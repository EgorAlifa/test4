import { Url, base64Decode } from '@goodt-common/utils';
import { AuthAdapterError } from '@goodt-wcore/managers';
import Adapter from '../Adapter';
import { AdapterLoginStrategyType, AdapterLogoutStrategyType } from '../../const';
import { isPostMessageInitRequired, promisifyAuthCredentialsRequest } from './utils/iframe';
import { cookieExtractTokenInfo } from './utils/cookie';
import { useAuthService } from './utils/service';

/**
 * @typedef {import('./utils/service').AuthService} AuthService
 * @typedef {import('./utils/service').TokenResponse} TokenResponse
 * @typedef {import('./utils/service').UserProfileWithAttributes} UserProfileWithAttributes
 * @typedef {import('../../const').IAdapterLoginStrategy} IAdapterLoginStrategy
 * @typedef {import('../../const').IAdapterLogoutStrategy} IAdapterLogoutStrategy
 * @typedef {import('./Keycloak').Session} Session
 * @typedef {import('./Keycloak').KeycloakConfig} KeycloakConfig
 * @typedef {import('./Keycloak').KeycloakConfigCookies} KeycloakConfigCookies
 * @typedef {import('./Keycloak').KeycloakConfigCustomUrl} KeycloakConfigCustomUrl
 */

/** @type {KeycloakConfig} */
const CONFIG_DEFAULT = {
    url: '',
    realm: '',
    clientId: '',
    flow: 'rop',
    scope: 'openid profile email',
    cookies: {
        init: false,
        tokenKey: 'KEYCLOAK_IDENTITY',
        refreshTokenKey: 'KEYCLOAK_REFRESH'
    },
    customUrl: {
        login: null,
        logout: null
    },
    postMessageInit: false
};

class Keycloak extends Adapter {
    /** @type {Promise} */
    initPromise;

    /** @type {KeycloakConfig} */
    config;

    /** @type {Session | null} */
    session = null;

    /** @type {AuthService} */
    service = null;

    /** @type {UserProfileWithAttributes | null} */
    profileCache = null;

    /**
     * @type {boolean}
     * @private
     */
    isPostMessageInit = false;

    /**
     * Constructor
     * @param {KeycloakConfig?} config
     */
    constructor(config = {}) {
        const instanceConfig = { ...CONFIG_DEFAULT, ...config };
        super(instanceConfig);

        this.config = instanceConfig;
        this.service = useAuthService(this.config);
        this.isPostMessageInit = isPostMessageInitRequired(instanceConfig.postMessageInit);
        this.initPromise = null;
    }

    /**
     * Init adapter
     * @return {Promise<boolean>}
     */
    async init() {
        if (this.initPromise != null) {
            return this.initPromise;
        }

        /** @type {{ cookies:KeycloakConfigCookies }} */
        const { cookies: cookiesConfig } = this.config;
        /** @type {{ token: string, refreshToken: string } | null} */
        let tokenInfo = null;

        // post-message: try to retrieve via postmessage
        if (this.isPostMessageInit) {
            tokenInfo = await promisifyAuthCredentialsRequest(keycloakInstanceInit);
        }
        // cookie: try to retrieve via cookies
        else if (cookiesConfig?.init ?? false) {
            tokenInfo = cookieExtractTokenInfo(cookiesConfig);
        }

        this.initPromise = new Promise(async (resolve) => {
            const { flow } = this.config;

            // mb we got a code flow ie we are redirected from oath service
            if (flow === 'code' || flow === 'code-pkce') {
                const { code, error, error_description, redirectUrl } = this.service.getCodeStateFromUrl(location.href);

                this.profileCache = null;

                // restore the url ie remove oauth callback params
                if (redirectUrl != null) {
                    history.replaceState(null, '', redirectUrl);
                }

                // ok?
                if (code != null) {
                    try {
                        const result = await this.service.loginCode({ pkce: flow === 'code-pkce', code });
                        this.setSession(result);
                        resolve(true);
                    } catch (error) {
                        console.warn(`auth.adapter.init failed:`, error);
                        resolve(false);
                    }
                    return;
                }
                // smth went wrong on the auth service
                if (error != null || error_description != null) {
                    const decodeUriStr = (s) => decodeURIComponent(s.replace(/\+/g, '%20'));
                    // save last auth service errror
                    const errMsg = [error, error_description, '(probably your are using wrong "flow")']
                        .filter((s) => s != null)
                        .map(decodeUriStr)
                        .join(' ');
                    const errInst = new Error(errMsg);
                    errInst.name = 'OAuthCodeFlow';
                    // we need to throw here or we'll get into redirect recursion
                    // init() -> login() -> redirect with error -> init() -> login() ...
                    throw errInst;
                }
            }

            // try to restore session implicitly via cookie or explicitly via tokenInfo
            try {
                const result = await this.service.token(tokenInfo?.refreshToken);
                this.setSession(result);
                resolve(true);
            } catch (error) {
                console.warn(`auth.adapter.init failed:`, error);
                resolve(false);
            }
        });

        return this.initPromise;
    }

    /**
     * @return {Promise<IAdapterLoginStrategy>}
     */
    async getLoginStrategy() {
        const { customUrl, flow } = this.config;
        const redirectUrl = window.location.href;

        if (customUrl?.login != null) {
            const uri = Url.create(customUrl.login);
            uri.query = { ...uri.query, redirect: redirectUrl };

            return { type: AdapterLoginStrategyType.REDIRECT, options: { url: uri.toString() } };
        }
        if (flow === 'code' || flow === 'code-pkce') {
            const uri = await this.service.getLoginUrl({ pkce: flow === 'code-pkce', redirectUrl });

            return { type: AdapterLoginStrategyType.REDIRECT, options: { url: uri.toString() } };
        }

        return { type: AdapterLoginStrategyType.CREDENTIALS };
    }

    /**
     * @return {Promise<IAdapterLoginStrategy>}
     */
    async getLogoutStrategy() {
        const { customUrl } = this.config;

        if (customUrl?.logout != null) {
            const url = Url.create(customUrl.logout);
            url.query = { ...url.query, redirect: window.location.href };

            return { type: AdapterLogoutStrategyType.REDIRECT, options: { url: url.toString() } };
        }

        return { type: AdapterLogoutStrategyType.CREDENTIALS };
    }

    /**
     * Login method
     * @param {{ username:string, password:string }} credentials
     * @return {Promise<void>}
     */
    async login({ username, password }) {
        const { customUrl } = this.config;

        // return silently as strategy is 'redirect'
        if (customUrl?.login != null) {
            return;
        }

        try {
            this.profileCache = null;
            const result = await this.service.login({ username, password });
            this.setSession(result);
            return;
        } catch (error) {
            throw error;
        }
    }

    /**
     * Logout method
     * @return {Promise<void>}
     */
    async logout() {
        /** @type {{ customUrl:KeycloakConfigCustomUrl }} */
        const { customUrl } = this.config;
        const { session } = this;

        // return silently as strategy is 'redirect'
        if (customUrl?.logout != null) {
            return;
        }
        if (session == null) {
            return;
        }

        try {
            this.profileCache = null;
            await this.service.logout(session.idToken);
            this.setSession();
            return;
        } catch (error) {
            throw error;
        }
    }

    /**
     * If the token expires within minValidity seconds the token is refreshed.
     * @param {number} [minValidity=5]
     * @return {Promise<boolean>}  Promise; resolve(refreshed) if token is valid/update; reject() if session expired
     */
    async updateToken(minValidity = 5) {
        const isExpired = this.isTokenExpired(minValidity);

        if (isExpired) {
            try {
                const result = await this.service.token();
                this.setSession(result);
                return true;
            } catch (error) {
                throw error;
            }
        }

        return true;
    }

    /**
     * Returns user profile (depends on the adapter)
     * @return {Promise.<object>}   Promise; resolve(profile); resolve({}) on error
     */
    async getUserProfile() {
        const { session, profileCache } = this;

        if (session == null) {
            return {};
        }

        // token ok -> use cache if possible
        if (this.isTokenExpired() === false && profileCache) {
            return profileCache;
        }
        try {
            await this.updateToken();
            this.profileCache = await this.service.profile(this.token);
            return this.profileCache;
        } catch (error) {
            return {};
        }
    }

    /**
     * Returns true if the token has less than minValidity seconds left before it expires (minValidity is optional, if not specified 0 is used).
     * @param {number} [minValidity=5]
     * @return {boolean}
     */
    isTokenExpired(minValidity = 5) {
        const { tokenParsed } = this;
        const now = (new Date() / 1000) | 0;
        return tokenParsed ? tokenParsed.exp - now - minValidity <= 0 : true;
    }

    /**
     * @param {TokenResponse?} [tokenResponse=null]
     */
    setSession(tokenResponse = null) {
        this.session = tokenResponse ? { token: tokenResponse.access_token, idToken: tokenResponse.id_token } : null;
    }

    /**
     * Return auth status
     * @return {boolean}
     */
    get authenticated() {
        return this.session != null;
    }

    /**
     * Return token
     * @return {string}
     */
    get token() {
        return this.session?.token ?? '';
    }

    /**
     * Return parsed token
     * @return {?import('./utils/jwt').JwtPayload}
     */
    get tokenParsed() {
        const { token } = this;
        const tokenParts = token.split('.');
        if (token === '' || tokenParts.length !== 3) {
            return null;
        }
        try {
            const [_, payload] = tokenParts;
            const jwt = JSON.parse(base64Decode(payload));
            return jwt;
        } catch (error) {
            throw new AuthAdapterError('Keycloak adapter: token parse failed', {
                reason: error,
                code: 0
            });
        }
    }

    /**
     * Returns default config
     * @return {Record<string, any>}
     */
    // eslint-disable-next-line class-methods-use-this
    get configDefault() {
        return { ...CONFIG_DEFAULT };
    }
}

export default Keycloak;
