import { createUserProfileWithAttributes } from './jwt';

/**
 * @typedef {import('./jwt').UserProfileWithAttributes} UserProfileWithAttributes
 * @typedef {{ state:string, verifier:string, redirectUrl:string }} CodeInfo
 * @typedef {{ code:string|null, error:string|null, error_description:string|null, redirectUrl:string|null }} CodeUrlState
 * @typedef {{ access_token: string, id_token: string }} TokenResponse
 *
 * @typedef {object} AuthService
 * @property {({ username: string, password: string }) => Promise<TokenResponse>} login
 * @property {({ pkce: boolean, code: string, scope: string }) => Promise<TokenResponse>} loginCode
 * @property {(idToken: string) => Promise} logout
 * @property {(refreshToken?: string) => Promise<TokenResponse>} token
 * @property {(token: string) => Promise<UserProfileWithAttributes>} profile
 * @property {(url: string) => CodeUrlState} getCodeStateFromUrl
 * @property {({ pkce:boolean, redirectUrl:string, scope:string }) => Promise<string>} getLoginUrl
 */

/**
 * @param {{ url:string, clientId:string, realm:string, scope:string }} options
 * @return {AuthService}
 */
export const useAuthService = ({ url, clientId, realm, scope }) => {
    const CODE_INFO_LS_KEY = 'auth-code-flow';
    /**
     * @return {CodeInfo|null}
     */
    const getCodeInfo = () => {
        const val = localStorage.getItem(CODE_INFO_LS_KEY);
        if (!val) {
            return null;
        }
        try {
            return JSON.parse(val);
        } catch (e) {
            return null;
        }
    };

    /**
     * @param {CodeInfo|null} val
     */
    const setCodeInfo = (val = null) => {
        if (val == null) {
            localStorage.removeItem(CODE_INFO_LS_KEY);
            return;
        }
        localStorage.setItem(CODE_INFO_LS_KEY, JSON.stringify(val));
    };

    /**
     * @param {string} s
     */
    const sha256 = async (s) => await crypto.subtle.digest({ name: 'SHA-256' }, new TextEncoder().encode(s));

    /**
     * @param {Uint8Array<ArrayBuffer>} bytes
     */
    const bytesToBase64 = (bytes) => btoa(String.fromCodePoint(...bytes));

    /**
     * @param {string} codeVerifier
     */
    const generatePkceChallenge = async (codeVerifier) => {
        // hash codeVerifier, then encode as url-safe base64 without padding
        const hashBytes = new Uint8Array(await sha256(codeVerifier));
        const encodedHash = bytesToBase64(hashBytes).replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g, '');
        return encodedHash;
    };

    /**
     * @param {number} len
     * @return {string}
     */
    const generateCodeVerifier = (len) => {
        const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        const data = crypto.getRandomValues(new Uint8Array(len));
        const chars = new Array(len).fill(0).map((_, index) => alphabet.charCodeAt(data[index] % alphabet.length));
        return String.fromCharCode.apply(null, chars);
    };

    /**
     * @param {object} obj
     * @return {string}
     */
    const encodeQuery = (obj) =>
        Object.entries(obj)
            .reduce((acc, [key, val]) => {
                val != null && acc.append(key, val);
                return acc;
            }, new URLSearchParams())
            .toString();
    /**
     * @return {object}
     */
    const encodeHeaders = () => ({ 'Content-Type': 'application/x-www-form-urlencoded' });

    /**
     * @param {object} obj
     * @return {string}
     */
    const encodeBody = (obj) =>
        Object.entries(obj)
            .reduce((acc, [key, val]) => {
                val != null && acc.append(key, val);
                return acc;
            }, new URLSearchParams())
            .toString();

    /**
     * @param {{ error:string, description:string, status:number }} options
     * @return {Error}
     */
    const createException = ({ error, description, status }) => {
        const exception = new Error(`${description}`);
        exception.reason = {
            status,
            error,
            error_description: description
        };
        return exception;
    };

    /**
     * @param {RequestInit} requestInit
     * @param {{ action:string, query?:object, handler?: (r:Response) => Promise }} options
     * @return {Promise}
     */
    const request = async (requestInit, options) => {
        const { action, query = null, handler } = options;
        const requestUrl = new URL(`./${action}`, url);
        if (query != null) {
            requestUrl.search = encodeQuery(query);
        }
        const response = await fetch(requestUrl, requestInit);

        if (response.status >= 200 && response.status < 300) {
            return await handler(response);
        }
        const { error, error_description: description } = await response.json();
        throw createException({ error, description, status: response.status });
    };

    /**
     * @param {{ pkce:boolean, redirectUrl:string }} options
     * @returns
     */
    const getLoginUrl = async ({ pkce, redirectUrl }) => {
        const uri = new URL(`./auth/authorize/${realm}`, url);
        const query = {
            client_id: clientId,
            scope,
            response_mode: 'fragment',
            response_type: 'code',
            redirect_uri: redirectUrl,
            state: generateCodeVerifier(64)
        };
        const verifier = generateCodeVerifier(96);
        setCodeInfo({ state: query.state, verifier, redirectUrl });

        if (pkce) {
            query.code_challenge = await generatePkceChallenge(verifier);
            query.code_challenge_method = 'S256';
        }

        uri.search = encodeQuery(query);
        return uri.toString();
    };

    /**
     * @param {{ pkce:boolean, code:string }} options
     * @return {Promise<TokenResponse>}
     */
    const loginCode = ({ pkce, code }) => {
        const info = getCodeInfo();
        if (info == null) {
            throw createException({ error: 'code-flow', description: 'Failed to get code info', code: 400 });
        }

        const body = encodeBody({
            grant_type: 'authorization_code',
            client_id: clientId,
            code,
            code_verifier: pkce ? info.verifier : undefined,
            redirect_uri: info.redirectUrl,
            state: info.state,
            scope
        });
        const headers = encodeHeaders();
        setCodeInfo();

        return request(
            { method: 'POST', body, headers, credentials: 'include' },
            { action: `auth/token/${realm}`, handler: (r) => r.json() }
        );
    };

    /**
     * @param {{ username:string, password:string }} options
     * @return {Promise<TokenResponse>}
     */
    const login = ({ username, password }) => {
        const body = encodeBody({
            grant_type: 'password',
            scope,
            client_id: clientId,
            realm,
            username,
            password
        });
        const headers = encodeHeaders();
        return request(
            { method: 'POST', body, headers, credentials: 'include' },
            { action: `auth/token/${realm}`, handler: (r) => r.json() }
        );
    };

    /**
     * @param {string} idToken
     * @return {Promise}
     */
    const logout = (idToken) =>
        request(
            { method: 'GET' },
            {
                action: `auth/logout/${realm}`,
                query: { client_id: clientId, realm, id_token_hint: idToken },
                handler: (r) => r.text()
            }
        );

    /**
     * @param {string?} refreshToken
     * @return {Promise<TokenResponse>}
     */
    const token = (refreshToken) => {
        const body = encodeBody({
            grant_type: 'refresh_token',
            client_id: clientId,
            realm,
            refresh_token: refreshToken
        });
        const headers = encodeHeaders();
        return request(
            { method: 'POST', body, headers, credentials: 'include' },
            { action: `auth/token/${realm}`, handler: (r) => r.json() }
        ).catch(() => {
            throw createException({ error: 'unauthorized', description: 'unauthorized', status: 401 });
        });
    };

    /**
     * @param {string} token
     * @return {Promise<import('./utils/jwt').UserProfileWithAttributes>}
     */
    const profile = async (token) => {
        try {
            const profile = await request(
                { method: 'GET', headers: { Authorization: `Bearer ${token}` } },
                { action: `auth/userinfo/${realm}`, query: { realm }, handler: (r) => r.json() }
            );
            return createUserProfileWithAttributes(profile);
        } catch (error) {
            throw error;
        }
    };

    /**
     * @param {string} url
     * @return {CodeUrlState}
     */
    const getCodeStateFromUrl = (url) => {
        const matchers = {
            state: /state=([^&]+)/,
            code: /code=([^&]+)/,
            error: /error=([^&]+)/,
            error_description: /error_description=([^&]+)/
        };
        const { state, code, error, error_description } = Object.entries(matchers).reduce((acc, [key, reg]) => {
            const m = url.match(reg);
            return { ...acc, [key]: m && m.length > 1 ? m[1] : null };
        }, {});
        const info = getCodeInfo();
        /** @type {CodeUrlState} */
        const emptyState = { code: null, error: null, error_description: null, redirectUrl: null };

        // no info or wrong state
        if (info == null || info.state !== state) {
            info &&
                info.state !== state &&
                console.warn(`auth.adapter.service.getCodeStateFromUrl`, `state doesnt match with cache`);
            return emptyState;
        }

        return { code, error, error_description, redirectUrl: info.redirectUrl };
    };

    return { getLoginUrl, getCodeStateFromUrl, login, loginCode, logout, token, profile };
};
