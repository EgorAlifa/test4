import axios from 'axios';
import { HttpTransportError, HttpTransportRequestCancel } from './errors';

/**
 * @typedef {import('axios').AxiosInstance} AxiosInstance
 * @typedef {import('axios').CancelToken} CancelToken
 * @typedef {import('./HttpBase').RequestCancelData} RequestCancelData
 * @typedef {import('./HttpBase').TransportRequestCancel} TransportRequestCancel
 * @typedef {import('./HttpBase').InnerRequestCancel} InnerRequestCancel
 * @typedef {import('./types').ITransportRequest} ITransportRequest
 * @typedef {import('./types').ITransportResponse} ITransportResponse
 * @typedef {import('./types').ITransportOptions} ITransportOptions
 * @typedef {import('./types').ITransportExtraOptions} ITransportExtraOptions
 */

/**
 * HTTP Transport Client implementation
 * with Axios HTTP Client underhood
 * and extra service-specific behaviour
 *
 * @implements {import('./types').ITransportConstructor}
 */
export class HttpBase {
    /**
     *
     * @type {AxiosInstance}
     * @private
     */
    _axios;

    /**
     *
     * @type {Set<InnerRequestCancel>}
     * @private
     */
    _requestCancels = new Set();
    /**
     *
     * @type {?RequestCancelData}
     * @private
     */
    _nextRequestCancel = null;
    /**
     *
     * @type {Record<string, any>}
     * @private
     */
    _options = {};

    /**
     * Checks if specified error is transport-related
     *
     * @param {Error} error
     * @return {boolean}
     */
    static isTransportError(error) {
        return axios.isAxiosError(error);
    }

    /**
     * Checks if specified error is cancel request-related
     * @param {Error} error
     * @return {boolean}
     */
    static isCancel(error) {
        return axios.isCancel(error);
    }

    /**
     * Обрабатывает ошибку от транспорта и трансформирует в инфраструктурную ошибку
     * Особенность: знает формат ошибки сервера, какие статус коды являются ошибочными
     *
     * @param {Error} error
     * @return {HttpTransportError|HttpTransportRequestCancel}
     */
    static processTransportError(error) {
        if (error instanceof HttpTransportError) {
            return error;
        }

        // mute cancel error
        if (this.isCancel(error)) {
            return new HttpTransportRequestCancel();
        }

        const { message } = error;
        // If non-transport error
        if (this.isTransportError(error) === false) {
            return new HttpTransportError(message, {
                code: HttpTransportError.Code.INTERNAL,
                reason: error
            });
        }

        // The request was made and the server responded with a status code
        // that falls out of the range of 2xx
        const {
            response,
            request,
            config: { url, data: requestData, method }
        } = error;

        const reason = { url, data: requestData, method };

        if (response != null) {
            const { data, status } = response;
            const errorMessage = typeof data === 'string' ? data : message;

            return new HttpTransportError(errorMessage, {
                data,
                code: status,
                reason
            });
        }

        // The request was made but no response was received
        // `error.request` is an instance of XMLHttpRequest in the browser
        if (request != null) {
            return new HttpTransportError(message, {
                code: HttpTransportError.Code.INTERNAL,
                reason
            });
        }

        // Something happened in setting up the request that triggered an Error
        return new HttpTransportError(message, {
            code: HttpTransportError.Code.INTERNAL,
            reason: error
        });
    }

    /**
     * Constructor
     *
     * @param {ITransportOptions} [transportOptions={}]
     * @param {ITransportExtraOptions} [extraOptions={}]
     */
    constructor(transportOptions = {}, extraOptions = {}) {
        this._options = { ...this._options, ...extraOptions };
        this._axios = axios.create(transportOptions);
    }

    /**
     * Returns cancel function that can be used to cancel next transport request
     *
     * @return {TransportRequestCancel}
     */
    getNextRequestCancel() {
        const { cancel, token } = this._createRequestCancel();
        this._nextRequestCancel = { cancel, token };
        return cancel;
    }

    /**
     * Creates a new request
     *
     * @param {ITransportRequest} config per-request config
     * @return {Promise<ITransportResponse>}
     */
    async request({ url, method = 'get', params = {}, options = {}, responseHandler = null }) {
        const { token: cancelToken, cancel } = this._nextRequestCancel ?? this._createRequestCancel();
        this._nextRequestCancel = null;
        const unregisterCancel = this._registerRequestCancel(cancel);

        const request = this._buildRequestConfig({ url, method, params, options, cancelToken });
        try {
            const response = await this._axios.request(request);
            return this._processSuccessResponse(response, { responseHandler });
        } catch (error) {
            throw this._processTransportError(error);
        } finally {
            unregisterCancel();
        }
    }

    /**
     * Disposes http transport related resources
     */
    dispose() {
        this.cancelAllRequests();
    }

    /**
     * Cancel all active RequestPromises
     */
    cancelAllRequests() {
        this._requestCancels.forEach((cancel) => cancel());
        this._requestCancels.clear();
    }

    /**
     *
     * @return {string}
     */
    get baseURL() {
        // eslint-disable-next-line goodt-rules/no-long-prop-chains
        return this._axios.defaults.baseURL;
    }

    /**
     *
     * @param {string} baseURL
     */
    set baseURL(baseURL) {
        // eslint-disable-next-line goodt-rules/no-long-prop-chains
        this._axios.defaults.baseURL = baseURL;
    }

    /**
     * Returns the base url
     *
     * @return {string}
     */
    getBaseUrl() {
        return this.baseURL;
    }

    /**
     *
     * @param {ITransportRequest & { cancelToken?: CancelToken }} [config={}]
     * @return {import('axios').AxiosRequestConfig} request
     * @protected
     */
    _buildRequestConfig(config = {}) {
        const { url, method = 'get', params = {}, options = {}, cancelToken = null } = config;
        const request = {
            method,
            url,
            cancelToken,
            ...options
        };
        request[request.method.toLocaleLowerCase() === 'get' ? 'params' : 'data'] = params;

        // axios 0.x.x AxiosRequestConfig.paramsSerializer back compatibility
        if (typeof request.paramsSerializer !== 'object') {
            request.paramsSerializer =
                typeof request.paramsSerializer === 'function'
                    ? { serialize: request.paramsSerializer }
                    : { indexes: null };
        }

        return request;
    }

    /**
     *
     * @param {ITransportResponse} response
     * @param responseHandler
     * @return {ITransportResponse}
     * @throws {HttpTransportError}
     * @protected
     */
    _processSuccessResponse(response, { responseHandler }) {
        if (typeof response.data === 'object' && response.data.error != null) {
            const { error } = response.data;
            const message = typeof error === 'string' ? error : error.message ?? 'Transport response error';

            throw new HttpTransportError(message, {
                code: 1,
                data: error,
                reason: response.request
            });
        }

        return responseHandler ? responseHandler(response) : response;
    }

    /**
     * @return {RequestCancelData}
     * @private
     */
    _createRequestCancel() {
        const { token, cancel } = axios.CancelToken.source();
        return { cancel, token };
    }

    /**
     * Registers a new cancel
     *
     * @private
     * @param {InnerRequestCancel} cancel
     * @return {() => void} unregister function
     */
    _registerRequestCancel(cancel) {
        this._requestCancels.add(cancel);
        return () => this._requestCancels.delete(cancel);
    }

    /**
     *
     * @param {Error} error
     * @return {Error|HttpTransportError|HttpTransportRequestCancel}
     * @protected
     */
    _processTransportError(error) {
        return this.constructor.processTransportError(error);
    }
}

export { HttpBase as default };
