import { CancelToken, AxiosRequestConfig, AxiosInstance } from 'axios';

import {
    HttpClient,
    HttpClientError,
    ITransport,
    ITransportExtraOptions,
    ITransportOptions,
    ITransportRequest,
    ITransportResponse,
    TransportRequestCancel
} from './types';

import { HttpTransportError, HttpTransportRequestCancel } from './errors';

export type InnerRequestCancel = () => void;

export type RequestCancelData = {
    cancel: InnerRequestCancel;
    token: CancelToken;
};

/**
 * HTTP Transport Client implementation
 * with Axios HTTP Client underhood
 * and extra service-specific behaviour
 *
 * @implements {import('./types').ITransportConstructor}
 * @param {ITransportOptions} [options={}]  transport config
 */
export class HttpBase implements ITransport {
    /**
     *
     * @type {Set<RequestCancelData['cancel']>}
     * @private
     */
    private _requestCancel: Set<RequestCancelData['cancel']>;

    /**
     *
     * @type {?RequestCancelData}
     * @private
     */
    private _nextRequestCancel: RequestCancelData;

    /**
     *
     */
    protected _axios: HttpClient;

    protected _options: Record<string, any>;

    /**
     * Checks if specified error is transport-related
     *
     * @param {Error|HttpClientError} error
     * @return {boolean}
     */
    static isTransportError(error: Error | HttpClientError): boolean;

    /**
     * Checks if specified error is cancel request-related
     * @param {Error| HttpClientError} error
     * @return {boolean}
     */
    static isCancel(error: Error | HttpClientError): boolean;

    /**
     *
     * @param {Error} error
     * @return {HttpTransportError | HttpTransportError}
     */
    static processTransportError(error: HttpClientError): Error | HttpTransportError | HttpTransportRequestCancel;

    baseURL: string;

    /**
     * Constructor
     *
     * @param {ITransportOptions} [transportOptions={}] Transport config
     * @param {ITransportExtraOptions} [extraOptions={}] Transport options
     */
    constructor(transportOptions?: ITransportOptions, extraOptions?: ITransportExtraOptions);

    /**
     * Creates a new request
     *
     * @param {ITransportRequest} config per-request config
     * @return {Promise<ITransportResponse>}
     */
    request(config: ITransportRequest): Promise<ITransportResponse>;

    /**
     * Disposes http transport related resources
     */
    dispose(): void;

    /**
     * Returns cancel function that can be used to cancel next transport request
     *
     * @return {TransportRequestCancel}
     */
    getNextRequestCancel(): TransportRequestCancel

    /**
     * Cancel all active RequestPromises
     */
    cancelAllRequests(): void;

    /**
     * Returns the base url
     *
     * @return {string}
     */
    getBaseUrl(): string;

    /**
     *
     * @param {ITransportRequest & { cancelToken: CancelToken }} [params]
     * @return {{ request: import('axios').AxiosRequestConfig }}
     * @protected
     */
    protected _buildRequestConfig(params: ITransportRequest & { cancelToken: CancelToken }): AxiosRequestConfig;

    /**
     *
     * @return {RequestCancelData}
     * @private
     */
    private _createRequestCancel(): RequestCancelData;

    /**
     * Registers a new cancel
     *
     * @private
     * @param {InnerRequestCancel} cancel
     * @return {() => void} unregister function
     */
    private _registerRequestCancel(cancel: InnerRequestCancel): () => void;

    /**
     * Unregisters cancel
     *
     * @private
     * @param {InnerRequestCancel} cancel
     */
    private _unregisterRequestCancel(cancel: InnerRequestCancel);

    /**
     * @protected
     * @param {Error} error
     * @return {HttpTransportError | HttpTransportRequestCancel}
     */
    protected _processTransportError<T extends Error>(error: T): T | HttpTransportError | HttpTransportRequestCancel;

    /**
     * @protected
     * @param {ITransportResponse} response
     * @param responseHandler
     * @throws {HttpTransportError}
     * @return {ITransportResponse}
     */
    protected _processSuccessResponse(response: ITransportResponse, { responseHandler }): ITransportResponse
}

export { HttpBase as default };
