import Vue from 'vue';
import { shouldWatch } from './watch-when';

const UNDEFINED_SYMBOL = Symbol('undefined');

/**
 *
 * @param {() => any} getter
 * @param {import('vue').Vue} context
 * @return {function(): any}
 */
const createGetterWithCache = (getter, { context }) => {
    let cachedValue = UNDEFINED_SYMBOL;
    return () => {
        if (cachedValue === UNDEFINED_SYMBOL) {
            cachedValue = getter.call(context);
        }
        return cachedValue;
    }
}
/**
 *
 */
class ComputedWhen {
    constructor(computed, when) {
        this.computed = computed;
        this.when = when;
    }

    /**
     * @param {import('vue').Vue} context
     * @return {import('vue/types/options').ComponentOptions['computed']|{}}
     */
    resolveComputedDescriptor({ context }) {
        return shouldWatch(this.when, context) ? this.computed : {};
    }

    /**
     * @param {import('vue').Vue} context
     * @return {void}
     */
    assignStaticProperties({ context }) {
        if (shouldWatch(this.when, context)) {
            return;
        }
        Object.entries(this.computed).forEach(([accessor, getter]) => {
            // eslint-disable-next-line better-mutation/no-mutating-functions
            const get = createGetterWithCache(getter, { context });
            Object.defineProperty(context, accessor, {
                get,
                configurable: true,
                enumerable: true
            });
        });
    }
}

/**
 *
 * @param {import('vue/types/options').ComponentOptions['computed']} computed
 * @param {string|function} when
 * @return {ComputedWhen}
 */
export const computedWhen = function (computed, when) {
    return new ComputedWhen(computed, when);
};

/**
 *
 * @param name
 * @param when
 * @return {{ beforeCreate(): void }}
 */
export const useComputedWhenMixin = ({ name = 'computedEditor', when = '$root.isEditorMode' } = {}) => {
    const Mixin = {
        beforeCreate() {
            let { [name]: computed } = this.$options;
            // eslint-disable-next-line better-mutation/no-mutating-functions
            if (computed == null) {
                return;
            }
            if (Object.keys(computed).length === 0) {
                return;
            }
            if (computed instanceof ComputedWhen === false) {
                computed = new ComputedWhen(computed, when);
            }
            this.$options.computed = {
                ...this.$options.computed,
                ...computed.resolveComputedDescriptor({ context: this })
            };

            computed.assignStaticProperties({ context: this });
        }
    };

    return Mixin;
};

const mergeComputedEditorOptionStrategy = (from, to) => ({
    ...from,
    ...to
});

Vue.config.optionMergeStrategies.computedEditor = mergeComputedEditorOptionStrategy;
