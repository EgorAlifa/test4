import { get as getByPath } from 'lodash';
import Vue from 'vue';

/**
 *
 * @param {string|function} when
 * @param {import('@goodt-wcore/elem').IElemInstance} context
 * @return {boolean}
 */
export const shouldWatch = (when, context) => {
    if (typeof when === 'function' && when.call(context, context) !== true) {
        return false;
    }
    if (typeof when === 'string' && getByPath(context, when) !== true) {
        return false;
    }

    return true;
};

/**
 *
 */
class WatchWhen {
    constructor(watch, when) {
        this.watch = watch;
        this.when = when;
    }

    /**
     * @param {import('@goodt-wcore/elem').IElemInstance} context
     * @return {*|null}
     */
    resolveWatch({ context }) {
        return shouldWatch(this.when, context) ? this.watch : null;
    }
}

/**
 *
 * @param watch
 * @param {string|function} when
 * @return {WatchWhen}
 */
export const watchWhen = function(watch, when) {
    return new WatchWhen(watch, when);
};

/**
 *
 * @param name
 * @param when
 * @return {{created(): void, beforeCreate(): void}}
 */
export const useWatchWhenMixin = ({ name = 'watchEditor', when = '$root.isEditorMode' } = {}) => {
    const Mixin = {
        beforeCreate() {
            const { [name]: watch } = this.$options;
            // eslint-disable-next-line better-mutation/no-mutating-functions
            if (watch == null) {
                return;
            }
            if (Reflect.ownKeys(watch).length === 0) {
                return;
            }
            if (name === 'watch') {
                this.$options.watch = undefined;
            }
            this.$options.watchWhen = watch instanceof WatchWhen ? watch : new WatchWhen(watch, when);
        },
        created() {
            // eslint-disable-next-line no-shadow
            const { watchWhen } = this.$options;
            // eslint-disable-next-line better-mutation/no-mutating-functions
            if (watchWhen == null) {
                return;
            }
            const watch = watchWhen.resolveWatch({ context: this });
            if (watch == null) {
                return;
            }

            Reflect.ownKeys(watch).forEach((watchingTargetTokenSymbol) => {
                let options = {};
                let handler = watch[watchingTargetTokenSymbol];
                const watchingTargetToken = handler.target;

                if (typeof handler === 'object') {
                    // eslint-disable-next-line no-shadow
                    const { handler: handlerFn, when, ...restOptions } = handler;
                    if (shouldWatch(when, this) === false) {
                        return;
                    }

                    options = restOptions;
                    // eslint-disable-next-line no-param-reassign
                    handler = handlerFn;
                }

                watchingTargetToken.split(',').forEach((target) => {
                    [handler].flat().forEach((_handler) => {
                        if (typeof _handler === 'string') {
                            // eslint-disable-next-line no-param-reassign
                            _handler = this[_handler];
                        }
                        this.$watch(target, _handler.bind(this), options);
                    });
                });
            });
        }
    };

    return Mixin;
};

const normalizeWatchDefinitions = (watchDefinitions) => watchDefinitions == null
    ? null
    : Reflect.ownKeys(watchDefinitions)
        .reduce((acc, key) => ({
                ...acc,
                [typeof key === 'symbol' ? key : Symbol(key)]: typeof watchDefinitions[key] === 'object'
                    ? {
                        target: key,
                        ...watchDefinitions[key]
                    } : {
                        target: key,
                        handler: watchDefinitions[key]
                    }
            }), {}
        );

const mergeWatchEditorOptionStrategy = (from, to) => {
    const result = {
        ...normalizeWatchDefinitions(from),
        ...normalizeWatchDefinitions(to)
    };
    return result;
};

Vue.config.optionMergeStrategies.watchEditor = mergeWatchEditorOptionStrategy;
