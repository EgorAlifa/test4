/**
 * @typedef {import('./elem-config').ElemMetaMigration} ElemMetaMigration
 */
/**
 * @typedef {object} ElemTypeMetaBase
 * @property {?string} packageName
 * @property {string} type
 */
/**
 * @typedef {object} ElemTypeMeta
 * @property {?string} packageName
 * @property {string} type
 * @property {string} path
 */

const CoreElemTypes = [
    'ElemRoot',
    'ElemTemplateContent'
];

const LegacyPackageNames = [
    null,
    undefined,
    'enterpriseconsulting',
    'informationideas'
];

/**
 * @param {string} type
 * @return {string}
 */
const migrateElemType = (type) => {
    const rules = []; // [{ find: /^PerformanceManagement/, replace: 'PM' }];
    for (const { find, replace } of rules) {
        if (type.match(find) != null) {
            return type.replace(find, replace);
        }
    }
    return type;
};

/**
 * @param {string} elemFullType
 * @param {ElemTypeMetaBase} meta
 * @param {Object.<string, ElemMetaMigration>} [migrations={}]
 * @return {ElemTypeMetaBase}
 */
const migrateElemMeta = (elemFullType, { packageName, type }, migrations = {}) => {
    const migrationRecord = migrations[elemFullType];
    if (migrationRecord != null) {
        const { package: newPackageName, name: newType = type } = migrationRecord;
        return { packageName: newPackageName, type: migrateElemType(newType) };
    }
    if (LegacyPackageNames.includes(packageName)) {
        return { packageName: 'legacy', type: migrateElemType(type) };
    }

    return { packageName, type };
};

/**
 * @param {string} elemType
 * @return {string}
 */
const getElemTypePath = (elemType) => {
    const name = elemType.split('/').pop();
    return `${elemType}/${name}`;
};

/**
 * @param {ElemTypeMeta} meta
 * @return {string}
 */
export const getElemFullType = ({ packageName, type }) => packageName != null ? `${packageName}::${type}` : type;

/**
 * @param {string} elemFullType
 * @param {Object.<string, ElemMetaMigration>} [migrations]
 * @return {ElemTypeMeta}
 */
export const getElemTypeMeta = (elemFullType, migrations = {}) => {
    if (CoreElemTypes.includes(elemFullType)) {
        return { packageName: null, type: elemFullType, path: '' }
    }
    const match = elemFullType.match(/^([^:]+)::([^:]+)/);
    const [, packageName = null, type = elemFullType] = match ?? [];
    const { packageName: packageNameMigrated, type: typeMigrated } = migrateElemMeta(
        elemFullType,
        { packageName, type },
        migrations
    );
    return { packageName: packageNameMigrated, type: typeMigrated, path: getElemTypePath(typeMigrated) };
};
