import setByPath from 'lodash/set';
import getByPath from 'lodash/get';
import { has as hasByPath } from 'lodash';
import { CoreError } from '@goodt-wcore/errors';

const INDEX_MATCHER_RE = /\[(\d+)\]/g;

const getLabelOrHint = (propName, propLabelOrHint, defaultValue = propName) => {
    const getFromArray = (labelOrHint) => {
        const [arrayElementIndex] = [...propName.matchAll(INDEX_MATCHER_RE)].reverse();
        return labelOrHint[arrayElementIndex[1]];
    };

    if (Array.isArray(propLabelOrHint)) {
        return getFromArray(propLabelOrHint) || defaultValue;
    }

    if (typeof propLabelOrHint === 'object') {
        const labelOrHint = propLabelOrHint[propName.replace(INDEX_MATCHER_RE, '')];

        if (Array.isArray(labelOrHint)) {
            return getFromArray(labelOrHint) || defaultValue;
        }

        return labelOrHint || defaultValue;
    }

    return propLabelOrHint || defaultValue;
};

/**
 * @typedef {object} PanelMetaData
 * @property {string} name      panel name
 * @property {string} icon      mdi icon class
 */

export default {
    provide(vm = this) {
        return {
            get panel() {
                return {
                    get elementInstance() {
                        return vm.elementInstance;
                    },
                    get props() {
                        return vm.props;
                    },
                    setProp: vm.setProp.bind(vm),
                    getProp: vm.getProp.bind(vm),
                    getLabel: vm.getLabel.bind(vm),
                    getHint: vm.getHint.bind(vm),
                    handleError: vm.handleError.bind(vm),
                    validatePropExist: vm.validatePropExist.bind(vm)
                };
            }
        };
    },
    methods: {
        /**
         * @public
         * @param {string} propName
         * @param {any} propValue
         * @param {boolean} [emitChange=true]
         */
        setProp(propName, propValue, emitChange = true) {
            this.props = setByPath(this.props, propName, this.ensureType(propName, propValue));
            if (emitChange === true) {
                this.propChanged();
            }
        },
        /**
         * @public
         * @param {string} propName
         * @return {any}
         */
        getProp(propName) {
            const propValue = getByPath(this.props, propName);
            return this.ensureType(propName, propValue);
        },
        /**
         *
         * @param {string} propName
         * @return {*}
         */
        getLabel(propName) {
            const { props } = this.descriptor;
            const [rootPropName] = propName.replace(INDEX_MATCHER_RE, '').split('.');
            const { label: propLabel } = props[rootPropName];
            return getLabelOrHint(propName, propLabel);
        },

        /**
         *
         * @param {string} propName
         * @return {*}
         */
        getHint(propName) {
            const { props } = this.descriptor;
            const [rootPropName] = propName.replace(INDEX_MATCHER_RE, '').split('.');
            const { hint } = props[rootPropName];
            return getLabelOrHint(propName, hint, null);
        },
        /**
         * @param {string} propName
         */
        validatePropExist(propName) {
            const { props } = this.descriptor;
            const [rootPropName] = propName.replace(INDEX_MATCHER_RE, '').split('.');

            if (rootPropName in props === false) {
                this.handleError(new CoreError(`"${rootPropName}" not found in widget "descriptor.props"`));
            }

            if (hasByPath(this.props, propName) === false) {
                this.handleError(new CoreError(`"${propName}" not found in widget "descriptor.props"`));
            }
        },
        /**
         *
         * @param {string} propName
         * @param {string} propValue
         * @return {*}
         */
        ensureType(propName, propValue) {
            // regexp with 'g' flag is stateful
            const hasMatch = new RegExp(INDEX_MATCHER_RE).test(propName);

            if (hasMatch === true) {
                return propValue;
            }
            const propPath = propName.split('.');
            if (propPath.length > 1) {
                return propValue;
            }
            if ([undefined, null, ''].includes(propValue)) {
                return propValue;
            }
            const { type: Type } = this.descriptor.props[propName];
            if ([Number, Boolean, String].includes(Type)) {
                return Type(propValue);
            }

            return propValue;
        },
        /**
         *
         * @param {Error} error
         */
        handleError(error) {
            error.message = `Panel[${this.elementInstance.type}]: ${error.message}`;
            this.elementInstance?.handleError(error, { scope: this.$meta?.name ?? this.name });
        }
    }
};
