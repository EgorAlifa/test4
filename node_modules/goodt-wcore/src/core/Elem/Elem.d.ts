import Vue, { AsyncComponent, VueConstructor, ComponentOptions as VueComponentOptions } from 'vue';
import { ThisTypedComponentOptionsWithRecordProps } from 'vue/types/options';

import { ErrorService } from '@goodt-wcore/managers';

import { IWatchStoreDefinition } from './infra';

import { EventBusEvent, EventBusWrapper, EventBus, EventHandler } from '@goodt-wcore/managers/EventBus';
import {
    Computed as IElemStoreComputed,
    Methods as IElemStoreMethods,
    Inject as IElemStoreInject
} from './types/IElemStore';
import { Computed as IElemRouterComputed, Methods as IElemRouterMethods } from './types/IElemRouter';

import VueElem from './Elem.vue';
import {
    CssVarsMapping,
    DescriptorProps,
    WidgetMetaComponentOption,
    ISubscribeEventBusDefinition
} from './infra/types';

import { ElemDescriptor } from '@goodt-wcore/elem';

/**
 * Component Instance 'data' ComponentOptions descriptor section members
 * @interface {Data}
 */
interface Data {
    cssClass: Record<string, string>;
    cssStyle: Record<string, string>;
    slotDefault: string;
    descriptor: ElemDescriptor;
}

interface Props {
    readonly id: string;
    readonly type: string;
    readonly initProps: object;
    readonly slotData: object;
}

interface Injected extends IElemStoreInject {
    readonly $eventBus: EventBusWrapper;
    readonly $errorService: ErrorService;
}

/**
 * Component Instance 'computed' ComponentOptions descriptor section members
 */
interface Computed extends IElemStoreComputed, IElemRouterComputed {
    readonly props: Record<string, any> & DescriptorProps;
    readonly $cssVarsStatic: Record<string, any>;
    readonly $cssVarsStyle: Record<string, string>;
    readonly isEditorMode: boolean;
    readonly isDebugMode: boolean;
}

/**
 * Component Instance 'methods' ComponentOptions descriptor section members
 * @interface {Methods}
 */
interface Methods extends IElemStoreMethods, IElemRouterMethods {
    super(componentOptions?: VueComponentOptions): IElemInstance;

    genCssClass(): void;

    genCssStyle(): void;

    /**
     * Build css-vars-style object from css var to prop mapping
     * @public
     * @template P
     * @param {CssVarsMapping<P>>} cssVarsMapping
     * @param {P} [props]
     * @return {Record<string, string>}
     */
    $buildCssVarsStyle<P = Record<string, any>>(cssVarsMapping: CssVarsMapping<P>, props?: P): Record<string, string>;

    /**
     * @public
     */
    $genCssVarsStyle(cssVars: Record<string, string>): Record<string, string>;

    /**
     * @public
     */
    getSlotNames(): string[];

    getPanels(): AsyncComponent[];

    isChildAllowed(type: string): boolean;

    /* event bus related */
    setEventBus(eventBus: EventBus): void;

    /**
     * @public
     * @deprecated Use subscribe section instead
     */
    subscribe(): void;

    /**
     * Listen event bus event
     *
     * @param {string | EventBusEvent} eventType      event type
     * @param {EventHandler} handler                handler
     * @param {boolean} [once=false]                once? @default false
     * @return {Function}                           dispose handler
     */
    $eventListen(eventType: string | EventBusEvent, handler: EventHandler, once?: boolean): () => void;

    /**
     * Trigger event bus event
     *
     * @param {string | EventBusEvent} eventType    event type
     * @param {object} [data] custom data
     */
    $eventTrigger(eventType: string | EventBusEvent, data?: object): void;

    /**
     * Returns event bus event listeners count
     *
     * @param {string | EventBusEvent} eventType    event type
     * @return {number}                             count of registered event listener handlers
     */
    $eventCount(eventType): number;

    /**
     * @deprecated Use `hasConst` descriptor option instead
     */
    $c<T extends unknown>(constantName: T): T;

    /**
     * @private
     */
    _mounted(triggerEvents: boolean = true): void;

    /**
     *
     */
    $handleError(error: Error, { scope }?: { scope?: string }): void;

    /**
     *
     */
    $debugMessage(message: string, { scope, type = 'warning' }?: { scope?: string; type?: 'error' | 'warning' }): void;
}

export interface IElemInstance extends Vue, Data, Methods, Computed, Props, Injected {}

export interface IElemComponentOptionsInternal
    extends ThisTypedComponentOptionsWithRecordProps<Vue, Data, IElemInstance, Computed, Props> {
    computed?: IElemInstance;
    subscribe?: ISubscribeEventBusDefinition[];
    static?: Record<string, any>;
    meta?: WidgetMetaComponentOption;
    watchStore?: IWatchStoreDefinition[];
}

export interface IElemComponentOptions<IInstance, D, M, C, P>
    extends ThisTypedComponentOptionsWithRecordProps<
        IElemInstance & IInstance,
        Data & D,
        IElemInstance & IInstance & D & M & C & P,
        Computed & C,
        Props & P
    > {
    computed?: IElemInstance & IInstance & D & M & C & P;
    subscribe?: ISubscribeEventBusDefinition[];
    static?: Record<string, any>;
    meta?: WidgetMetaComponentOption;
    watchStore?: IWatchStoreDefinition[];
}

declare module 'vue/types/options' {
    import Vue from 'vue';

    interface ComponentOptions<V extends Vue> {
        subscribe?: ISubscribeEventBusDefinition[];
        static?: Record<string, any>;
        meta?: WidgetMetaComponentOption;
        watchStore?: IWatchStoreDefinition[];
    }
}

declare module 'vue/types/vue' {
    interface Vue {
        isEditorMode: boolean;
        isDebugMode: boolean;
    }
}

export type TElemConstructor = VueConstructor<IElemInstance>;
declare const _default: VueElem & IElemComponentOptions;
export default _default;
