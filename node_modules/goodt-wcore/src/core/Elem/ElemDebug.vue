<script>
import { CoreError, CoreWarning } from '@goodt-wcore/errors';
import ElemBase from './ElemBase.vue';
import { validateStateTypes, validateWidgetVars } from './infra';

const ElemDebugOptions = {
    ...ElemBase,
    methods: {
        ...ElemBase.methods,
        _buildExternalStateFromInternal: ElemBase.methods.buildExternalStateFromInternal,
        _buildInternalStateFromExternal: ElemBase.methods.buildInternalStateFromExternal,
        /**
         *
         * @param {StoreGlobalState} externalState
         * @param {boolean} hasMap
         * @return {[StoreElemState, StoreElemState]}
         */
        buildInternalStateFromExternal(externalState, { hasMap = true } = {}) {
            // call original ElemBase,
            const [internalState, internalStateWithEnsuredTypes] = this._buildInternalStateFromExternal(externalState, { hasMap });
            const varAliases = hasMap ? this.props.varAliases : null;
            const { vars: varsDescriptor } = this.descriptor;

            const problems = [];

            if (Object.keys(internalState).length > 0) {
                // prevent validation cause exception
                try {
                    const { isError, error: errors } = validateStateTypes(
                        internalState,
                        internalStateWithEnsuredTypes,
                        {
                            varsDescriptor
                        }
                    );
                    if (isError) {
                        problems.push(...errors);
                    }
                } catch (error) {
                    problems.push(error);
                }
            }

            const internalStateProxy = new Proxy(internalStateWithEnsuredTypes, {
                get: (target, propKey) => {
                    if (propKey in target || ['toJSON'].includes(propKey)) {
                        return target[propKey];
                    }
                    // prevent validation cause exception
                    try {
                        const { isError, error: errors } = validateWidgetVars(
                            {
                                stateVars: [propKey],
                                descriptorVars: Object.keys(varsDescriptor),
                                varAliases: Object.entries(varAliases ?? {})
                                    .filter(([, { listen }]) => listen != null)
                                    .map(([name]) => name)
                            },
                            { traceContext: this.$options.methods.buildInternalStateFromExternal }
                        );
                        if (isError) {
                            problems.push(...errors);
                        }
                    } catch (error) {
                        problems.push(error);
                    }

                    return target[propKey];
                },
                set: (target, propKey, value) => {
                    const error = new CoreError(
                        `FORBIDDEN to overwrite this.$storeState['${propKey}'] directly with value '${value}'. Use this.$storeCommit`
                    );
                    error.captureStackTrace(this.$options.methods.buildInternalStateFromExternal);
                    this.handleError(error, {
                        scope: '$storeState'
                    });
                    return true;
                },
                deleteProperty: (target, propKey) => {
                    const error = new CoreError(
                        `FORBIDDEN to delete this.$storeState['${propKey}'] directly. Use this.$storeCommit({ ${propKey}: undefined })`
                    );
                    error.captureStackTrace(this.$options.methods.buildInternalStateFromExternal);
                    this.handleError(error, {
                        scope: '$storeState'
                    });
                    return true;
                }
            });

            problems.forEach((error) => {
                this.handleError(error, {
                    scope: '$storeState'
                });
            });

            return [internalState, internalStateProxy];
        },
        /**
         *
         * @param {import('@goodt-wcore/managers').StoreElemState} internalState
         * @param {boolean} [hasMap=true]
         * @param {boolean} [validate=true]
         * @param {function(value: any): any} buildExternalStateValue
         * @return {import('@goodt-wcore/managers').StoreGlobalState}
         */
        buildExternalStateFromInternal(internalState, { validate = true, hasMap = true, buildExternalStateValue } = {}) {
            if (validate === true && Object.keys(internalState).length > 0) {
                const problems = [];
                const { vars: varsDescriptor } = this.descriptor;
                const varAliases = hasMap ? this.props.varAliases : null;

                try {
                    const { error: problemsOne } = validateWidgetVars(
                        {
                            stateVars: Object.keys(internalState),
                            descriptorVars: Object.keys(varsDescriptor),
                            varAliases: Object.entries(varAliases ?? {})
                                .filter(([, { trigger }]) => trigger != null)
                                .map(([name]) => name)
                        },
                        { traceContext: this.$options.methods.buildExternalStateFromInternal }
                    );
                    if (problemsOne != null) {
                        problems.push(...problemsOne);
                    }
                } catch (error) {
                    problems.push(error);
                }

                problems.forEach(this.handleError);
            }

            return this._buildExternalStateFromInternal(internalState, {
                hasMap,
                buildExternalStateValue
            });
        }
    }
};

export default ElemDebugOptions;
</script>
