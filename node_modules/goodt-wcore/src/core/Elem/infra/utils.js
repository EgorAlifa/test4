import Vue from 'vue';
import { merge } from 'lodash';
import { ConstManager, ColorManager } from '@goodt-wcore/managers';
import { ELEM_TYPE_DOM_ATTRIBUTE_NAME } from './config';

/**
 * @typedef {import('vue/types/vue').Vue} VueInstance
 */

/**
 * Widget LC event class
 */
class ElemEvent extends CustomEvent {
    /**
     * @constructor
     * @param {string} eventName
     * @param {Object} options
     * @param {Record<string,any>} options.payload
     * @param {VueInstance} options.instance
     */
    constructor(eventName, { payload, instance }) {
        super(eventName, {
            detail: {
                ...(payload != null && { payload }),
                instance
            }
        });
    }

    get instance() {
        return this.detail.instance;
    }
    
    get payload() {
        return this.detail.payload;
    }
}

/**
 * Returns generated Constructor-specific dom id
 *
 * @param {string | number} elemId
 * @return {string}
 */
export const getElemDomId = (elemId) => `elem-${elemId}`;

/**
 * Dispatches Elem Vue Component LC-specific Event
 * via Vue emit mechanism and also DOM events mechanism.
 *
 * @param {string} eventName
 * @param {{payload?: Record<string,any>}} [options]
 * @this {VueInstance}
 */
export function dispatchEventByName(eventName, { payload } = {}) {
    const event = new ElemEvent(eventName, { payload, instance: this });
    this.$emit(event.type, this, payload);
    document.dispatchEvent(event);
}

/**
 * Patches vue component instance root dom element with runtime prop
 * __elem__ refers to self component instance and set constructor-specific extra attributes
 *
 * @param {VueInstance & {id, type}} context
 */
export const patchComponentRootDomElement = (context) => {
    const { $el, id, type } = context;
    if (!$el) {
        return;
    }
    // expose vue component instance reference
    $el.__elem__ = context;
    // set id/data-elem attrs
    if ($el.setAttribute) {
        $el.setAttribute('id', getElemDomId(id));
        $el.setAttribute(ELEM_TYPE_DOM_ATTRIBUTE_NAME, type);
    }
};

/**
 * Returns descriptor props hash with default values
 *
 * @param {ElemDescriptor} descriptor
 * @return {Record<string, any>}
 */
export const getDescriptorDefaultProps = (descriptor) => {
    const { props } = descriptor;
    return Object.entries(props).reduce((defaults, [propName, propOptions]) => {
        const { default: value } = propOptions;
        return {
            ...defaults,
            [propName]: typeof value === 'function' ? value() : value
        };
    }, {});
};

const Observer = new Vue().$data.__ob__.constructor;
const dummyObserver = new Observer({});

/**
 *
 * @param object
 */
export const unobserve = (object) => {
    if (object == null || typeof object !== 'object') {
        return;
    }

    if (object.__ob__ != null) {
        object.__ob__ = dummyObserver;
    }

    if (Array.isArray(object) === false) {
        Object.entries(object).forEach(unobserve);
        return;
    }

    if (object.length === 0 || typeof object[0] !== 'object') {
        return;
    }

    object.forEach(unobserve);
};

/**
 * Replaces all constant keys occurrences with values in a string
 *
 * @param {any} str  string to test
 * @return {any}
 */
export const $c = (str) => {
    if (typeof str !== 'string') {
        return str;
    }
    str = ColorManager.instance.interpolate(str);
    str = ConstManager.instance.interpolate(str);

    return str;
};

/**
 * Simple object props traverse
 *
 * @param propValue
 * @return {*}
 */
const processPropWithConst = (propValue) => {
    if (propValue == null) {
        return propValue;
    }
    if (Array.isArray(propValue)) {
        return propValue.map(processPropWithConst);
    }
    if (typeof propValue === 'object') {
        const propValueClone = { ...propValue };
        Object.entries(propValueClone).forEach(([name, value]) => {
            propValueClone[name] = processPropWithConst(value);
        });
        return propValueClone;
    }
    if (typeof propValue === 'string') {
        return $c(propValue);
    }
    return propValue;
};

/**
 * Process props object with constants resolve
 *
 * @param {ElemDescriptor['props']} props
 * @return {*}
 */
export const processPropsConst = (props) =>
    Object.entries(props).reduce((acc, [propName, propValue]) => ({
        ...acc,
        [propName]: processPropWithConst(propValue)
    }), {});

/**
 *
 * @param {import('./types').WidgetMetaComponentOption} fromOption
 * @param {import('./types').WidgetMetaComponentOption} toOption
 * @return {import('./types').WidgetMetaComponentOption}
 */
export const mergeWidgetMetaComponentOptionsStrategy = (fromOption = {}, toOption = {}) => {
    const {
        panels: fromPanels = [],
        panelsDefault: fromPanelsDefault = [],
        cssVars: fromCssVars,
        slotNames: fromSlotNames = [],
        isChildAllowed: fromIsChildAllowed,
        descriptor: fromDescriptor,
        ...restFromOptions
    } = fromOption;
    const {
        panels: toPanels = [],
        panelsDefault: toPanelsDefault,
        cssVars: toCssVars,
        slotNames: toSlotNames,
        isChildAllowed: toIsChildAllowed,
        descriptor: toDescriptor,
        ...restToOptions
    } = toOption;

    return {
        panels: [...fromPanels, ...toPanels],
        panelsDefault: toPanelsDefault ?? fromPanelsDefault,
        cssVars: { ...fromCssVars, ...toCssVars },
        slotNames: toSlotNames ?? fromSlotNames,
        isChildAllowed: toIsChildAllowed ?? fromIsChildAllowed,
        descriptor: () => merge(fromDescriptor && fromDescriptor(), toDescriptor && toDescriptor()),
        ...restFromOptions,
        ...restToOptions
    };
};

Vue.config.optionMergeStrategies.meta = mergeWidgetMetaComponentOptionsStrategy;

/**
 * Apply transformations to build actual normalized descriptor format
 * For back-compatibility purposes and shorthand descriptor format to be used
 *
 * @param {ElemDescriptor} descriptor
 * @returns {ElemDescriptor}
 */
export const normalizeDescriptorFormat = (descriptor) => {
    /**
     * checks if descriptor vars defined in alias mode and rebuild to normal
     * alias:
     */
    descriptor.vars = Object.entries(descriptor.vars).reduce((acc, [name, value]) => {
        if (typeof value == 'string') {
            return {
                ...acc,
                [value]:  { description: value }
            }
        }
        return { ...acc, [name]: value }
    }, {});

    return descriptor;
}

export const setReadonlyProp = (object, propName, propValue) => {
    Object.defineProperty(object, propName, {
        value: propValue,
        writable: false
    });
}
