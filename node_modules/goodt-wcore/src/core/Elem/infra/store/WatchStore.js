import { CoreError } from '@goodt-wcore/errors';
import { fail, success } from '@goodt-common/utils';
import { validateWidgetVars } from '../validations';

/**
 * @typedef {import('@goodt-wcore/elem').IElemInstance} ElemInstance
 */

/**
 * Watch store component option name @default 'watchStore'
 */
const WATCH_STORE_COMPONENT_OPTION_NAME = 'watchStore';

/**
 * @type {import('./WatchStore').WatchStoreStrategyEnum}
 */
const WatchStoreStrategy = {
    ANY: 'any',
    ALL: 'all',
    ALL_VARS: 'allVars'
};

/**
 *
 * @param {string[]|null} vars
 * @param {boolean} all
 * @param {import('./WatchStore').WatchStoreHandlerCondition} when
 * @return {import('./WatchStore').WatchStoreStrategy}
 */
const resolveStrategy = ({ vars, all, when }) => {
    if (vars == null) {
        return WatchStoreStrategy.ALL_VARS;
    }
    if (all === true || when === true) {
        return WatchStoreStrategy.ALL;
    }
    return WatchStoreStrategy.ANY;
};

/**
 *
 * @param {WatchStoreDefinition} definition watcher definition
 * @throw {CoreError}
 */
const validateDefinition = (definition, { varAliases, varsDescriptor }) => {
    const unknownProps = Object.keys(definition).filter(
        (prop) => ['id', 'handler', 'vars', 'all', 'when'].includes(prop) === false
    );

    if (unknownProps.length > 0) {
        return fail(
            new CoreError(
                `[watchStore]: INVALID DESCRIPTOR: prop(s) '${unknownProps.join("', '")}' ${
                    unknownProps.length > 1 ? 'are' : 'is'
                } unknown.`
            )
        );
    }

    const { id, handler, vars, all, when } = definition;
    if (id != null && ['string'].includes(typeof id) === false) {
        return fail(new CoreError(`[watchStore]: INVALID DESCRIPTOR FORMAT: 'id' prop type is expected to be String.`));
    }
    if (['function', 'string'].includes(typeof handler) === false) {
        return fail(
            new CoreError(
                `[watchStore]: INVALID DESCRIPTOR FORMAT: 'handler' prop type is expected to be Function or String.`
            )
        );
    }
    if (vars !== null && (Array.isArray(vars) === false || vars.length === 0) && typeof vars !== 'function') {
        return fail(
            new CoreError(
                `[watchStore] section invalid descriptor format: 'vars' type is expected to be non-empty Array<String> or Function`
            )
        );
    }
    if (typeof all !== 'boolean') {
        return fail(
            new CoreError(`[watchStore]: INVALID DESCRIPTOR FORMAT: 'all' prop type is expected to be Boolean`)
        );
    }
    if (['function', 'string', 'boolean'].includes(typeof when) === false && Array.isArray(when) === false) {
        return fail(
            new CoreError(
                `[watchStore] section invalid descriptor format. 'when' prop type is expected to be Function, String,  Boolean, Array<Function>`
            )
        );
    }
    if (vars === null && (all === true || when === true)) {
        return fail(
            new CoreError(
                `[watchStore]: INVALID DESCRIPTOR FORMAT: 'all: true' or 'when: true' prop and empty 'vars' prop can't be used together`
            )
        );
    }

    if (Array.isArray(vars) && vars.length > 0) {
        return validateWidgetVars({
            stateVars: vars,
            descriptorVars: Object.keys(varsDescriptor),
            varAliases: Object.entries(varAliases)
                .filter(([, { listen }]) => listen != null)
                .map(([name]) => name)
        });
    }

    return success(true);
};

/**
 * @param {import('./WatchStore').WatchStoreHandler} handler
 * @param {ElemInstance} vm
 * @return {function(): void}
 */
const resolveHandlerByVm = (handler, vm) =>
    typeof handler === 'function' ? handler.bind(vm) : vm[handler].bind(vm);

/**
 *
 * @param {null|string[]|function(): string[]} vars
 * @param {ElemInstance} vm
 * @return {string[]|null}
 */
const resolveVars = (vars, vm) => {
    return typeof vars === 'function' ? vars.call(vm, vm) : vars;
};

/**
 *
 * @param {import('./WatchStore').WatchStoreHandlerCondition} when vue component reference
 * @param {ElemInstance} vm
 * @return {import('./WatchStore').WatchStoreHandlerCondition}
 */
const resolveWhen = (when, vm) => {
    if (typeof when === 'function') {
        return when.bind(vm);
    }
    if (typeof when === 'string') {
        return vm[when].bind(vm);
    }
    return when;
};

/**
 * Resolves state
 *
 * @param {string[]|function():string[]|null} vars
 * @param {Record<string, any>} storeState
 * @param {import('@goodt-wcore/elem').IElemInstance} vm
 * @return {Record<string, any>}
 */
// prettier-ignore
const resolveState = (vars, storeState) => {
    if (vars === null) {
        return storeState;
    }
    return vars
        .reduce((acc, varName) => ({
            ...acc,
            [varName]: storeState[varName]
        }), {});
}

/**
 * Checks if all values are meeting all conditions
 *
 * @param {any[]} values
 * @param state
 * @param {(function(values: any[]): boolean) | Array<function(values: any[]): boolean>} conditions
 * @return {boolean}
 */
// prettier-ignore
const isMeetConditions = (values, state, conditions) => []
    .concat(conditions)
    .filter((condition) => typeof condition === 'function')
    .every((isMeetCondition) => isMeetCondition(values, state));

/**
 * Build a 'state' object using 'vars' as keys, even if values are 'undefined'
 * always invoke handler (just like vue does)
 *
 * @example
 * // $storeState: { foo: 1 }
 * // vars: ['foo', 'bar']
 * // state: { foo:1, bar:undefined }
 *
 * @param {ElemInstance} vm              vue component reference
 * @param {string[]|null} vars           vars list or null
 * @param {import('./WatchStore').WatchStoreHandlerCondition} when vue component reference
 * @param {import('./WatchStore').WatchStoreHandler} handler watcher definition
 * @return void
 */
const defaultBehaviourHandler = (vm, { vars, when, handler }) => {
    const resolvedVars = resolveVars(vars, vm);
    // if "vars" is a function and returns empty list [] – not apply handler
    if (typeof vars === 'function' && resolvedVars?.length === 0) {
        return;
    }

    const state = resolveState(resolvedVars, vm.$storeState);

    const values = Object.values(state);
    if (isMeetConditions(values, state, when)) {
        // vm.$nextTick(() => handler(values, state));
        handler(values, state);
    }
}

const WatchStoreStratFactory = {
    /**
     * Build a 'state' object using 'vars' as keys, even if values are 'undefined'
     * always invoke handler (just like vue does)
     *
     * @example
     * // $storeState: { foo: 1 }
     * // vars: ['foo', 'bar']
     * // state: { foo:1, bar:undefined }
     *
     * @param {ElemInstance} vm              vue component reference
     * @param {string[]|null} vars           vars list or null
     * @param {import('./WatchStore').WatchStoreHandlerCondition} when vue component reference
     * @param {import('./WatchStore').WatchStoreHandler} handler watcher definition
     * @return {function(): void}            return strat handler
     */
    [WatchStoreStrategy.ANY](vm, { vars, when, handler }) {
        return () => {
            // eslint-disable-next-line no-param-reassign
            when = resolveWhen(when, vm);
            defaultBehaviourHandler(vm, { vars, when, handler });
        };
    },

    /**
     * Builds a 'state' object using 'vars' as keys, only if values are not 'undefined'
     * invoke handler only if all 'vars' keys are present in the 'state'
     *
     * @example
     * $storeState: { foo: 1 }
     * vars: ['foo', 'bar']
     * state: { foo:1 }
     *
     * @param {ElemInstance} vm              vue component reference
     * @param {string[]|null} vars           vars list or null
     * @param {import('./WatchStore').WatchStoreHandlerCondition} when vue component reference
     * @param {import('./WatchStore').WatchStoreHandler} handler watcher definition
     * @return {function(): void}            return strat handler
     */
    [WatchStoreStrategy.ALL](vm, { vars, handler, when }) {
        return () => {
            // eslint-disable-next-line no-param-reassign
            when = [
                // mandatory condition for `all` strategy
                (varValues) => varValues.every((value) => value !== undefined),
                ...[resolveWhen(when, vm)].flat()
            ];
            defaultBehaviourHandler(vm, { vars, when, handler });
        };
    },
    /**
     * Builds a 'state' object using 'vars' as keys, only if values are not 'undefined'
     * invoke handler only if all 'vars' keys are present in the 'state'
     *
     * @example
     * $storeState: { foo: 1 }
     * vars: ['foo', 'bar']
     * state: { foo:1 }
     *
     * @param {ElemInstance} vm              vue component reference
     * @param {string[]|null} vars           vars list or null
     * @param {import('./WatchStore').WatchStoreHandlerCondition} when vue component reference
     * @param {import('./WatchStore').WatchStoreHandler} handler watcher definition
     * @return {function(): void}            return strat handler
     */
    [WatchStoreStrategy.ALL_VARS](vm, { handler }) {
        return () => {
            handler(Object.values(vm.$storeState), vm.$storeState);
        };
    },
};

/**
 *
 * @param {import('./WatchStore').WatchStoreStrategy} strategy
 * @return {*}
 */
const useWatchStoreStrategyWatcher = (strategy) => {
    const watcher = WatchStoreStratFactory[strategy];
    if (watcher == null) {
        throw new CoreError(
            `Watch store strategy '${strategy}' not implemented. Check your component '${WATCH_STORE_COMPONENT_OPTION_NAME}' options`
        );
    }
    return watcher;
};

/**
 * Creates a new watcher, which watches 'vars' keys in '$storeState'
 * @param {ElemInstance} vm                                 vue component reference
 * @param {WatchStoreDefinition} definition                 watcher definition
 * @param {import('vue').WatchOptions} watchOptions         watcher options
 *
 * @return {function(): void} watcher disposal function
 */
const createStoreWatcher = (vm, definition, watchOptions = { immediate: true }) => {
    const { id, all = false, vars = null, handler, when = false } = definition;
    // eslint-disable-next-line no-const-assign

    const {
        descriptor: { vars: varsDescriptor },
        props: { varAliases }
    } = vm;

    const { isError, error: problems } = validateDefinition(
        { ...definition, all, vars, when },
        {
            varAliases,
            varsDescriptor
        }
    );
    if (isError) {
        [problems].flat().forEach((error) => {
            vm.handleError(error, {
                scope: 'watchStore'
            });
        });
    }

    // stringify as 'state' is always a new object
    // prettier-ignore
    const changesResolver = () => {
        const resolvedVars = resolveVars(vars, vm) ?? [];
        const varNames = typeof vars === 'function' ? resolvedVars : [];
        return JSON.stringify(
            // use 'vars' keys from '$storeState' || use all keys from '$storeState'
            vars === null
                ? vm.$storeState
                : resolvedVars.map((key) => vm.$storeState[key]).concat(varNames)
        );
    }

    const createWatcherHandler = useWatchStoreStrategyWatcher(resolveStrategy({ vars, all, when }));
    const watcherHandler = createWatcherHandler(vm, {
        id,
        vars,
        handler: resolveHandlerByVm(handler, vm),
        when
    });

    // prettier-ignore
    const watcherDisposal = vm.$watch(
        changesResolver,
        // используем откладывание $nextTick в связи с
        // watch.immediate = true, чтобы ДС-хук компонента успел произойти
        // и были доступны возможно создающиеся там значения свойств контекста компонента,
        // которые могут быть использованы в handler
        () => vm.$nextTick(watcherHandler),
        watchOptions
    );

    return {
        watcherDisposal,
        watcherHandler
    };
};

/**
 * Allows creating a stateWatcher dynamically
 * @param {WatchStoreDefinition} def watcher definition
 * @return {function(): void} watcher disposal function
 */
export function watchStore({ id, handler, vars, all = false, when = false }) {
    return createStoreWatcher(this, { id, handler, vars, all, when });
}

/**
 * Automatically creates '$storeState' watchers defined in the '#WATCH_STORE_COMPONENT_OPTION_NAME' block of the target 'vm'
 * @param {ElemInstance} vm target component
 * @return {{ disposals: function[], $watchStore: function }}
 */

export const useWatchStore = (vm) => {
    /** @type {WatchStoreDefinition[]} */
    const defs = vm.$options[WATCH_STORE_COMPONENT_OPTION_NAME] ?? [];
    const { disposals, handlersMap } = defs
        .map((def) => ({ ...createStoreWatcher(vm, def), id: def.id }))
        .reduce(
            (acc, { watcherDisposal, watcherHandler, id }) => {
                // eslint-disable-next-line no-shadow
                const { disposals, handlersMap } = acc;
                disposals.push(watcherDisposal);
                if (id != null) {
                    handlersMap.set(id, watcherHandler);
                }
                return acc;
            },
            { disposals: [], handlersMap: new Map() }
        );

    const $watchStore = watchStore.bind(vm);

    /**
     *
     * @param {WatchStoreDefinition['id']} id
     */
    $watchStore.applyWatcher = (id) => {
        if (handlersMap.has(id)) {
            handlersMap.get(id).call();
        }
    };

    return {
        disposals,
        $watchStore
    };
};
