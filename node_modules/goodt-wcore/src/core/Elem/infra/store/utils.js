/**
 * @todo: Possibly move functionality close to presentation level,
 * @todo to `useStore`'s structure / store's $storeState $storeCommit responsibility holder/provider
 */
import { CoreWarning } from '@goodt-wcore/errors';
import { fail, success } from '@goodt-common/utils';
import { buildStoreValue as buildStoreValueDefault, unwrapStoreValue as unwrapStoreValueDefault } from '@goodt-wcore/managers';
import { ArrayOfType } from './ArrayOfType';

/**
 * @typedef {import('@goodt-wcore/managers').ValueObject} ValueObject
 * @typedef {import('@goodt-wcore/managers').StoreElemState} StoreElemState
 * @typedef {import('@goodt-wcore/managers').StoreGlobalState} StoreGlobalState
 */
/**
 *
 * @param {VarDescriptor['type']} type
 * @param {any} value
 * @returns {any}
 */
export const ensureTypeDefault = (type, value) => {
    if (type == null) {
        return value;
    }
    if (type === Array) {
        return [value].flat();
    }
    if (type instanceof ArrayOfType) {
        return [value].flat().map((_value) => ensureTypeDefault(type.type, _value));
    }
    if (value instanceof Array) {
        return ensureTypeDefault(type, value[0]);
    }
    if (typeof type === 'function') {
        return type(value);
    }
    return value;
};

/**
 *
 * @param {StoreGlobalState} externalState
 * @param {ElemDescriptorVarAliasesMap} [varAliases=null]
 * @param {ElemDescriptorVarMetasMap} [varsDescriptor={}]
 * @param {function} [unwrapStoreValue]
 * @return {StoreElemState}
 */
export const buildInternalStateFromExternal = (
    { externalState, varAliases = null, varsDescriptor = {} },
    { unwrapStoreValue = unwrapStoreValueDefault } = {}
) => {
    if (varAliases === null) {
        return Object.entries(externalState).reduce(
            (state, [varName, varValueObject]) => ({
                ...state,
                [varName]: unwrapStoreValue(varValueObject)
            }),
            {}
        );
    }

    const internalState = Object.entries(varAliases).reduce((state, [varName, varAliasData]) => {
        const { listen: alias } = varAliasData;
        if (alias == null || String(alias).length === 0) {
            return state;
        }
        if (alias in externalState) {
            const varValueObject = externalState[alias];
            return {
                ...state,
                [varName]: unwrapStoreValue(varValueObject)
            };
        }

        return state;
    }, {});

    return internalState;
};

/**
 *
 * @param {StoreElemState} widgetState
 * @param {ElemDescriptorVarMetasMap} [varsDescriptor={}]
 * @return {StoreElemState}
 */
export const ensureStateTypes = (widgetState, { varsDescriptor }) => {
    const ensuredState = Object.entries(widgetState).reduce((state, [varName, varValue]) => {
        const type = varsDescriptor[varName]?.type;
        if (type == null) {
            return {
                ...state,
                [varName]: varValue
            };
        }
        const targetVarValue = ensureTypeDefault(type, varValue);
        return {
            ...state,
            [varName]: targetVarValue
        };
    }, {});

    return ensuredState;
};

/**
 *
 * @param {StoreElemState} originalState
 * @param {StoreElemState} ensuredState
 * @param varsDescriptor
 * @return {SafeResult<null, CoreWarning[]>}
 */
export const validateStateTypes = (originalState, ensuredState, { varsDescriptor }) => {
    const errors = Object.entries(originalState).reduce((acc, [varName, varValue]) => {
        if (varsDescriptor[varName] == null || ensuredState[varName] == null) {
            return acc;
        }
        let varDescriptorType = (typeof ensuredState[varName]).toLowerCase();

        const { strict = false } = varsDescriptor[varName];
        if (strict === false) {
            return acc;
        }

        let storeType = (typeof varValue).toLowerCase();
        if (storeType !== varDescriptorType) {
            if (Array.isArray(varValue)) {
                storeType = 'array';
            }
            if (Array.isArray(ensuredState[varName])) {
                varDescriptorType = 'array';
            }
            acc.push(
                new CoreWarning(
                    `[Store]: typeof this.$storeState['${varName}'] is "${storeType}" !== descriptor.vars['${varName}'].type is "${varDescriptorType}")`,
                    {
                        reason: {
                            storeValue: varValue,
                            expectedValue: ensuredState[varName]
                        }
                    }
                )
            );
            return acc;
        }
        if (varDescriptorType !== 'object') {
            return acc;
        }
        if (ensuredState[varName].constructor.name !== varValue.constructor.name) {
            acc.push(
                new CoreWarning(
                    `[Store]: typeof this.$storeState['${varName}'] is "${varValue.constructor.name.toLowerCase()}" !== descriptor.vars['${varName}'].type is "${ensuredState[
                        varName
                    ].constructor.name.toLowerCase()}")`,
                    {
                        reason: {
                            storeValue: varValue,
                            expectedValue: ensuredState[varName]
                        }
                    }
                )
            );
            return acc;
        }
        if (Array.isArray(varValue)) {
            const invalidTypeValue = varValue.find((value) => typeof value !== typeof ensuredState[varName][0]);
            if (invalidTypeValue != null) {
                acc.push(
                    new CoreWarning(
                        `[Store]: typeof this.$storeState['${varName}'] "${typeof invalidTypeValue}[]" !== descriptor.vars['${varName}'].type is "${typeof ensuredState[
                            varName
                        ][0]}[]")`,
                        {
                            reason: {
                                storeValue: varValue,
                                expectedValue: ensuredState[varName]
                            }
                        }
                    )
                );
                return acc;
            }
        }

        return acc;
    }, []);

    return errors.length > 0 ? fail(errors) : success(null);
};

/**
 * @param {StoreElemState} internalState
 * @param {ElemDescriptorVarAliasesMap} [varAliases=null]
 * @param {ElemDescriptorVarMetasMap} [varsDescriptor={}]
 * @param {function} [buildStoreValue]
 * @return {StoreGlobalState}
 */
export const buildExternalStateFromInternal = (
    { internalState, varAliases = null, varsDescriptor = {} },
    { buildStoreValue = buildStoreValueDefault } = {}
) => {
    if (varAliases === null) {
        const externalState = Object.entries(internalState).reduce(
            (state, [varName, varValue]) => ({
                ...state,
                [varName]: buildStoreValue(varValue)
            }),
            {}
        );

        return externalState;
    }

    const externalState = Object.entries(internalState).reduce((state, [varName, varValue]) => {
        const { trigger: alias, meta } = varAliases[varName] || {};

        if (alias != null && String(alias).length > 0) {
            return {
                ...state,
                [alias]: buildStoreValue(varValue, meta)
            };
        }

        return state;
    }, {});

    return externalState;
};

export { useWatchStore } from './WatchStore';
