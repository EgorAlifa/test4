import Vue from 'vue';
import { get as getByPath, difference } from 'lodash';
import { CoreError } from '@goodt-wcore/errors';

const isRequiredValid = ([prop, value]) => {
    if ([null, '', undefined].includes(value)) {
        setTimeout(() => {
            throw new CoreError(`'${prop}' key is required in 'subscribe' descriptor`);
        });
        return false;
    }
    return true;
};

const isValidEventListenDescriptor = ({ event, handler }) => {
    // prettier-ignore
    return [
        [ 'event', event ],
        [ 'handler', handler ]
    ].every(isRequiredValid);
};

const resolveAddedAndDeleted = (arrayA, arrayB) => [
    difference(arrayA, arrayB),
    difference(arrayB, arrayA)
];

/**
 *
 * @param {string|null|undefined|string[]} arrayOrSingle
 * @return {FlatArray<*[], 1>[]}
 */
const buildNotNullValuesList = (arrayOrSingle) => [arrayOrSingle].flat().filter((value) => value != null);

/**
 *
 * @param {string} eventName
 * @return {`__${string}`}
 */
const resolvePrivateDescriptorEventName = (eventName) => `__${eventName}`;

/**
 * This is for runtime event subscribe.
 * Patch "descriptor.events" with runtime changing events
 * to be available for EventsPanel
 * {
 *     event() {
 *         return this.props.runtimeEvents;
 *     },
 *     handler() {
 *         /.../
 *     }
 * }
 * @param {import('@goodt-wcore/elem').IElemInstance} vm
 * @return {(function(newEventTypes: string[], oldEventTypes?: ?string[]): void)}
 */
const createDescriptorEventsPatcher = (vm) => {
    const {
        descriptor: { events: descriptorEvents }
    } = vm;

    return (newEventTypes, oldEventTypes = null) => {
        // eslint-disable-next-line no-param-reassign, id-length
        newEventTypes = buildNotNullValuesList(newEventTypes);
        // eslint-disable-next-line no-param-reassign, id-length
        oldEventTypes = buildNotNullValuesList(oldEventTypes);

        // eslint-disable-next-line no-param-reassign
        const [addingEventTypes, removingEventTypes] = resolveAddedAndDeleted(
            newEventTypes,
            oldEventTypes
        );
        removingEventTypes.forEach((eventName) => {
            const privateEventName = resolvePrivateDescriptorEventName(eventName);
            if (descriptorEvents[privateEventName] != null) {
                delete descriptorEvents[privateEventName];
            }
        });
        // adding event data (listen) to "descriptor.events" to be available to show in "EventsPanel"
        addingEventTypes.forEach((eventName) => {
            const privateEventName = resolvePrivateDescriptorEventName(eventName);
            // write event data (listen) under key "eventName" with private prefix "__" to
            // avoid overriding user defined events in "descriptor.events" section
            if (descriptorEvents[privateEventName] == null) {
                descriptorEvents[privateEventName] = {
                    listen: eventName
                };
            }
        });
    };
}

// eslint-disable-next-line no-param-reassign
const createSubscribeWatcher = (vm, { handler, once }) => {
    let unsubscribe = () => {};
    return (_eventNameOrAlias) => {
        // we might not have an actual event to subscribe to
        unsubscribe();
        if ([null, '', undefined].includes(_eventNameOrAlias)) {
            return;
        }
        // vm.$eventBus.unlisten(_eventNameOrAlias, handler);
        unsubscribe = vm.$eventListen(_eventNameOrAlias, handler, once);
    };
};

/**
 *
 * @param {import('@goodt-wcore/elem').IElemInstance} vm
 * @param {function} handler
 * @param {boolean} once
 *
 * @return {(function(newEventTypes: (null|undefined|string|string[]), oldEventTypes?: (null|undefined|string|string[])): void)} */
const createEventSubscriber =
    (vm, { handler, once }) =>
    (newEventTypes, oldEventTypes = null) => {
        // eslint-disable-next-line no-param-reassign, id-length
        newEventTypes = buildNotNullValuesList(newEventTypes);
        // eslint-disable-next-line no-param-reassign, id-length
        oldEventTypes = buildNotNullValuesList(oldEventTypes);
        const [addingEventTypes, removingEventTypes] = resolveAddedAndDeleted(newEventTypes, oldEventTypes);

        removingEventTypes.forEach((eventType) => {
            vm.$eventBus.unlisten(eventType, handler);
        });
        addingEventTypes.forEach((eventType) => {
            const subscribe = createSubscribeWatcher(vm, { handler, once });
            subscribe(eventType);
        });
 };

/**
 * @param {import('@goodt-wcore/elem').IElemInstance} vm
 * @param $eventBus
 */
export const useSubscribeEventBus = (vm, $eventBus) => {
    const {
        $options: { subscribe: descriptors }
    } = vm;

    if (Array.isArray(descriptors) === false || descriptors.length === 0) {
        return;
    }

    const { subscribe: originalSubscribe } = vm;
    // re-assign Elem*.subscribe() method,
    // keep and call original subscribe() method
    //  eslint-disable-next-line no-param-reassign
    vm.subscribe = () => {
        originalSubscribe.call(vm);
        const patchDescriptorEvents = createDescriptorEventsPatcher(vm);

        descriptors.forEach(({ event, handler, once }) => {
            if (isValidEventListenDescriptor({ event, handler }) === false) {
                return;
            }
            // eslint-disable-next-line no-param-reassign
            handler = handler.bind(vm);
            const subscribeEvents = createEventSubscriber(vm, { handler, once });

            let eventNameOrAlias = event;
            if (typeof eventNameOrAlias === 'function') {
                // eslint-disable-next-line no-param-reassign
                eventNameOrAlias = eventNameOrAlias.call(vm, vm);
                patchDescriptorEvents(eventNameOrAlias);
            }

            subscribeEvents(eventNameOrAlias);

            if (vm.isEditorMode === false) {
                return;
            }

            if (typeof event === 'function') {
                vm.$watch(
                    event.bind(vm, vm),
                    (newEvents, oldEvents) => {
                        patchDescriptorEvents(newEvents, oldEvents);
                        subscribeEvents(newEvents, oldEvents);
                    }
                );
                return;
            }
            [eventNameOrAlias].flat().forEach((alias) => {
                // watch and re-subscribe
                const eventNameSource = vm.$eventBus.getEventTypeResolver(alias);
                if (eventNameSource == null) {
                    throw new CoreError(
                        `[EventBus]: Elem.subscribe section descriptor "{ event: '${alias}', ... }" has no descriptor.events['${alias}'] mapping`
                    );
                }
                // eslint-disable-next-line no-shadow
                vm.$watch(eventNameSource, subscribeEvents);
            });
        });
    };
};

/**
 *
 * @param {import('@goodt-wcore/elem').IElemInstance} vm
 */
export const registerEventBusEventTypeResolvers = (vm) => {
    /**
     * registers widget local eventType resolvers – aliases
     */
    Object.entries(vm.descriptor.events ?? {}).forEach(([eventType, descriptor]) => {
        const resolvers = [];

        if (Array.isArray(descriptor)) {
            // if is array specified => accessor name in props.events is equal to `eventType`
            // =>  props.events[eventType]
            resolvers.push(() => getByPath(vm.props.events, eventType));
        } else if (typeof descriptor === 'object') {
            // to abstract `listen`, `trigger` prop names
            const accessor = Object.values(descriptor).pop();
            const resolver = () => getByPath(vm.props, accessor);
            resolvers.push(resolver);
        }

        resolvers.forEach((resolver) => {
            vm.$eventBus.setEventTypeResolver(eventType, resolver);
        });
    });
};

export class FakeEventBusWrapper {
    listen() {
        throw new CoreError('Usage of this.eventBusWrapper.listen now is DISABLED – use Elem.$eventListen / Elem.subscribe section instead (https://gitlab.goodt.me/goodt/docs/-/blob/main/docs/widget/elem/guide/eventbus.md)');
    }

    trigger() {
        throw new CoreError('Usage of this.eventBusWrapper.trigger now is DISABLED – use Elem.$eventTrigger method instead (https://gitlab.goodt.me/goodt/docs/-/blob/main/docs/widget/elem/guide/eventbus.md)');
    }
}

const mergeSubscribeOptionStrategy = (from = [], to = []) => [...from, ...to];

Vue.config.optionMergeStrategies.subscribe = mergeSubscribeOptionStrategy;
