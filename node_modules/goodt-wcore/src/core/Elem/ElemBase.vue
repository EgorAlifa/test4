<script>
import { cloneDeep } from 'lodash';
import { WidgetDebugMessage } from '@goodt-wcore/errors';
import { RouteManager, useEventBus, EventBusWrapper, store } from '@goodt-wcore/managers';
import { useWatchWhenMixin, useComputedWhenMixin, widget } from '@goodt-wcore/utils';
import { StylePanelAsync, EventPanelAsync, VariablePanelAsync } from '@goodt-wcore/panels';

import {
    dispatchEventByName,
    getDescriptorDefaultProps,
    patchComponentRootDomElement,
    unobserve,
    buildCssVarsStyle,
    buildCssVars,
    $c,
    processPropsConst,
    useSubscribeEventBus,
    FakeEventBusWrapper,
    registerEventBusEventTypeResolvers,
    normalizeDescriptorFormat,
    setReadonlyProp,
    createElemStoreMeta,
    buildExternalStateFromInternal,
    buildInternalStateFromExternal,
    ensureStateTypes,
    useWatchStore,
    resolvePropsDif,
    mergeProps
    // useGuards
} from './infra';


import { WidgetContainer } from './components';

import { descriptor } from './descriptor';
import { ElemEvent, PropsToClassMap, ELEM_ROOT_NODE_DOM_CLASS_NAME } from './infra/config';

export const ComponentOptions = {
    __name: 'Elem',
    mixins: [useWatchWhenMixin(), useComputedWhenMixin()],
    components: {
        WElem: WidgetContainer
    },
    /**
     * A short and more declarative way to declare widget panels
     */
    meta: {
        descriptor,
        panels: [],
        panelsDefault: [
            StylePanelAsync,
            EventPanelAsync,
            VariablePanelAsync
        ],
        cssVars: {},
        isChildAllowed: true,
        slotNames: ['default']
    },
    provide() {
        return {
            $widget: widget(this)
        };
    },
    inject: ['$errorService'],
    props: {
        /** uniq instance id */
        id: {
            type: String,
            default: ''
        },
        /** elem fulltype @example 'Ns/SubNs/ElemExample' */
        type: {
            type: String,
            default: ''
        },
        /** elem props defined in ElemDescriptor */
        initProps: {
            type: Object,
            default() {
                return {};
            }
        },
        /** slot scope data if component is inside scoped slot of the parent component */
        slotData: {
            type: Object,
            default() {
                return {};
            }
        }
    },
    data() {
        return {
            /** css-class def object */
            cssClass: {},
            /** css-style def object */
            cssStyle: {},
            /** default slot name (used in editor env by dnd) */
            slotDefault: 'default',
            /** @type {ElemDescriptor} */
            descriptor: this.meta.descriptor()
        };
    },
    computedEditor: {
        /**
         * @return {object}
         */
        propsDefault() {
            return getDescriptorDefaultProps(this.descriptor);
        },
        /**
         * Merged props
         * @return {object}
         */
        props() {
            const initProps = cloneDeep(this.initProps);
            const props = mergeProps(this.propsDefault, initProps);

            return this.processPropsConst(props);
        },
        /**
         * Css variables (static, auto-generated from descriptor)
         * @return {object}
         */
        $cssVarsStatic() {
            const {
                props,
                descriptor: { cssVars: descriptorCssVars },
                meta: { cssVars: metaCssVars } = {}
            } = this;
            // prettier-ignore
            return buildCssVars({
                ...descriptorCssVars,
                ...metaCssVars
            }, props);
        },
        /** css variables style object */
        $cssVarsStyle() {
            return this.$genCssVarsStyle(this.$cssVarsStatic);
        },
        /**
         *
         * @returns {boolean}
         */
        isDebugMode() {
            return this.$root.constructor.config.silent === false;
        }
    },
    computed: {
        /**
         * Returns the current store state
         * @return {StoreElemState} state
         */
        $storeState() {
            const { state: externalState } = store;
            const [, internalStateWithEnsuredTypes] = this.buildInternalStateFromExternal(externalState);

            return internalStateWithEnsuredTypes;
        },
        /**
         * Returns the current route
         *
         * @return {import('../managers/RouteManager').RouteObject} current route object
         */
        $routeCurrent() {
            return RouteManager.instance.route;
        },
        /**
         *
         * @returns {boolean}
         */
        isEditorMode() {
            return this.$root.isEditorMode;
        }
    },
    watch: {
        descriptor: {
            handler: normalizeDescriptorFormat,
            immediate: true
        }
    },
    /*
     * hook, that is called after construction of the widget's component
     */
    constructed() {
        // ... to be implemented
    },
    beforeCreate() {
        this.meta = this.$options.meta;
        // useGuards(this);
        this.$storeMeta = createElemStoreMeta(this);
        // starts watching Global Store.state
    },
    /**
     * @this {import('./Elem').IElemInstance}
     */
    created() {
        // whenever css-vars change -> invoke getCssStyle()
        this.$watch('$cssVars', this.genCssStyle, { immediate: true });

        if (this.isEditorMode) {
            this.$watch('props.cssClass', this.genCssClass, { immediate: true });
            this.$watch('props.cssStyle', this.genCssStyle, { immediate: true });
            this.$watch('$cssVarsStatic', this.genCssStyle, { immediate: true });
        } else {
            this.genCssClass();
            unobserve([this.descriptor, this.$props, this.cssClass, this.cssStyle]);
        }

        // starts watching Global Store.state
        const { $watchStore } = useWatchStore(this);
        // this.$watchStore = $watchStore;
        setReadonlyProp(this, '$watchStore', $watchStore);

        const { eventBus } = useEventBus();
        this.setEventBus(eventBus);

        // emit 'created' event via vue/dom
        dispatchEventByName.call(this, ElemEvent.CREATED);
    },
    /**
     * @this {import('./Elem').IElemInstance}
     */
    mounted() {
        this._mounted();
    },
    /**
     * @this {import('./Elem').IElemInstance}
     */
    beforeDestroy() {
        // teardown eventbus wrapper
        this.$eventBus.dispose();
        // emit 'destroyed' event via vue/dom
        dispatchEventByName.call(this, ElemEvent.DESTROYED);
    },
    methods: {
        /**
         * Super method call helper, allows calling super methods when using extends/mixins
         *
         * @example this.super(ComponentOptions).method.call(this)
         * @param {?any} [componentOptions=ComponentOptions]  component options
         * @param {boolean} [mixins=true]
         * @param {boolean} [parent=true]
         * @return {Record<string, any>}  methods list
         */
        super(componentOptions, { mixins: useMixins = true, parent: useParent = true } = {}) {
            if (componentOptions == null) {
                // eslint-disable-next-line no-param-reassign
                componentOptions = ComponentOptions;
            }
            const extractMixinMethods = (_mixins) => _mixins
                ? _mixins.flatMap(({ methods = {}, mixins }) => [...extractMixinMethods(mixins), methods])
                : [];

            const extractParentMethods = ({ methods = {}, extends: parent, mixins } = {}) =>
                [
                    ...(parent != null ? extractParentMethods(parent) : []),
                    ...extractMixinMethods(mixins),
                    methods
                ];

            const methods = [
                ...(useParent === true ? extractParentMethods(componentOptions.parent) : []),
                ...(useMixins === true ? extractMixinMethods(componentOptions.mixins) : []),
                componentOptions.methods
            ];

            return Object.assign({}, ...methods);
        },
        /**
         * Generates css-class def
         */
        genCssClass() {
            const { props } = this;
            const classMap = {
                [ELEM_ROOT_NODE_DOM_CLASS_NAME]: true
            };
            // prettier-ignore
            [ 'display', 'position', 'cssClass' ].forEach((propName) => {
                [].concat(props[propName])
                    .filter(Boolean)
                    .forEach((propValue) => {
                        classMap[propValue] = true;
                    });
            });
            PropsToClassMap.forEach((classPrefix, propName) => {
                const { [propName]: value } = props;
                if (value) {
                    classMap[`${classPrefix}-${value}`] = true;
                }
            });
            if (props.widthUnit === '' && props.width !== '') {
                classMap[`w-${props.width}`] = true;
            }

            this.$set(this, 'cssClass', classMap);

            return classMap;
        },
        /**
         * Generates css-style def
         */
        genCssStyle() {
            const cssStyle = { ...this.props.cssStyle };
            if (this.props.widthUnit !== 'size' && !Number.isNaN(this.props.width) && this.props.width !== '') {
                cssStyle.width = `${this.props.width}${this.props.widthUnit}`;
            }
            if (!Number.isNaN(this.props.height) && this.props.height !== '') {
                cssStyle.height = `${this.props.height}${this.props.heightUnit}`;
            }
            this.$set(this, 'cssStyle', {
                ...this.$cssVarsStyle,
                ...cssStyle
            });
        },
        /**
         * Build css-vars-style object from css var to prop mapping
         *
         * @param {Record<string, string|[string, string]|function(): string>} cssVarsMapping
         * @param {Record<string, any>} props
         * @return {Record<string, string>}
         */
        $buildCssVarsStyle(cssVarsMapping, props = this.props) {
            return this.$genCssVarsStyle(buildCssVars(cssVarsMapping, props));
        },
        /**
         * Build css-vars-style object from css var name to css prop value hash map
         */
        $genCssVarsStyle: buildCssVarsStyle,
        /**
         * Returns component slot names
         *
         * @NOTE <slot></slot> without name have a 'default' name
         * @public
         * @return {Array}
         */
        getSlotNames() {
            // eslint-disable-next-line goodt-rules/no-long-prop-chains
            if (typeof this.meta.slotNames === 'function') {
                return this.meta.slotNames.call(this, this);
            }
            return this.meta.slotNames;
        },
        /**
         * Returns panel components list (used by the editor env)
         * @public
         * @return {import('vue/types/options').AsyncComponentPromise[]}   list of panel components
         */
        getPanels() {
            return [];
        },
        /**
         * Returns true if component accepts children (used by the editor env, dnd)
         *
         * @param {string} type     elem fulltype to test @example 'Ns/SubNs/ElemExample'
         * @return {boolean}        true if 'type' child is allowed
         */
        isChildAllowed(type) {
            if (typeof this.meta.isChildAllowed === 'function') {
                return this.meta.isChildAllowed.call(this, type, this);
            }
            return this.meta.isChildAllowed;
        },
        /**
         * Creates a new event bus wrapper
         * @invoked after @see ElemEvent.MOUNTED
         * @param {import('../managers').EB.EventBus} eventBus
         */
        setEventBus(eventBus) {
            if (this.$eventBus != null) {
                return;
            }
            // eslint-disable-next-line no-multi-assign
            const $eventBus = new EventBusWrapper(eventBus, {
                context: {
                    id: this.id,
                    type: this.type
                },
                // provide compatibility handlers for legacy
                // eventBus methods: listenStateChange, triggerStateChange
                // listenNavigate, triggerNavigate
                listenStateChange: (delegate, { global = false } = {}) => {
                    if (global === false) {
                        return this.$watchStore({
                            handler(_, state) {
                                delegate(state);
                            }
                        });
                    }
                    return this.$watch(
                        () => store.state,
                        (externalState) => {
                            const internalState = this.buildInternalStateFromExternal(externalState, { hasMap: false });
                            delegate(internalState);
                        }
                    );
                },
                triggerStateChange: (internalState, { global = false } = {}) =>
                    this.$storeCommit(internalState, { hasMap: global === false }),
                listenRouteNavigate: (delegate) => this.$watch('$routeCurrent', delegate),
                triggerRouteNavigate: ({ url: path, params: query }) => this.$routeNavigate({ path, query })
            });

            // to force stop using eventBusWrapper
            setReadonlyProp(this, '$eventBus', $eventBus);

            if (this.$root.$options.sandbox != null) {
                setReadonlyProp(this, 'eventBusWrapper', new FakeEventBusWrapper());
            } else {
                setReadonlyProp(this, 'eventBusWrapper', $eventBus);
            }

            registerEventBusEventTypeResolvers(this);
            this.$nextTick(() => this.subscribe());
            useSubscribeEventBus(this);
        },
        /**
         * Transforms 'internalStatePartial' object to Object.< string, ValueObject>
         * and commits internalStatePartial to the store's state
         *
         * @param {Record<string, any>} internalStatePartial
         * @param {boolean} [global=false]
         * @param {boolean|null} [hasMap=true]
         * @param {boolean} [validate=true] if internalStatePartial should be validated with varAliases & descriptor.vars
         */
        $storeCommit(internalStatePartial, { global = false, hasMap = null, validate = true } = {}) {
            const externalStatePartial = this.buildExternalStateFromInternal(internalStatePartial, {
                // transitive compatibility mode to support old { global } and new { hasMap } `$storeCommit` method interface
                // @todo remove `global` param on `$storeCommit` usages refactored
                // @todo add default value `hasMap = true`
                hasMap: hasMap === null ? global === false : hasMap,
                validate
            });
            // don't commit if obj is empty
            if (Object.keys(externalStatePartial).length > 0) {
                store.commit(externalStatePartial, { context: this });
            }
        },
        /**
         *
         * @param {import('@goodt-wcore/managers').StoreElemState} internalState
         * @param {boolean} [hasMap=true]
         * @param {boolean} [validate=true]
         * @param {function(value: any): any} buildExternalStateValue
         * @return {import('@goodt-wcore/managers').StoreGlobalState}
         */
        buildExternalStateFromInternal(
            internalState,
            { hasMap = true, validate = true, buildExternalStateValue } = {}
        ) {
            const { vars: varsDescriptor } = this.descriptor;
            const varAliases = hasMap ? this.props.varAliases : null;

            const externalState = buildExternalStateFromInternal(
                {
                    internalState,
                    varAliases,
                    varsDescriptor
                },
                { buildStoreValue: buildExternalStateValue }
            );

            return externalState;
        },
        /**
         *
         * @param {StoreGlobalState} externalState
         * @param {boolean} hasMap
         * @return {[StoreElemState, StoreElemState]}
         */
        buildInternalStateFromExternal(externalState, { hasMap = true } = {}) {
            const { vars: varsDescriptor } = this.descriptor;
            const { varAliases } = this.props;

            const internalState = buildInternalStateFromExternal({
                externalState,
                varAliases: hasMap ? varAliases : null,
                varsDescriptor
            });
            const internalStateWithEnsuredTypes = ensureStateTypes(internalState, { varsDescriptor });

            return [internalState, internalStateWithEnsuredTypes];
        },
        /**
         /**
         * Requests a route change by path
         *
         * @param {import('../managers/RouteManager').NavigateOptions} options
         * @param {boolean} hasMap
         */
        $routeNavigate({ path, query = {} }, { hasMap = false } = {}) {
            if (hasMap) {
                // eslint-disable-next-line no-param-reassign
                query = this.buildExternalStateFromInternal(query, {
                    hasMap,
                    // build value "as is"
                    buildExternalStateValue: (x) => x
                });
            }
            RouteManager.instance.navigate({ path, query });
        },
        $c,
        /**
         * LC stage, called by the env after 'mounted()'
         */
        subscribe() {
            // ... to be implemented
        },
        /**
         * Trigger
         *
         * @param {string | EventBusEvent} eventType    event type
         * @param {object} [data] custom data
         */
        $eventTrigger(eventType, data) {
            this.$eventBus.trigger(eventType, data);
        },
        /**
         * Listen
         *
         * @param {string | EventBusEvent} eventType      event type
         * @param {EventHandler} handler                handler
         * @param {boolean} [once=false]                once? @default false
         * @return {Function}                           dispose handler
         */
        $eventListen(eventType, handler, once = false) {
            return this.$eventBus.listen(eventType, handler, once);
        },
        /**
         * Count
         *
         * @param {string | EventBusEvent} eventType    event type
         * @return {number}                             count of registered event listener handlers
         */
        $eventCount(eventType) {
            return this.$eventBus.count(eventType);
        },

        /**
         * Mounted LC handler
         *
         * @private
         * This method is useful for edge-cases when Elem's $el may change
         * Cases:
         * - root domNode has a v-if directive
         * - component uses render() function and the domNode tag is dynamic and v-key is not used
         * @param {boolean} [shouldTriggerEvents=true]    whether to emit 'mounted' event
         */
        _mounted(shouldTriggerEvents = true) {
            patchComponentRootDomElement(this);
            if (shouldTriggerEvents) {
                // emit 'mounted' event via vue/dom
                dispatchEventByName.call(this, ElemEvent.MOUNTED);
            }
        },
        /**
         * @param {Record<string, any>} props
         * @return {Record<string, any>}
         */
        processPropsConst(props) {
            return processPropsConst(props);
        },
        /**
         * @param {Error} error
         * @param {string} scope
         */
        handleError(error, { scope = 'handleError' } = {}) {
            if (error.isCancel) {
                return;
            }
            if (error.scope == null) {
                error.scope = scope;
            }

            this.$errorService.handleError({ error, context: this, scope: error.scope });
        },
        /**
         * @param {Error} error
         * @param {string} scope
         */
        $handleError(error, { scope = 'handleError' } = {}) {
            this.handleError(error, { scope });
        },

        /**
         * @param {string} message
         * @param {string} type
         * @param {string} scope
         */
        $debugMessage(message, { type = 'warning', scope = 'method' } = {}) {
            const debugMessage = new WidgetDebugMessage(message, {}, { type, scope });
            this.$errorService.handleError({ error: debugMessage, context: this, scope });
        },

        propChanged() {
            const { propsDefault, props: propsNew } = this;
            const props = resolvePropsDif(propsDefault, propsNew);
            dispatchEventByName.call(this, ElemEvent.PROPS_CHANGE, { payload: { props } });
        }
    },
    /**
     * Used by Editor/Sandbox Environment
     * to get Panel Component Modules list
     *
     * @public
     * @param {string} type
     * @return {[]|import('vue/types/options').AsyncComponentPromise[]}
     */
    resolvePanels({ type = '' } = {}) {
        if (type === 'default') {
            return this.meta.panelsDefault;
        }
        return [...this.meta.panels, ...this.methods.getPanels()];
    }
};

export default ComponentOptions;
</script>
