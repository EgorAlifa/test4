<template>
    <ui-container>
        <ui-radio-buttons v-model="activeKey" :options="borderSideOptions" />
        <ui-input-units v-model="activeSide.width" :units="units">Толщина</ui-input-units>
        <ui-input-cp v-model="activeSide.color">Цвет</ui-input-cp>
        <ui-select v-model="activeSide.style" :options="styleOptions">Тип</ui-select>
    </ui-container>
</template>

<script>
import { isEqual, map as mapByKey, uniq, camelCase } from 'lodash';
import { BorderSideOptions, SizeUnits, BorderStyleOptions } from '@goodt-wcore/panels';
import { ControlMixin, createBorder } from './utils';
import UiInputUnits from './InputUnits.vue';
import UiRadioButtons from './RadioButtons.vue';
import UiHasTwoColumns from './HasTwoColumns.vue';
import UiSelect from './Select.vue';
import UiInputCp from './InputCp.vue';
import UiContainer from './Container.vue';

const orderedSides = ['top', 'right', 'bottom', 'left'];

/**
 * @typedef {import('./utils').IBorderProps} IBorderProps
 * @typedef {import('@goodt-wcore/panels').BorderSideOptions} IBorderSideOptions
 */

export default {
    components: { UiInputUnits, UiRadioButtons, UiHasTwoColumns, UiSelect, UiInputCp, UiContainer },
    mixins: [ControlMixin],
    props: {
        /**
         * @model
         * @type {import('vue').PropOptions<IBorderProps>}
         */
        value: {
            type: Object,
            default: createBorder
        },
        /**
         * Sides Array[String]
         */
        sides: {
            type: Array,
            default: () => ['all', 'top', 'right', 'bottom', 'left']
        },
        /**
         * Options Array[Object] ~ [ { value: '', label: '' } ]
         */
        styleOptions: {
            type: Array,
            default: () => BorderStyleOptions
        },
        /**
         * Units Array[String]
         */
        units: {
            type: Array,
            default: () => SizeUnits
        }
    },
    data: (vm) => ({
        /** @type {Record<string, IBorderProps>} */
        model: null,
        activeKey: vm.sides[0]
    }),
    computed: {
        /** @return {IBorderProps} */
        activeSide() {
            return this.model?.[this.activeKey];
        },
        /** @return {Partial<IBorderSideOptions>} */
        borderSideOptions() {
            return BorderSideOptions.filter(({ value }) => this.sides.includes(value));
        },
        /** @return {string} */
        stringedModelAll() {
            const { all: allSet } = this.model ?? {};
            return allSet == null ? '' : JSON.stringify(allSet);
        }
    },
    watch: {
        valueResolved: {
            deep: true,
            immediate: true,
            handler() {
                const { valueResolved, model } = this;

                if (model != null && isEqual(this.collectBorder(model), valueResolved)) {
                    return;
                }

                const { color, width, style } = valueResolved;
                const colors = this.parseProp(color, 'color');
                const widths = this.parseProp(width, 'width');
                const styles = this.parseProp(style, 'style');
                this.model = orderedSides.reduce((acc, side, index) => ({
                    ...acc,
                    [side]: createBorder({
                        color: colors[index],
                        width: widths[index],
                        style: styles[index]
                    })
                }), {});
                this.updateModelAll();
            }
        },
        model: {
            deep: true,
            immediate: true,
            handler() {
                const { valueResolved, model } = this;
                const collectedModel = this.collectBorder(model);

                if (isEqual(collectedModel, valueResolved)) {
                    return;
                }

                this.updateModelAll();
                this.emitModel(collectedModel);
            }
        },
        stringedModelAll: {
            handler(allSetStr, oldAllSetStr) {
                if (oldAllSetStr === '') {
                    return;
                }

                const [allSet, oldAllSet] = [JSON.parse(allSetStr), JSON.parse(oldAllSetStr)];
                const mismatchedKey = this.findMismatchedKey(allSet, oldAllSet);
                const mismatchedValue = allSet[mismatchedKey];
                this.model = Object.fromEntries(
                    Object
                        .entries(this.model)
                        .map(([key, value]) => [key, { ...value, ...(mismatchedValue != null && { [mismatchedKey]: mismatchedValue }) }])
                );
            }
        }
    },
    methods: {
        /**
         * @param {Record<string, IBorderProps>} border
         * @return {IBorderProps}
         */
        collectBorder(border) {
            const { sides } = this;

            if (isEqual(sides.slice(), ['all'])) {
                return { ...this.model.all };
            }

            const elementStyle = this.getServiceElementStyle();
            const { color, width, style } = orderedSides.reduce((acc, side) => {
                const isSideIncluded = sides.includes(side);
                // user may use a part of these properties,
                // so if it's necessary, we have to "reset" all of them
                const color = isSideIncluded ? border[side].color : 'transparent';
                const width = isSideIncluded ? border[side].width : '0px';
                const style = isSideIncluded ? border[side].style : 'none';
                acc.color += (acc.color === '' ? '' : ' ') + color;
                acc.width += (acc.width === '' ? '' : ' ') + width;
                acc.style += (acc.style === '' ? '' : ' ') + style;
                return acc;
            }, { color: '', width: '', style: '' });
            // in order to optimize property entries: '1px 1px 1px 1px' -> '1px'
            elementStyle.borderColor = color;
            elementStyle.borderWidth = width;
            elementStyle.borderStyle = style;
            const { borderColor, borderWidth, borderStyle } = elementStyle;
            return { color: borderColor, width: borderWidth, style: borderStyle };
        },
        /** @return {CSSStyleDeclaration} */
        getServiceElementStyle() {
            let element = document.createElement('div');
            const elementStyle = element.style;
            element = null;
            return elementStyle;
        },
        /**
         * @param {string} prop
         * @param {string} propName
         * @return {string[]}
         */
        parseProp(prop, propName) {
            const elementStyle = this.getServiceElementStyle();
            elementStyle[camelCase(`border ${propName}`)] = prop;
            return orderedSides.reduce((acc, side) => [
                ...acc,
                elementStyle[camelCase(`border ${side} ${propName}`)] // e.g. borderLeftWidth
            ], [])
        },
        updateModelAll() {
            const { all, ...model } = this.model;
            const allSet = Object.keys(createBorder()).reduce((acc, prop) => {
                const values = mapByKey(model, prop);  // Extract the values for the current key
                acc[prop] = uniq(values).length === 1 ? values[0] : null;   // Check if all values are the same
                return acc;
            }, {});
            this.$set(this.model, 'all', allSet); // because initially adding new prop on reactive object
        },
        /**
         * @param {Object} obj1
         * @param {Object} obj2
         * @return {string|null}
         */
        findMismatchedKey(obj1, obj2) {
            for (const key in obj1) {
                if (obj1[key] !== obj2[key]) {
                    return key;
                }
            }
            return null;
        },
        /**
         * @param {IBorderProps} border
         */
        emitModel(border) {
            this.onInput(border);
            this.onChange(border);
        }
    }
};
</script>
