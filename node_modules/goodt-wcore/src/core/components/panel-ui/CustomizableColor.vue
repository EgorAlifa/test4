<template>
    <div class="row">
        <div class="col" :class="colSizeCl">
            <ui-container>
                <ui-select v-model="model.type" :options="TypeOptions">Тип окрашивания</ui-select>
                <template v-if="isDimensionType">
                    <ui-has-two-columns>
                        <template #left>
                            <ui-input-cp v-model="model.dimensions.color">Цвет</ui-input-cp>
                        </template>
                        <template #right>
                            <ui-input v-model="model.dimensions.step" type="number">Шаг</ui-input>
                        </template>
                    </ui-has-two-columns>
                    <ui-draggable v-model="resultDimensions" v-bind="DragOptions">
                        <div
                            class="row row-hgap-3 mar-bot-3"
                            v-for="(dimension, index) in resultDimensions"
                            :key="index">
                            <div class="col col-auto col-vbot">
                                <span class="icon mar-bot-2 cursor-pointer drag-handle">
                                    <i class="mdi mdi-18px mdi-drag"></i>
                                </span>
                            </div>
                            <div class="col col-vbot">
                                <ui-input-cp
                                    :value="getDimensionColor(dimension)"
                                    @change="setDimensionColor(dimension, $event)">
                                    {{ dimension }}
                                </ui-input-cp>
                            </div>
                            <div class="col col-auto col-vbot">
                                <span class="icon mar-bot-2 cursor-pointer" @click="resetDimensionColor(dimension)">
                                    <i class="mdi mdi-18px mdi-refresh"></i>
                                </span>
                            </div>
                        </div>
                    </ui-draggable>
                </template>
                <template v-if="isMetricType">
                    <ui-select v-model="model.metrics.metric" :options="metrics">Метрика</ui-select>
                </template>
                <template v-if="isIndexesType">
                    <button class="btn btn-primary w-100 flex-h-space-between" @click="addIndexesColor">
                        <span>Добавить</span>
                        <span class="icon">
                            <i class="mdi mdi-18px mdi-plus-box-outline"></i>
                        </span>
                    </button>
                    <ui-draggable v-model="model.indexes.colors" v-bind="DragOptions">
                        <div class="row row-hgap-3 mar-bot-3" v-for="(_, index) in model.indexes.colors" :key="index">
                            <div class="col col-auto col-vbot">
                                <span class="icon mar-bot-2 cursor-pointer" @click="copyIndexesColor(index)">
                                    <i class="mdi mdi-18px mdi-content-copy"></i>
                                </span>
                            </div>
                            <div class="col col-auto col-vbot">
                                <span class="icon mar-bot-2 cursor-pointer drag-handle">
                                    <i class="mdi mdi-18px mdi-drag"></i>
                                </span>
                            </div>
                            <div class="col col-vbot">
                                <ui-input-cp v-model="model.indexes.colors[index]">Цвет {{ index + 1 }}</ui-input-cp>
                            </div>
                            <div class="col col-auto col-vbot">
                                <span class="icon mar-bot-2 cursor-pointer" @click="removeIndexesColor(index)">
                                    <i class="mdi mdi-18px mdi-minus-box-outline"></i>
                                </span>
                            </div>
                        </div>
                    </ui-draggable>
                </template>
            </ui-container>
        </div>
    </div>
</template>
<script>
import Color from 'color';
import UiDraggable from 'vuedraggable';
import { uniq } from 'lodash';
import { ObjectControlMixin, ControlMixin, createCustomizableColor } from './utils';
import UiInputCp from './InputCp.vue';
import UiInput from './Input.vue';
import UiSelect from './Select.vue';
import UiHasTwoColumns from './HasTwoColumns.vue';
import UiContainer from './Container.vue';

export const shiftColorByNumber = ({ color, number }) => {
    try {
        const colorData = Color(color);
        const { l: light } = colorData.hsl().object();
        return colorData.lightness(light + number).string();
    } catch {
        return color;
    }
};

const Types = Object.freeze({
    DIMENSION: '',
    METRIC: 'metric',
    INDEXES: 'indexes'
});

const TypeOptions = Object.freeze([
    { label: 'По измерению', value: Types.DIMENSION },
    { label: 'По метрике', value: Types.METRIC },
    { label: 'По порядку', value: Types.INDEXES }
]);
const DragOptions = {
    handle: '.drag-handle',
    animation: 500
};

export default {
    components: { UiInputCp, UiInput, UiHasTwoColumns, UiSelect, UiContainer, UiDraggable },
    mixins: [ControlMixin, ObjectControlMixin],
    static: {
        TypeOptions,
        DragOptions
    },
    props: {
        /**
         * Options Array[String]
         */
        dimensions: {
            type: Array,
            default: () => []
        },
        /**
         * Options Array[String]
         */
        metrics: {
            type: Array,
            default: () => []
        }
    },
    computed: {
        colSizeCl() {
            return `col-${this.colSize}`;
        },
        isDimensionType() {
            return this.model.type === Types.DIMENSION;
        },
        isMetricType() {
            return this.model.type === Types.METRIC;
        },
        isIndexesType() {
            return this.model.type === Types.INDEXES;
        },
        dimensionsStepColors() {
            const {
                model: {
                    dimensions: { color, step }
                },
                resultDimensions
            } = this;
            return resultDimensions.map((_, index) => shiftColorByNumber({ color, number: step * index }));
        },
        resultDimensions: {
            get() {
                const {
                    dimensions,
                    model: {
                        dimensions: { dimensions: modelDimensions }
                    }
                } = this;
                return uniq([...modelDimensions.filter((dim) => dimensions.includes(dim)), ...dimensions]);
            },
            set(value) {
                this.$set(this.model.dimensions, 'dimensions', value);
            }
        }
    },
    methods: {
        /**
         * @public
         */
        createSettings(settings = createCustomizableColor()) {
            return createCustomizableColor(settings);
        },
        getDimensionColor(dimension) {
            const { colors } = this.model.dimensions;
            const { resultDimensions } = this;
            return (
                colors?.[dimension] ??
                this.dimensionsStepColors[resultDimensions.findIndex((dim) => dim === dimension)] ??
                ''
            );
        },
        setDimensionColor(dimension, value) {
            this.$set(this.model.dimensions.colors, dimension, value);
        },
        resetDimensionColor(dimension) {
            this.$set(
                this.model.dimensions,
                'colors',
                Object.fromEntries(Object.entries(this.model.dimensions.colors).filter(([dim]) => dim !== dimension))
            );
        },
        addIndexesColor() {
            this.model.indexes.colors.push('');
        },
        copyIndexesColor(index) {
            const {
                model: {
                    indexes: { colors }
                }
            } = this;
            colors.splice(index, 0, colors[index]);
        },
        removeIndexesColor(index) {
            const {
                model: {
                    indexes: { colors }
                }
            } = this;
            colors.splice(index, 1);
        }
    }
};
</script>
