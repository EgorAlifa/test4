<template>
    <div>
        <control-layout v-bind="{ prop, colSize }">
            <template #label="{ getLabel }">
                <!--
                @slot label slot
                -->
                <slot v-bind="{ getLabel }" />
            </template>
            <template #hint="{ getHint }">
                <!--
                @slot hint slot
                -->
                <slot name="hint" v-bind="{ getHint }" />
            </template>
            <template #helper>
                <i
                    v-if="optionsWithConstants.length"
                    class="mdi mdi-variable cursor-pointer pull-right"
                    :class="[isCustomValueMode ? '' : 'color-grey']"
                    style="line-height: 1"
                    @click="toggleCustomValueMode" />
            </template>
            <template #control>
                <ui-select
                    v-if="optionsWithConstants.length && isCustomValueMode"
                    class="w-100"
                    :class="controlCl"
                    size="small"
                    v-bind="{ value: attrs.value, options: optionsWithConstants }"
                    @change="onOptionChange" />
                <ui-input-units
                    ref="input"
                    class="w-12-12"
                    :class="controlCl"
                    v-bind="{ value: attrs.value, units, size: 'small' }"
                    v-else-if="isCustomValueMode === false"
                    @change="onInputUnitChange"></ui-input-units>
            </template>
        </control-layout>
    </div>
</template>
<script>
import { InputUnits as UiInputUnits, Select as UiSelect } from 'goodteditor-ui';
import { ControlMixin, getConstants } from './utils';

export default {
    components: { UiInputUnits, UiSelect },
    mixins: [ControlMixin],
    props: {
        /**
         * @model
         */
        value: {
            type: String,
            default: ''
        },
        /**
         * Suggested options Array.[Object] ~ [ { label:'', value:'' } ]
         */
        options: {
            type: Array,
            default() {
                return [];
            }
        },
        /**
         * Unit options Array.[String]
         */
        units: {
            type: Array,
            default() {
                return [];
            }
        }
    },
    data() {
        return {
            isCustomValueMode: false
        };
    },
    computed: {
        optionsWithConstants() {
            return [...this.options, ...getConstants().map((constName) => ({ label: constName, value: constName }))];
        }
    },
    watch: {
        'attrs.value': {
            /**
             * @param {any} newValue
             */
            handler(newValue) {
                this.isCustomValueMode = this.optionsWithConstants.some(({ value }) => value === newValue);
            },
            immediate: true
        }
    },
    methods: {
        toggleCustomValueMode() {
            this.isCustomValueMode = !this.isCustomValueMode;
        },
        /**
         * @param {any} value
         * @param {object} model
         * @param {any} model.value
         * @param {string} model.unit
         */
        emitChange(value, model) {
            /**
             * Change event
             * @property {any} value
             * @property {object} model
             */
            this.$emit('change', value, model);
        },
        /**
         * @param {any} value
         */
        onOptionChange(value) {
            const model = { value, unit: '' };
            this.onInput(value);
            this.emitChange(value, model);
        },
        /**
         * @param {any} value
         */
        onInputUnitChange(value) {
            if (value == null) {
                return;
            }
            const { model } = this.$refs.input;
            value = value === '' ? [model.value, model.unit].join('') : value;
            this.onInput(value);
            this.emitChange(value, model);
        }
    }
};
</script>
