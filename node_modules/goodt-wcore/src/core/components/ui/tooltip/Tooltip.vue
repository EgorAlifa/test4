<template>
    <div class="contents">
        <slot name="target"></slot>
        <w-popover v-bind="popoverOptions" :show.sync="isPopoverShown" @mouseleave.native="onMouseLeave">
            <slot
                name="tooltip"
                v-bind="{
                    tooltipCssVars,
                    buildTooltipDataItemCssVars,
                    dataItemRender,
                    data: dataItemsFiltered
                }"
            >
                <div :style="tooltipCssVars" class="tooltip">
                    <div v-if="tooltip.title.text !== ''" class="tooltip__title">{{ tooltip.title.text }}</div>
                    <div v-if="dataItemsFiltered.length > 0" class="tooltip__data-items">
                        <component
                            :is="dataItemRender"
                            v-for="(item, idx) of dataItemsFiltered"
                            :key="idx"
                            :style="buildTooltipDataItemCssVars(item)"
                            v-bind="{ item, data }"
                            class="tooltip__data-item"
                        />
                    </div>
                </div>
            </slot>
        </w-popover>
    </div>
</template>

<script>
import { get as getByPath, isEqual, isEmpty } from 'lodash';
import { Popover as WPopover } from 'goodteditor-ui';

import {
    TooltipDefaultFactory,
    buildTooltipDataItemCssVariables,
    generateTooltipCssVars
} from './utils';
import { TOOLTIP_PROP_NAME, DELAY_TIME } from './constants';
import { ItemRender } from './components';

export default {
    components: {
        WPopover
    },
    inject: ['$widget'],
    props: {
        /**
         * Whether to show the tooltip
         */
        isShown: {
            type: Boolean,
            default: false
        },
        /**
         * Whether the tooltip is fixed on the screen
         */
        isFixed: {
            type: Boolean,
            default: false
        },
        /**
         * Whether to append popover to body
         */
        appendToBody: {
            type: Boolean,
            default: true
        },
        /**
         * Cursor coordinates [ x, y ]
         */
        coordinates: {
            type: Array,
            default: () => [0, 0],
            validator: (array) => array.length === 2 && array.every(Number.isFinite)
        },
        /**
         * Hide delay in ms
         */
        hideDelay: {
            type: Number,
            default: DELAY_TIME,
        },
        /**
         * Name under which the property is recorded
         */
        propName: {
            type: String,
            default: TOOLTIP_PROP_NAME
        },
        /**
         * Record which may contain fields to form tooltip data items
         */
        data: {
            type: Object,
            default: () => ({})
        },
        /**
         * Tooltip data item component render
         */
        dataItemRender: {
            type: Object,
            default: () => ItemRender
        }
    },
    data: () => ({
        isPopoverShown: false,
        timeout: null,
    }),
    computed: {
        /**
         * @return {Record<string, any>}
         */
        tooltip() {
            return getByPath(this.$widget.props, this.propName, TooltipDefaultFactory());
        },
        /**
         * @return {Record<string, any>}
         */
        popoverOptions() {
            const {
                coordinates: target,
                appendToBody,
                tooltip: { position, positionOffsets: positionOffset, shouldRespondToPointerEvents }
            } = this;
            return { target, appendToBody, position, positionOffset, shouldRespondToPointerEvents };
        },
        /**
         * @return {Record<string, string>}
         */
        tooltipCssVars() {
            return this.$widget.buildCssVarsStyle(generateTooltipCssVars(this.propName));
        },
        /**
         * @return TooltipDataItem[]
         */
        dataItemsFiltered() {
            return this.tooltip.data.filter(({ value }) => value != null);
        }
    },
    watch: {
        isShown: {
            /**
             * @param {boolean} value
             */
            handler(value) {
                this.toggleVisibility(value);
            },
            immediate: true,
        },
        data: {
            /**
             * @param {Record<string, any>|null} data
             * @param {Record<string, any>|null} oldData
             */
            handler(data, oldData) {
                if (data == null || isEqual(data, oldData)) {
                    return;
                }

                let { vars = null } = this.tooltip;

                if (isEmpty(vars)) {
                    return;
                }

                const hasWidgetDataset = this.$widget.static?.DATASET_PROP != null;

                if (hasWidgetDataset) {
                    vars = Object.values(vars).reduce((acc, fieldName) => ({ ...acc, [fieldName]: fieldName }), {});
                }

                const dataToCommit = Object.entries(vars).reduce(
                    (acc, [varName, fieldName]) => ({ ...acc, [varName]: data[fieldName] }),
                    {}
                );

                this.$widget.storeCommit(dataToCommit, { hasMap: hasWidgetDataset });
            },
            immediate: true
        }
    },
    methods: {
        /**
         * @param {boolean} value
         */
        toggleVisibility(value) {
            const { timeout, hideDelay } = this;

            if (timeout != null) {
                clearTimeout(timeout);
            }

            if (value === true) {
                this.isPopoverShown = true;
                return;
            }

            this.timeout = setTimeout(() => {
                this.isPopoverShown = false;
            }, hideDelay);
        },
        /**
         * @param {TooltipDataItem} item
         * @return {Record<string, string>}
         */
        buildTooltipDataItemCssVars(item) {
            return this.$widget.genCssVarsStyle(buildTooltipDataItemCssVariables(item));
        },
        onMouseLeave() {
            if (this.isFixed) {
                return;
            }

            this.$emit('update:is-shown', false);
        }
    }
}
</script>
<style lang="pcss" scoped src="./style.pcss"></style>
