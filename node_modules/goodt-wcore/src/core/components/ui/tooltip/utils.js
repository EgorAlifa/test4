import isEmpty from 'lodash/isEmpty';
import isNaN from 'lodash/isNaN';
import dayjs from 'dayjs';
import customParseFormat from 'dayjs/esm/plugin/customParseFormat';
import { formatNumber } from '@goodt-common/utils';
import {
    TemplateVariable,
    TextPosition,
    TOOLTIP_PROP_NAME,
    TooltipDataItemValueType,
    TooltipPosition,
} from './constants';

dayjs.extend(customParseFormat);

export const TooltipDefaultFactory = () => ({
    isEnabled: false,
    isSlotShown: false,
    shouldFollowPointer: false,
    shouldRespondToPointerEvents: true,
    position: TooltipPosition.TOP,
    positionOffsets: [1, 1],
    data: [],
    vars: {},
    style: {
        vPadding: '0.5rem',
        hPadding: '0.5rem',
        color: '',
        backgroundColor: '',
        borderWidth: '1px',
        borderColor: '',
        borderStyle: 'solid',
        borderRadius: '0.25rem',
        boxShadow: '0 1px 3px rgba(0, 0, 0, 0.4)'
    },
    title: {
        text: '',
        textAlign: TextPosition.CENTER,
        color: '',
        fontSize: '1rem',
        fontFamily: '',
        fontWeight: '500'
    }
});

/**
 * allows to redefine tooltip css variables according to property name
 * @param {string} [propName = TOOLTIP_PROP_NAME]          see [[TOOLTIP_PROP_NAME]]
 * @return {Record<string, string|[string, string]>}
 */
export const generateTooltipCssVars = (propName = TOOLTIP_PROP_NAME) => ({
    'tooltip_v-padding': `${propName}.style.vPadding`,
    'tooltip_h-padding': `${propName}.style.hPadding`,
    'tooltip_color': [`${propName}.style.color`, 'var(--color-white)'],
    'tooltip_bg-color': [`${propName}.style.backgroundColor`, 'var(--color-body)'],
    'tooltip_border-width': `${propName}.style.borderWidth`,
    'tooltip_border-color': [`${propName}.style.borderColor`, 'var(--color-border)'],
    'tooltip_border-style': `${propName}.style.borderStyle`,
    'tooltip_border-radius': `${propName}.style.borderRadius`,
    'tooltip_box-shadow': `${propName}.style.boxShadow`,
    'tooltip-title_text-align': `${propName}.title.textAlign`,
    'tooltip-title_color': [`${propName}.title.color`, 'var(--color-white)'],
    'tooltip-title_font-size': `${propName}.title.fontSize`,
    'tooltip-title_font-family': [`${propName}.title.fontFamily`, 'var(--font-family)'],
    'tooltip-title_font-weight': `${propName}.title.fontWeight`,
});

/**
 * @param {any} value
 * @param {string} fallback
 * @return {string|number}
 */
const resolveValue = (value, fallback = '') => isEmpty(value) ? fallback : value;
/**
 * builds tooltip data-item css variables
 * @param {TooltipDataItem} item
 * @return {Record<string, string|number>}
 */
export const buildTooltipDataItemCssVariables = ({ style, prefix, postfix }) => ({
    'tooltip-item_font-size': style.fontSize,
    'tooltip-item_font-family': resolveValue(style.fontFamily, 'var(--font-family)'),
    'tooltip-item_font-weight': style.fontWeight,
    'tooltip-item_text-align': style.textAlign,
    'tooltip-item_color': resolveValue(style.color, 'var(--color-white)'),
    'tooltip-item-prefix_font-size': prefix.fontSize,
    'tooltip-item-prefix_font-family': resolveValue(prefix.fontFamily, 'var(--font-family)'),
    'tooltip-item-prefix_font-weight': prefix.fontWeight,
    'tooltip-item-prefix_color': resolveValue(prefix.color, 'var(--color-white)'),
    'tooltip-item-prefix_margin-right': prefix.offset,
    'tooltip-item-postfix_font-size': postfix.fontSize,
    'tooltip-item-postfix_font-family': resolveValue(postfix.fontFamily, 'var(--font-family)'),
    'tooltip-item-postfix_font-weight': postfix.fontWeight,
    'tooltip-item-postfix_color': resolveValue(postfix.color, 'var(--color-white)'),
    'tooltip-item-postfix_margin-left': postfix.offset
});
/**
 * @return TextStyle
 */
const TextStyleFactory = () => ({
    color: '',
    fontSize: '1rem',
    fontFamily: '',
    fontWeight: '500'
});
/**
 * @return TooltipDataItem
 */
export const TooltipDataItemFactory = () => ({
    value: null,
    type: TooltipDataItemValueType.STRING,
    valueFormat: '',
    outputFormat: '{n}: {v}',
    shouldShowSign: false,
    style: {
        ...TextStyleFactory(),
        textAlign: 'left'
    },
    prefix: {
        value: '',
        ...TextStyleFactory(),
        offset: '4px'
    },
    postfix: {
        value: '',
        ...TextStyleFactory(),
        offset: '4px'
    }
});
/**
 * format a value according to value format
 * @param {string|number|null} value
 * @param {string} type
 * @param {string} format
 * @param {boolean} [shouldShowSign = false]
 * @return {string|number}
 */
export const formatValue = (value, { type, format, shouldShowSign = false }) => {
    if (value == null) {
        return '-';
    }
    
    if (type === TooltipDataItemValueType.STRING) {
        return value;
    }

    if (type === TooltipDataItemValueType.DATE) {
        const date = dayjs(value);
        return date.isValid() ? date.format(format) : value;
    }
    
    if (isNaN(value)) {
        return value;
    }
    
    if (type === TooltipDataItemValueType.NUMBER) {
        const number = formatNumber(Number(value), format);
        return value > 0 && shouldShowSign ? `+${number}` : number;
    }
    
    return value;
}
/**
 * @param {string|value|null} value
 * @param {TooltipDataItem} item
 * @return {{name: string, value: (string|number)}}
 */
export const resolveTooltipDataItemValue = (value, { value: name, type, valueFormat: format, shouldShowSign }) => {
    const formattedValue = formatValue(value, { type, format, shouldShowSign });
    return { name, value: formattedValue };
}

/**
 * builds tooltip data-item children elements
 * @param {import('vue').CreateElement} h
 * @param {TooltipDataItem} item
 * @param {string} name
 * @param {string|number} value
 * @param {string} [cssClass = ITEM_CSS_CLASS]
 * @return HTMLElement[]
 */
export const buildTooltipDataItemChildren = (h, { outputFormat, prefix, postfix }, { name, value }, cssClass) => {
    const prefixElem = prefix.value !== '' ? h('span', { class: `${cssClass}__prefix` }, prefix.value) : null;
    const postfixElem = postfix.value !== '' ? h('span', { class: `${cssClass}__postfix` }, postfix.value) : null;
    const brace = (string) => `{${string}}`;
    const splitterRegExp = RegExp([
        '({[',
        Object.values(TemplateVariable).reduce((acc, letter) => acc.concat(letter), ''),
        ']})',
    ].join(''), 'gi');
    
    return outputFormat
        .split(splitterRegExp)
        .reduce((acc, group) => {
            if (group.toLowerCase() === brace(TemplateVariable.NAME)) {
                return [...acc, h('span', name)];
            }
            if (group.toLowerCase() === brace(TemplateVariable.VALUE)) {
                return [...acc, prefixElem, h('span', value), postfixElem];
            }
            return [...acc, h('span', group)];
        }, [])
        .filter((elem) => elem != null);
};
