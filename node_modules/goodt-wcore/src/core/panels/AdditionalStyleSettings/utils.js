import { merge } from 'lodash';
import { ColorManager, ConstManager } from '@goodt-wcore/managers';
import {
    IGNORE_SPACES_IN_BRACKETS,
    BackgroundPositionOptions,
    BackgroundRepeatOptions,
    BackgroundType,
    GradientType,
    BorderTypeValues,
    ONLY_NUMBERS,
    ONLY_NUMBERS_WITH_MINUS,
    BorderVariation,
    BorderVariationKeys,
    CssStylePropertyPart,
    CssStyleName,
    BoxShadowType,
    BoxShadowLengthType,
    BackgroundPositionType,
    BackgroundRepeatType,
    DEFAULT_BACKGROUND_SIZE,
    DEFAULT_BORDER_OPTION,
    ONLY_NUMBERS_AND_STARTS_WITH_DIGIT
} from './constants';

const isConstant = (value) => value != null && (ConstManager.isConstant(value) || ColorManager.isConstant(value));

export const backgroundFactory = (background) => ({
    type: null,
    color: '',
    gradientType: null,
    gradientFirstColor: '',
    gradientSecondColor: '',
    gradientFirstColorOffset: null,
    gradientSecondColorOffset: null,
    gradientDirection: null,
    centerX: null,
    centerY: null,
    radius: null,
    file: '',
    size: DEFAULT_BACKGROUND_SIZE,
    repeat: BackgroundRepeatType.REPEAT_X,
    position: BackgroundPositionType.TOP,
    output: '',
    ...background
});

const outputFactory = () => ({
    backgrounds: [],
    primitiveStyle: {},
    border: {
        width: '',
        type: DEFAULT_BORDER_OPTION,
        color: '',
        radius: '',
        leftWidth: '',
        leftType: DEFAULT_BORDER_OPTION,
        leftColor: '',
        topLeftRadius: '',
        rightWidth: '',
        rightType: DEFAULT_BORDER_OPTION,
        rightColor: '',
        topRightRadius: '',
        bottomWidth: '',
        bottomType: DEFAULT_BORDER_OPTION,
        bottomColor: '',
        bottomLeftRadius: '',
        topWidth: '',
        topType: DEFAULT_BORDER_OPTION,
        topColor: '',
        bottomRightRadius: ''
    },
    boxShadow: {
        offsetX: '',
        offsetY: '',
        blurRadius: '',
        spreadRadius: '',
        color: '',
        type: ''
    },
    transformAngle: 0
});

// игнорирует запятые в скобках
const parseArgString = (string) => {
    const args = [];
    let argStartIndex = 0;
    let depth = 0;

    for (let index = 0; index < string.length; ++index) {
        const char = string[index];

        if (char == '(') {
            depth += 1;
        }
        if (char == ')') {
            depth -= 1;
        }
        if (depth < 0) {
            throw new Error('unexpected ")" character');
        }

        if (char == ',' && depth === 0) {
            args.push(string.slice(argStartIndex, index).trim());
            argStartIndex = index + 1;
        }
    }

    const finalArg = string.slice(argStartIndex).trim();
    if (finalArg.length > 0) {
        args.push(finalArg);
    }
    return args;
};

const hexToRgb = (hex) => {
    return `${CssStylePropertyPart.RGB}(${hex
        .replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, (m, r, g, b) => CssStylePropertyPart.HASH + r + r + g + g + b + b)
        .substring(1)
        .match(/.{2}/g)
        .map((x) => parseInt(x, 16))
        .join(',')})`;
};

export const filterObjectByKey = (object, key) =>
    Object.fromEntries(Object.entries(object).filter(([styleKey, _]) => styleKey !== key));

const parseLinearGradientFromStr = (backgroundStr) => {
    const linearBackgroundStyles = parseArgString(
        backgroundStr.replace(CssStylePropertyPart.LINEAR_GRADIENT, '').slice(1, -1)
    );
    return backgroundFactory({
        type: BackgroundType.GRADIENT,
        gradientType: GradientType.LINEAR,
        gradientDirection: Number(linearBackgroundStyles[0].match(ONLY_NUMBERS)[0]),
        gradientFirstColor: linearBackgroundStyles[1].split(IGNORE_SPACES_IN_BRACKETS)[0],
        gradientSecondColor: linearBackgroundStyles[2].split(IGNORE_SPACES_IN_BRACKETS)[0],
        gradientFirstColorOffset: Number(
            linearBackgroundStyles[1].split(IGNORE_SPACES_IN_BRACKETS)[1].match(ONLY_NUMBERS)[0]
        ),
        gradientSecondColorOffset: Number(
            linearBackgroundStyles[2].split(IGNORE_SPACES_IN_BRACKETS)[1].match(ONLY_NUMBERS)[0]
        ),
        output: backgroundStr
    });
};

const parseRadialGradientFromStr = (backgroundStr) => {
    const linearBackgroundStyles = parseArgString(
        backgroundStr.replace(CssStylePropertyPart.RADIAL_GRADIENT, '').slice(1, -1)
    );
    return backgroundFactory({
        type: BackgroundType.GRADIENT,
        gradientType: GradientType.RADIAL,
        centerX: linearBackgroundStyles[0].split(' ')[1].match(ONLY_NUMBERS)[0],
        centerY: linearBackgroundStyles[0].split(' ')[2].match(ONLY_NUMBERS)[0],
        radius: linearBackgroundStyles[1].split(IGNORE_SPACES_IN_BRACKETS)[1].match(ONLY_NUMBERS)[0],
        gradientFirstColor: linearBackgroundStyles[2].split(IGNORE_SPACES_IN_BRACKETS)[0],
        gradientSecondColor: linearBackgroundStyles[3].split(IGNORE_SPACES_IN_BRACKETS)[0],
        gradientFirstColorOffset: Number(
            linearBackgroundStyles[2].split(IGNORE_SPACES_IN_BRACKETS)[1].match(ONLY_NUMBERS)[0]
        ),
        gradientSecondColorOffset: Number(
            linearBackgroundStyles[3].split(IGNORE_SPACES_IN_BRACKETS)[1].match(ONLY_NUMBERS)[0]
        ),
        output: backgroundStr
    });
};

const parseFileFromStr = (backgroundStr) => {
    const imageBgStyles = backgroundStr.replace(CssStylePropertyPart.URL, '').split(' ');
    return backgroundFactory({
        type: BackgroundType.FILE,
        file: imageBgStyles[0].slice(1, -1),
        position: imageBgStyles.find((style) => BackgroundPositionOptions.map(({ value }) => value).includes(style)),
        size: imageBgStyles.find((style) => style.match(ONLY_NUMBERS_AND_STARTS_WITH_DIGIT)),
        repeat: imageBgStyles.find((style) => BackgroundRepeatOptions.map(({ value }) => value).includes(style)),
        output: backgroundStr
    });
};

const parseBackgroundColorFromStr = (backgroundStr) =>
    backgroundFactory({
        type: BackgroundType.COLOR,
        color: hexToRgb(backgroundStr),
        output: backgroundStr
    });

const parseBackgroundsFromStr = (backgroundStrs) =>
    backgroundStrs.reduce((map, backgroundStr) => {
        if (isConstant(backgroundStr)) {
            map.push(backgroundFactory({
                type: BackgroundType.COLOR,
                color: backgroundStr,
                output: backgroundStr
            }));
            return map;
        }
        if (backgroundStr.includes(CssStylePropertyPart.LINEAR_GRADIENT)) {
            map.push(parseLinearGradientFromStr(backgroundStr));
            return map;
        }
        if (backgroundStr.includes(CssStylePropertyPart.RADIAL_GRADIENT)) {
            map.push(parseRadialGradientFromStr(backgroundStr));
            return map;
        }
        if (backgroundStr.includes(CssStylePropertyPart.URL)) {
            map.push(parseFileFromStr(backgroundStr));
            return map;
        }
        if (
            backgroundStr.includes(CssStylePropertyPart.HASH)
        ) {
            map.push(parseBackgroundColorFromStr(backgroundStr));
            return map;
        }
        if (backgroundStr.includes(CssStylePropertyPart.RGB)) {
            map.push(
                backgroundFactory({
                    type: BackgroundType.COLOR,
                    color: backgroundStr,
                    output: backgroundStr
                })
            );
            return map;
        }
        return map;
    }, []);

const resolveBorder = (value) => {
    const borderStyles = value.split(IGNORE_SPACES_IN_BRACKETS);
    const width = borderStyles.find(
        (style) =>
            !style.includes(CssStylePropertyPart.HASH) &&
            !style.includes(CssStylePropertyPart.RGB) &&
            style.match(ONLY_NUMBERS)
    );
    const type = borderStyles.find((style) => BorderTypeValues.includes(style));
    const borderColor = borderStyles.find(
        (style) => style.includes(CssStylePropertyPart.HASH) || style.includes(CssStylePropertyPart.RGB)
    );
    const color = borderColor?.includes(CssStylePropertyPart.HASH) ? hexToRgb(borderColor) : borderColor;
    return { width, type, color };
};

const resolveBorderRadius = (acc, value) => {
    const borderRadiusSizes = value.split(' ');
    if (borderRadiusSizes.length === 2) {
        return merge(acc, {
            border: {
                topLeftRadius: borderRadiusSizes[0],
                topRightRadius: borderRadiusSizes[1],
                bottomLeftRadius: borderRadiusSizes[1],
                bottomRightRadius: borderRadiusSizes[0]
            }
        });
    }
    if (borderRadiusSizes.length === 1) {
        return merge(acc, { border: { radius: borderRadiusSizes[0] } });
    }
    if (borderRadiusSizes.length === 4) {
        return merge(acc, {
            border: {
                topLeftRadius: borderRadiusSizes[0],
                topRightRadius: borderRadiusSizes[1],
                bottomRightRadius: borderRadiusSizes[2],
                bottomLeftRadius: borderRadiusSizes[3]
            }
        });
    }
    return acc;
};

const resolveBoxShadow = (acc, value) => {
    const boxShadowStyles = value.split(IGNORE_SPACES_IN_BRACKETS);
    if (
        !boxShadowStyles.includes(BoxShadowType.INSET) &&
        boxShadowStyles.length === BoxShadowLengthType.FULL_WITHOUT_INSET
    ) {
        return merge(acc, {
            boxShadow: {
                offsetX: boxShadowStyles[0],
                offsetY: boxShadowStyles[1],
                blurRadius: boxShadowStyles[2],
                spreadRadius: boxShadowStyles[3],
                color: boxShadowStyles[4].includes(CssStylePropertyPart.HASH)
                    ? hexToRgb(boxShadowStyles[4])
                    : boxShadowStyles[4],
                type: BoxShadowType.OUTSET
            }
        });
    }
    if (
        boxShadowStyles.includes(BoxShadowType.INSET) &&
        boxShadowStyles.length === BoxShadowLengthType.FULL_WITH_INSET
    ) {
        const boxShadowWithoutInsetStyles = boxShadowStyles.filter((style) => style !== BoxShadowType.INSET);
        return merge(acc, {
            boxShadow: {
                offsetX: boxShadowWithoutInsetStyles[0],
                offsetY: boxShadowWithoutInsetStyles[1],
                blurRadius: boxShadowWithoutInsetStyles[2],
                spreadRadius: boxShadowWithoutInsetStyles[3],
                color: boxShadowWithoutInsetStyles[4].includes(CssStylePropertyPart.HASH)
                    ? hexToRgb(boxShadowWithoutInsetStyles[4])
                    : boxShadowWithoutInsetStyles[4],
                type: BoxShadowType.INSET
            }
        });
    }
    if (
        !boxShadowStyles.includes(BoxShadowType.INSET) &&
        boxShadowStyles.length === BoxShadowLengthType.WITHOUT_SPREAD_AND_INSET
    ) {
        return merge(acc, {
            boxShadow: {
                offsetX: boxShadowStyles[0],
                offsetY: boxShadowStyles[1],
                blurRadius: boxShadowStyles[2],
                color: boxShadowStyles[3].includes(CssStylePropertyPart.HASH)
                    ? hexToRgb(boxShadowStyles[3])
                    : boxShadowStyles[3],
                type: BoxShadowType.OUTSET
            }
        });
    }
    if (
        boxShadowStyles.includes(BoxShadowType.INSET) &&
        boxShadowStyles.length === BoxShadowLengthType.WITHOUT_SPREAD_WITH_INSET
    ) {
        const boxShadowWithoutInsetStyles = boxShadowStyles.filter((style) => style !== BoxShadowType.INSET);
        return merge(acc, {
            boxShadow: {
                offsetX: boxShadowWithoutInsetStyles[0],
                offsetY: boxShadowWithoutInsetStyles[1],
                blurRadius: boxShadowWithoutInsetStyles[2],
                color: boxShadowWithoutInsetStyles[3].includes(CssStylePropertyPart.HASH)
                    ? hexToRgb(boxShadowWithoutInsetStyles[3])
                    : boxShadowWithoutInsetStyles[3],
                type: BoxShadowType.INSET
            }
        });
    }
    return acc;
};

export const parseCss = ({ css }) => {
    return Object.entries(css).reduce(
        (acc, [key, value]) => {
            if (key === CssStyleName.BACKGROUND) {
                const backgroundStrs = parseArgString(value);
                acc.backgrounds = [...parseBackgroundsFromStr(backgroundStrs)];
                return acc;
            }
            if (
                [
                    CssStyleName.OPACITY,
                    CssStyleName.OVERFLOW_X,
                    CssStyleName.OVERFLOW__Y,
                    CssStyleName.CURSOR,
                    CssStyleName.MIN_WIDTH,
                    CssStyleName.MAX_WIDTH,
                    CssStyleName.MIN_HEIGHT,
                    CssStyleName.MAX_HEIGHT
                ].includes(key)
            ) {
                acc.primitiveStyle[key] = value;
                return acc;
            }
            if (key === CssStyleName.TRANSFORM) {
                acc.transformAngle = value.match(ONLY_NUMBERS_WITH_MINUS)[0];
                return acc;
            }
            if (key === CssStyleName.BORDER) {
                const border = resolveBorder(value);
                acc.border.width = border?.width ?? '';
                acc.border.type = border?.type ?? '';
                acc.border.color = border?.color ?? '';
                return acc;
            }
            if (BorderVariationKeys.includes(key)) {
                const border = resolveBorder(value);
                acc.border[BorderVariation[key].width] = border?.width ?? '';
                acc.border[BorderVariation[key].type] = border?.type ?? '';
                acc.border[BorderVariation[key].color] = border?.color ?? '';
                return acc;
            }
            if (key === CssStyleName.BORDER_RADIUS) {
                acc = { ...resolveBorderRadius(acc, value) };
                return acc;
            }
            if (key === CssStyleName.BOX_SHADOW) {
                acc = { ...resolveBoxShadow(acc, value) };
                return acc;
            }
            return acc;
        },
        { ...outputFactory() }
    );
};
