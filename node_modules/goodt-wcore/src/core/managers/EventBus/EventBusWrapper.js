/**
 * @typedef {import('./EventBus').EventBus} EventBus
 */
import { CoreError } from '@goodt-wcore/errors';
import EventBusEvent from './EventBusEvent';

/**
 * EventBusWrapper class
 * used by components
 */
class EventBusWrapper {
    /**
     * @type {EventBus}
     * @private
     */
    _eb;

    /**
     * @type {Function[]}
     * @private
     */
    _disposals = [];

    /**
     *
     * @type {Map<string, function(): string >}
     * @private
     */
    _eventTypeResolvers = new Map();

    _listenStateChange;

    _triggerStateChange;

    _listenRouteNavigate;

    _triggerRouteNavigate;

    /**
     * @param {EventBus} eventBus
     * @param context
     * @param [listenStateChange]
     * @param [listenRouteNavigate]
     * @param [triggerRouteNavigate]
     * @param [triggerStateChange]
     */
    constructor(
        eventBus,
        { context, listenStateChange, listenRouteNavigate, triggerRouteNavigate, triggerStateChange } = {}
    ) {
        /**
         * @type {EventBus}
         */
        if (eventBus == null) {
            throw new CoreError('`eventBus` could not be undefined or null');
        }

        this._eb = eventBus;

        this._context = context;
        this._listenStateChange = listenStateChange;
        this._triggerStateChange = triggerStateChange;
        this._listenRouteNavigate = listenRouteNavigate;
        this._triggerRouteNavigate = triggerRouteNavigate;
    }

    /**
     * Listen for @see EventBusEvent.EVENT_NAVIGATE event
     *
     * @param {EventHandler} handler    handler
     * @param {boolean} [once=false]    once
     * @return {Function}               handler ref
     */
    listenNavigate(handler, once = false) {
        const dispose = this._listenRouteNavigate((...args) => {
            handler(...args);
            once && dispose();
        });

        return dispose;
    }

    /**
     * Unlisten @see EventBusEvent.EVENT_NAVIGATE event
     *
     * @param {EventHandler} handler    handler
     */
    unlistenNavigate(handler) {
        // noop
    }

    /**
     * Trigger @see EventBusEvent.EVENT_NAVIGATE event (for relative urls; change window location for other url schemas)
     *
     * @param {object} info     nav info object { url:{String}, params:{Object} }
     * @param info.url
     * @param info.params
     * @return {boolean}        whether the event was triggered or not
     */
    triggerNavigate({ url, params = {} }) {
        const regExp = new RegExp('^(?:\\w*:(//)?)+', 'i');
        if (regExp.test(url) === false) {
            this._triggerRouteNavigate({ url, params });
            return true;
        }
        if (window != null) {
            const esc = encodeURIComponent;
            const query = Object.keys(params)
                .map((key) => `${key}=${esc(params[key])}`)
                .join('&');
            const sign = url.indexOf('?') >= 0 ? '&' : '?';
            window.location = query.length ? `${url}${sign}${query}` : url;
        }
        return false;
    }

    /**
     * Listen for @see EventBusEvent.EVENT_STATE_CHANGE event
     *
     * @param {EventHandler} handler    handler
     * @param {boolean} [once=false]    once
     * @param [global=false]
     * @return dispose function
     */
    listenStateChange(handler, once = false, { global = false } = {}) {
        const dispose = this._listenStateChange(
            (state) => {
                handler(new EventBusEvent(EventBusEvent.EVENT_STATE_CHANGE, undefined, this._context), state);
                once && dispose();
            },
            { global }
        );

        return dispose;
    }

    /**
     * Unlisten @see EventBusEvent.EVENT_STATE_CHANGE event
     *
     * @param {EventHandler} decoratedHandler    decorated handler
     */
    unlistenStateChange(decoratedHandler) {
        // noop
    }

    /**
     * Trigger @see EventBusEvent.EVENT_STATE_CHANGE event
     *
     * @param {object} stateChange     state change object { '<key>': '<value>' }
     * @param {boolean} [global=false]
     */
    triggerStateChange(stateChange, { global = false } = {}) {
        this._triggerStateChange(stateChange, { global });
    }

    /**
     * Listen
     *
     * @param {string | EventBusEvent} eventType      event type
     * @param {EventHandler} handler                handler
     * @param {boolean} [once=false]                once? @default false
     * @return {Function}                           dispose handler
     */
    listen(eventType, handler, once = false) {
        if (eventType == null || eventType === '') {
            console.warn(`[EventBus]: Empty "eventType" argument specified to "listen"`);
            return () => {};
        }

        const event = this.resolveEvent(eventType);
        if (event === null) {
            console.warn(`[EventBus]: Empty event for alias "${eventType}" trying to "listen"`);
            return () => {};
        }
        // {block}
        // @NOTE compatibility with those, who call listen(EventBusEvent.EVENT_STATE_CHANGE)
        // instead of listenStateChange()
        if (event.type === EventBusEvent.EVENT_STATE_CHANGE) {
            this.listenStateChange(handler, once, { global: true });
            return () => {};
        }
        // {/block}
        const dispose = this._eb.listen(event, handler, once);
        this._disposals.push(dispose);

        return dispose;
    }

    /**
     * Unlisten
     *
     * @param {string | EventBusEvent} eventType      event type
     * @param {EventHandler} handler                handler
     */
    unlisten(eventType, handler) {
        if (['', undefined, null].includes(eventType)) {
            console.warn(`[EventBus]: Empty "eventType" argument specified to "unsubscribe"`);
            return;
        }
        this._eb.unlisten(eventType, handler);
    }

    /**
     * Trigger
     *
     * @param {string | EventBusEvent} eventType    event type
     * @param {object} [data] custom data
     */
    trigger(eventType, data) {
        if (['', null, undefined].includes(eventType)) {
            console.warn(`[EventBus]: Empty "eventType" specified to "trigger"`);
            return;
        }
        const event = this.resolveEvent(eventType);
        if (event === null) {
            console.warn(`[EventBus]: Empty event for alias "${eventType}" trying to "trigger"`);
            return;
        }
        // {block}
        // @NOTE compatibility with those, who call trigger(EventBusEvent.EVENT_STATE_CHANGE)
        // instead of triggerStateChange()
        if (event.type === EventBusEvent.EVENT_STATE_CHANGE) {
            this.triggerStateChange(data, { global: true });
            return;
        }
        // {/block}

        this._eb.trigger(event, data);
    }

    /**
     * Has
     *
     * @param {string | EventBusEvent} eventType      event type
     * @param {EventHandler} handler                handler
     * @return {boolean}
     */
    has(eventType, handler) {
        const event = this.resolveEventType(eventType);
        return this._eb.has(event, handler);
    }
    
    /**
     * Count
     *
     * @param {string | EventBusEvent} eventType      event type
     * @return {number}
     */
    count(eventType) {
        const event = this.resolveEvent(eventType);
        return event == null ? 0 : this._eb.count(event);
    }

    /**
     * Dispose all handlers that refer to eventBus
     */
    dispose() {
        this._disposals.forEach((dispose) => dispose());
        this._disposals = [];
    }

    /**
     * Dispose all handlers that refer to eventBus
     * @deprecated
     */
    destroy() {
        this.dispose();
    }

    /**
     *
     * @param {string} eventType
     * @returns {EventBusEvent}
     * @private
     */
    resolveEvent(eventType) {
        // eslint-disable-next-line no-param-reassign
        const resolvedEventType = this.resolveEventType(eventType);
        if (resolvedEventType == null) {
            return null;
        }

        return resolvedEventType instanceof EventBusEvent
            ? resolvedEventType
            : new EventBusEvent(resolvedEventType, undefined, this._context);
    }

    /**
     *
     * @param {string} eventType
     * @return {string}
     * @private
     */
    resolveEventType(eventType) {
        const resolver = this.getEventTypeResolver(eventType);
        if (resolver != null) {
            const resolvedEventType = resolver();
            return resolvedEventType === '' ? null : resolvedEventType;
        }
        return eventType;
    }

    /**
     *
     * @param {string} eventType
     * @param {function(): string} resolver
     */
    setEventTypeResolver(eventType, resolver) {
        this._eventTypeResolvers.set(eventType, resolver);
    }

    /**
     *
     * @param {string} eventType
     * @return {function(): string}
     */
    getEventTypeResolver(eventType) {
        return this._eventTypeResolvers.get(eventType);
    }
}

export default EventBusWrapper;
