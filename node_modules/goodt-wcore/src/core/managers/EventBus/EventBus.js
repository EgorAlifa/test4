/**
 * @callback EventHandler
 * @param {EventBusEvent} event
 * @param {any} data
 */
/**
 * @typedef {object} ListenerInfo
 * @property {EventBusEvent} event
 * @property {EventHandler} handler
 * @property {boolean} once
 */

import EventBusEvent from './EventBusEvent';

/**
 * EventBus class
 */
class EventBus {
    /**
     * @private
     * @type {Record<string, ListenerInfo[]>}
     */
    _listeners;
    /**
     * @private
     * @type {Set.<EventHandler>}
     */
    _hooks;

    /**
     * Constructor
     */
    constructor() {
        this._hooks = new Set();
        this._listeners = Object.create(null);
    }

    /**
     * Registers trigger hook
     * @param {EventHandler} handler
     * @param {boolean} [once=false]
     * @return {Function} dispose function
     */
    hook(handler) {
        this._hooks.add(handler);
        return () => this._hooks.delete(handler);
    }

    /**
     * Registers an event handler
     *
     * @param {string|EventBusEvent} typeOrEvent     event
     * @param {EventHandler} handler    handler
     * @param {boolean} [once=false]    if set true event handler will be auto-unregistered when invoked
     * @return {Function}               dispose function to unregister the handler i.e. dispose() === unlisten(event, handler)
     */
    listen(typeOrEvent, handler, once = false) {
        const event = EventBusEvent.create(typeOrEvent);
        if (!this._listeners[event.type]) {
            this._listeners[event.type] = [];
        }
        this._listeners[event.type].push({ event, handler, once });
        return () => this.unlisten(event, handler);
    }

    /**
     * Unregisters an event handler
     *
     * @param {string|EventBusEvent} typeOrEvent     event
     * @param {EventHandler} handler    handler
     * @return {boolean}                true if ayn handler unregistered
     */
    unlisten(typeOrEvent, handler) {
        const event = EventBusEvent.create(typeOrEvent);
        const listeners = this._listeners[event.type];
        if (listeners == null) {
            return false;
        }
        let unlistenedCount = 0;
        for (let i = 0; i < listeners.length; ++i) {
            const listener = listeners[i];
            if (listener.event.fullType === event.fullType && listener.handler === handler) {
                listeners.splice(i, 1);
                i--;
                unlistenedCount++;
            }
        }
        if (listeners.length === 0) {
            delete this._listeners[event.type]
        }

        return unlistenedCount > 0;
    }

    /**
     * Returns true if event handler is registered
     *
     * @param {string|EventBusEvent} typeOrEvent     event
     * @param {EventHandler} theHandler    handler
     * @return {boolean}
     */
    has(typeOrEvent, theHandler) {
        const targetEvent = EventBusEvent.create(typeOrEvent);
        const listeners = this._listeners[targetEvent.type];
        if (!listeners) {
            return false;
        }
        const hasEventHandler = listeners.some(
            ({ event, handler }) => event.fullType === targetEvent.fullType && handler === theHandler
        );

        return hasEventHandler;
    }
    
    /**
     * Returns count of registered event listener handlers
     *
     * @param {string|EventBusEvent} typeOrEvent     event
     * @return {number}
     */
    count(typeOrEvent) {
        const targetEvent = EventBusEvent.create(typeOrEvent);
        const listeners = this._listeners[targetEvent.type];
        return listeners?.length ?? 0;
    }

    /**
     * Triggers event
     *
     * @param {string|EventBusEvent} event event
     * @param {*} [data]            data
     */
    trigger(typeOrEvent, data) {
        const targetEvent = EventBusEvent.create(typeOrEvent);
        const listeners = this._listeners[targetEvent.type];
        this._callHooks(targetEvent, data);

        if (!listeners) {
            return;
        }
        for (let i = 0; i < listeners.length; ++i) {
            const { event, handler, once } = listeners[i];
            if (event.fullType === targetEvent.fullType) {
                this.callEventHandler(handler, targetEvent, data);
                if (once) {
                    listeners.splice(i, 1);
                    i--;
                }
            }
        }
    }

    /**
     * Removes all listeners
     */
    resetListeners() {
        this._listeners = Object.create(null);
    }

    /**
     * Removes all hooks
     */
    resetHooks() {
        this._hooks = new Set();
    }

    /**
     * Alias for 'resetListeners'
     * @param {boolean} [resetHooks=false]
     */
    reset(resetHooks = false) {
        this.resetListeners();
        if (resetHooks) {
            this.resetHooks();
        }
    }

    /**
     * Call event handler
     *
     * @param {EventHandler} handler        handler
     * @param {EventBusEvent} typeOrEvent     event
     * @param {any} data                  data
     */
    callEventHandler(handler, event, data) {
        handler.apply(this, [event, data]);
    }

    /**
     * Call hooks
     * @param {EventBusEvent} event
     * @param {any} data
     */
    _callHooks(event, data) {
        this._hooks.forEach((handler) => this.callEventHandler(handler, event, data));
    }
}

export default EventBus;
