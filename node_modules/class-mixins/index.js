"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Mixed = exports.mix = exports.mixin = void 0;
/**
 * Mixes properties and methods from the given mixins to the class.
 */
function mixin(ctor, ...mixins) {
    for (let _mixin of mixins) {
        if (_mixin && typeof _mixin == "object") {
            mergeIfNotExists(ctor.prototype, _mixin);
        }
        else if (typeof _mixin == "function") {
            mergeHierarchy(ctor, _mixin);
        }
        else {
            throw new TypeError("A mixin must be either an object or a function");
        }
    }
}
exports.mixin = mixin;
/**
 * A decorator used directly on the class.
 */
function mix(...mixins) {
    return function (ctor) {
        mixin(ctor, ...mixins);
    };
}
exports.mix = mix;
function Mixed(base, // must use Constructor, otherwise it will not
...mixins // pass compilation in Deno, reason is unknown.
) {
    let ctor = class extends base {
    };
    mixin(ctor, ...mixins);
    return ctor;
}
exports.Mixed = Mixed;
/**
 * Merges properties and methods only if they're missing in the class.
 */
function mergeIfNotExists(proto, source, mergeSuper = false) {
    let props = Reflect.ownKeys(source);
    for (let prop of props) {
        if (prop == "constructor") {
            continue;
        }
        else if (mergeSuper) {
            // When merging properties from super classes, the properties in the
            // base super classes has the major priority, then the mixins 
            // and their super classes share the priority from left to right.
            if (!(prop in proto)) {
                setProp(proto, source, prop);
            }
        }
        else if (!proto.hasOwnProperty(prop)) {
            setProp(proto, source, prop);
        }
    }
    return proto;
}
/**
 * Merges properties and methods across the prototype chain.
 */
function mergeHierarchy(ctor, mixin, mergeSuper = false) {
    mergeIfNotExists(ctor.prototype, mixin.prototype, mergeSuper);
    let _super = Object.getPrototypeOf(mixin);
    // Every user defined class or functions that can be instantiated have their
    // own names, if no name appears, that means the function has traveled to 
    // the root of the hierarchical tree.
    if (_super.name) {
        mergeHierarchy(ctor, _super, true);
    }
}
/**
 * Sets property for prototype based on the given source and prop name properly.
 */
function setProp(proto, source, prop) {
    let desc = Object.getOwnPropertyDescriptor(source, prop);
    if (desc) {
        Object.defineProperty(proto, prop, desc);
    }
    else {
        proto[prop] = source[prop];
    }
}
//# sourceMappingURL=index.js.map