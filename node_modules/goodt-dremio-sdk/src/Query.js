import { SDKValidationError } from './errors';
import { utils, dayjs } from './utils';

/**
 * @class
 */
class Query {
    /**
     * @typedef {Object} QueryOptions
     * @property {IQuerySchema} query       query
     * @property {Object} dimensionList     dimensionList
     */
    /**
     * Constructor
     * @param {QueryOptions} options
     */
    constructor({ query, dimensionList }) {
        this.query = query;
        this.dimensionList = dimensionList;
        this.states = [];
        this.enableDimensions(Object.keys(dimensionList));
    }
    /**
     * Активирует dimension из списка dimensionList
     * @param {Array} names     массив названий dimension
     */
    enableDimensions(names) {
        let arr = [];
        names.forEach(name => {
            let fields = this.dimensionList[name];
            if (!fields) {
                return;
            }
            arr.push({
                name,
                index: 0,
                fields,
                filters: []
            });
        });
        this.states = arr;
    }
    /**
     * Формирует query с текущим state всех активных dimension
     * @return {IQuerySchema}     query
     */
    buildQuery() {
        let query = Query.clone(this.query);
        this.states.forEach(({ name, index, fields, filters }) => {
            let field = fields[index];
            if (!field) {
                return;
            }
            let dimension = Query.createDimension({ name, field });
            Query.queryInsertUpdateDimension(query, dimension);
            filters.forEach(filter => {
                Query.queryInsertUpdateFilter(query, filter);
            });
        });
        return query;
    }
    /**
     * Проверяет, сущ. ли state для dimensionName
     * @param {String} dimensionName    название dimension
     * @return {Boolean}
     */
    dimensionStateExists(dimensionName) {
        return this.states.find(({ name }) => name == dimensionName) != null;
    }
    /**
     * Возвращает true, если dimension state первый
     * @param {String} dimensionName    название dimension
     * @return {Boolean}
     */
    dimensionStateIsFirst(dimensionName) {
        let state = this.states.find(({ name }) => name == dimensionName);
        return state ? state.index == 0 : false;
    }
    /**
     * Возвращает true, если dimension state последний
     * @param {String} dimensionName    название dimension
     * @return {Boolean}
     */
    dimensionStateIsLast(dimensionName) {
        let state = this.states.find(({ name }) => name == dimensionName);
        return state ? state.index == state.fields.length - 1 : false;
    }
    /**
     * Сдвигает тек. dimension state на шаг вперед
     * @param {String} dimensionName    название dimension
     * @param {Array} filterValue      значения filter
     * @param {String} filterType       тип filter {@link Query#FILTER_TYPE}
     * @return {Boolean}                true если удалось; false нет
     */
    dimensionStateGoNext(dimensionName, filterValue, filterType) {
        let state = this.states.find(({ name }) => dimensionName == name);
        if (!state || state.index >= state.fields.length - 1) {
            return false;
        }
        // add filter
        let filter = Query.createFilter({
            name: state.fields[state.index],
            type: filterType,
            value: filterValue
        });
        state.filters.push(filter);
        state.index++;
    }
    /**
     * Сдвигает тек. dimension state на шаг назад
     * @param {String} dimensionName    название dimension
     * @return {Boolean}                true если удалось; false нет
     */
    dimensionStateGoPrev(dimensionName) {
        let state = this.states.find(({ name }) => dimensionName == name);
        if (!state || state.index <= 0) {
            return false;
        }
        // remove filter
        state.filters.pop();
        state.index--;
        return true;
    }
    /**
     * Клонирует json-like obj
     * @param {Object} obj
     * @return {Object}
     */
    static clone(obj) {
        try {
            return JSON.parse(JSON.stringify(obj));
        } catch (e) {
            return Object.assign({}, obj);
        }
    }
    /**
     * Создает/валидирует query
     * @param {IQuerySchema} [query=null]    query для валидации
     */
    static createQuery(query = null) {
        if (query) {
            if (!Query.validateQuery(query)) {
                throw new SDKValidationError('query schema invalid');
            }
            if (!Object.keys(query[Query.KEY.FIELDS])) {
                throw new SDKValidationError(`query ${Query.KEY.FIELDS} schema invalid`);
            }
            if (!Query.validateFrom(query)) {
                throw new SDKValidationError(`query ${Query.KEY.FROM} schema invalid`);
            }
            query[Query.KEY.METRICS].forEach(el => {
                if (!Query.validateMetric(el)) {
                    throw new SDKValidationError(`query ${Query.KEY.METRICS} schema invalid`);
                }
            });
            query[Query.KEY.DIMENSIONS].forEach(el => {
                if (!Query.validateDimension(el)) {
                    throw new SDKValidationError(`query ${Query.KEY.DIMENSIONS} schema invalid`);
                }
            });
            query[Query.KEY.FILTERS].forEach(el => {
                if (!Query.validateFilter(el)) {
                    throw new SDKValidationError(`query ${Query.KEY.FILTERS} schema invalid`);
                }
            });
            query[Query.KEY.SORT].forEach(el => {
                if (!Query.validateSort(el)) {
                    throw new SDKValidationError(`query ${Query.KEY.SORT} schema invalid`);
                }
            });
        } else {
            query = {
                [Query.KEY.FIELDS]: {},
                [Query.KEY.FROM]: [],
                [Query.KEY.METRICS]: [],
                [Query.KEY.DIMENSIONS]: [],
                [Query.KEY.FILTERS]: [],
                [Query.KEY.SORT]: []
            };
        }
        return query;
    }
    /**
     * Создает/мутирует metric
     * @param {MetricOptions} options   опции
     * @param {Object} [metric=null]           metric для мутации
     */
    static createMetric({ name, type, field }, metric = null) {
        if (metric) {
            // @TODO validate ~ throw new SDKValidationError()
            if (name) {
                utils.replaceKey(metric, utils.firstKey(metric), name);
            }
            if (type) {
                let n = utils.firstKey(metric);
                utils.replaceKey(metric[n], utils.firstKey(metric[n]), type);
            }
            if (field) {
                let n = utils.firstKey(metric);
                let t = utils.firstKey(metric[n]);
                metric[n][t] = field;
            }
        } else {
            metric = { [name]: { [type]: field } };
        }
        return metric;
    }
    /**
     * @typedef {Object} DimensionOptions
     * @param {String} name?        название metric
     * @param {String} field?       название field
     */
    /**
     * Создает/мутирует dimension
     * @param {DimensionOptions} options    опции
     * @param {Object} [dimension=null]            dimension для мутации
     */
    static createDimension({ name, field }, dimension = null) {
        if (dimension) {
            // @TODO validate ~ throw new SDKValidationError()
            if (name) {
                utils.replaceKey(dimension, utils.firstKey(dimension), name);
            }
            if (field) {
                let n = utils.firstKey(dimension);
                dimension[n] = field;
            }
        } else {
            dimension = { [name]: field };
        }
        return dimension;
    }
    /**
     * Создает/мутирует filter
     * @param {FilterOptions} options    опции
     * @param {Object} [filter=null]            filter для мутации
     */
    static createFilter({ name, type, value }, filter = null) {
        if (filter) {
            // @TODO validate ~ throw new SDKValidationError()
            if (name) {
                utils.replaceKey(filter, utils.firstKey(filter), name);
            }
            if (type) {
                let n = utils.firstKey(filter);
                utils.replaceKey(filter[n], utils.firstKey(filter[n]), type);
            }
            if (value) {
                let n = utils.firstKey(filter);
                let t = utils.firstKey(filter[n]);
                filter[n][t] = value;
            }
        } else {
            filter = { [name]: { [type]: value } };
        }
        return filter;
    }
    /**
     * @typedef {Object} SortOptions
     * @param {String} name?       название metric/dimension
     * @param {String} type?       тип sort {@link Query#SORT_TYPE}
     */
    /**
     * Создает/мутирует sort
     * @param {SortOptions} options     опции
     * @param {Object} [sort=null]             sort для мутации
     */
    static createSort({ name, type }, sort = null) {
        if (sort) {
            // @TODO validate ~ throw new SDKValidationError()
            if (name) {
                utils.replaceKey(sort, utils.firstKey(sort), name);
            }
            if (type) {
                let n = utils.firstKey(sort);
                sort[n] = type;
            }
        } else {
            sort = { [name]: type };
        }
        return sort;
    }
    /**
     * Возвращает имя metric
     * @param {Object} metric
     * @return {String}
     */
    static getMetricName(metric) {
        return utils.firstKey(metric);
    }
    /**
     * Возвращает тип metric
     * @param {Object} metric
     * @return {String}
     */
    static getMetricType(metric) {
        let n = utils.firstKey(metric);
        return utils.firstKey(metric[n]);
    }
    /**
     * Возвращает field metric
     * @param {Object} metric
     * @return {String}
     */
    static getMetricField(metric) {
        let n = utils.firstKey(metric);
        let t = utils.firstKey(metric[n]);
        return metric[n][t];
    }
    /**
     * Возвращает имя dimension
     * @param {Object} dimension
     * @return {String}
     */
    static getDimensionName(dimension) {
        return utils.firstKey(dimension);
    }
    /**
     * Возвращает field dimension
     * @param {Object} dimension
     * @return {String}
     */
    static getDimensionField(dimension) {
        let n = utils.firstKey(dimension);
        return dimension[n];
    }
    /**
     * Возвращает имя filter
     * @param {Object} filter
     * @return {String}
     */
    static getFilterName(filter) {
        return utils.firstKey(filter);
    }
    /**
     * Возвращает тип filter
     * @param {Object} filter
     * @return {String}
     */
    static getFilterType(filter) {
        let n = utils.firstKey(filter);
        return utils.firstKey(filter[n]);
    }
    /**
     * Возвращает value filter
     * @param {Object} filter
     * @return {String}
     */
    static getFilterValue(filter) {
        let n = utils.firstKey(filter);
        let t = utils.firstKey(filter[n]);
        return filter[n][t];
    }
    /**
     * Возвращает имя sort
     * @param {Object} sort
     * @return {String}
     */
    static getSortName(sort) {
        return utils.firstKey(sort);
    }
    /**
     * Возвращает тип sort
     * @param {Object} sort
     * @return {String}
     */
    static getSortType(sort) {
        let n = utils.firstKey(sort);
        return sort[n];
    }
    /**
     * Добавляет/заменяет filter в query
     * @param {IQuerySchema} query      query
     * @param {Object} filter           filter
     * @return {IQuerySchema}
     */
    static queryInsertUpdateFilter(query, filter) {
        let arr = query[Query.KEY.FILTERS];
        let filterName = Query.getFilterName(filter);
        let index = arr.findIndex(el => Query.getFilterName(el) == filterName);
        if (index >= 0) {
            arr.splice(index, 1, filter);
        } else {
            arr.push(filter);
        }
        return query;
    }
    /**
     * Удаляет filter из query
     * @param {IQuerySchema} query      query
     * @param {String} name             название metric/dimension
     * @return {IQuerySchema}
     */
    static queryRemoveFilter(query, name) {
        query[Query.KEY.FILTERS] = query[Query.KEY.FILTERS].filter(
            el => Query.getFilterName(el) != name
        );
        return query;
    }
    /**
     * Удаляет все filter из query
     * @param {IQuerySchema} query    query
     * @return {IQuerySchema}
     */
    static queryRemoveAllFilters(query) {
        query[Query.KEY.FILTERS] = [];
        return query;
    }
    /**
     * Заменяет Query.FILTER_VALUE value всех фильтров
     * @param {IQuerySchema} query
     * @return {IQuerySchema}
     */
    static queryReplaceAllFilterValues(query) {
        query[Query.KEY.FILTERS].forEach(el => {
            let value = Query.getFilterValue(el).map(val => {
                for (let key in Query.FILTER_VALUE) {
                    let handler = Query.FILTER_VALUE_HANDLER[key];
                    if (Query.FILTER_VALUE[key] === val && handler) {
                        return handler();
                    }
                }
                return val;
            });
            Query.createFilter({ value }, el);
        });
        return query;
    }
    /**
     * Возвращает field name dimension
     * @param {IQuerySchema} query      query
     * @param {String} name             dimension name
     * @return {String}                 field name или null если dimension нет
     */
    static queryGetDimensionField(query, name) {
        let dimension = query[Query.KEY.DIMENSIONS].find(el => Query.getDimensionName(el) == name);
        return dimension ? dimension[name] : null;
    }
    /**
     * Добавляет/заменяет dimension в query
     * @param {IQuerySchema} query      query
     * @param {Object} dimension        dimension
     * @return {IQuerySchema}
     */
    static queryInsertUpdateDimension(query, dimension) {
        let arr = query[Query.KEY.DIMENSIONS];
        let dimensionName = Query.getDimensionName(dimension);
        let index = arr.findIndex(el => Query.getDimensionName(el) == dimensionName);
        if (index >= 0) {
            arr.splice(index, 1, dimension);
        } else {
            arr.push(dimension);
        }
        return query;
    }
    /**
     * Возвращает массив имен field
     * @param {IQuerySchema} query      query
     * @return {Array}                  массив имен field
     */
    static queryFieldNames(query) {
        return Object.keys(query[Query.KEY.FIELDS]);
    }
    /**
     * Возвращает массив имен metric в query
     * @param {IQuerySchema} query      query
     * @return {Array}                  массив имен metric
     */
    static queryMetricNames(query) {
        return query[Query.KEY.METRICS]
            .map(el => Query.getMetricName(el))
            .filter((v, i, arr) => arr.indexOf(v) === i);
    }
    /**
     * Возвращает массив имен dimension в query
     * @param {IQuerySchema} query      query
     * @return {Array}                  массив имен dimension
     */
    static queryDimensionNames(query) {
        return query[Query.KEY.DIMENSIONS]
            .map(el => Query.getDimensionName(el))
            .filter((v, i, arr) => arr.indexOf(v) === i);
    }
    /**
     * Валидирует query
     * @param {IQuerySchema} query
     * @return {Boolean}
     */
    static validateQuery(query) {
        let keys = Object.values(Query.KEY);
        let found = keys.reduce((acc, val) => (acc + query[val] ? 1 : 0), 0);
        return keys.length != found;
    }
    /**
     * Валидирует from
     * @param {IQuerySchema} query
     * @return {Boolean}
     */
    static validateFrom(query) {
        let from = query[Query.KEY.FROM];
        return Array.isArray(from) && from.length > 0;
    }
    /**
     * Валидирует metric
     * @param {Object} metric
     * @return {Boolean}
     */
    static validateMetric(metric) {
        if (!Query._validateObj(metric)) {
            return false;
        }
        let name = utils.firstKey(metric);
        let def = metric[name];
        if (!def || !Query._validateObj(def)) {
            return false;
        }
        let type = utils.firstKey(def);
        if (Object.values(Query.METRIC_TYPE).indexOf(type) < 0) {
            return false;
        }
        return typeof metric[name][type] == 'string' && metric[name][type].length > 0;
    }
    /**
     * Валидирует dimension
     * @param {Object} dimension
     * @return {Boolean}
     */
    static validateDimension(dimension) {
        if (!Query._validateObj(dimension)) {
            return false;
        }
        let name = utils.firstKey(dimension);
        return typeof dimension[name] == 'string' && dimension[name].length > 0;
    }
    /**
     * Валидирует filter
     * @param {Object} filter
     * @return {Boolean}
     */
    static validateFilter(filter) {
        if (!Query._validateObj(filter)) {
            return false;
        }
        let name = utils.firstKey(filter);
        let def = filter[name];
        if (!def || !Query._validateObj(def)) {
            return false;
        }
        let type = utils.firstKey(def);
        if (Object.values(Query.FILTER_TYPE).indexOf(type) < 0) {
            return false;
        }
        let values = filter[name][type];
        if (!Array.isArray(values) || !Query.FILTER_TYPE_VALUE_VALIDATION[type](values)) {
            return false;
        }
        return true;
    }
    /**
     * Валидирует sort
     * @param {Object} sort
     * @return {Boolean}
     */
    static validateSort(sort) {
        if (!Query._validateObj(sort)) {
            return false;
        }
        let name = utils.firstKey(sort);
        if (Object.values(Query.SORT_TYPE).indexOf(sort[name]) < 0) {
            return false;
        }
        return true;
    }
    /**
     * @private Валидирует metric/dimension/filter/sort like obj
     * @param {Object} obj
     * @return {Boolean}
     */
    static _validateObj(obj) {
        if (typeof obj !== 'object') {
            return false;
        }
        let k = utils.firstKey(obj);
        if (!k) {
            return false;
        }
        return true;
    }
}
Query.FORMAT = {
    DATE: 'YYYY-MM-DD',
    TIME: 'HH:mm:ss',
    TIMESTAMP: 'YYYY-MM-DD HH:mm:ss'
};
/**
 * @static
 * @enum {String}
 */
Query.KEY = {
    /** @member {String} */
    FIELDS: '$fields',
    /** @member {String} */
    FROM: '$from',
    /** @member {String} */
    METRICS: '$metrics',
    /** @member {String} */
    DIMENSIONS: '$dimensions',
    /** @member {String} */
    FILTERS: '$filters',
    /** @member {String} */
    SORT: '$sort'
};
/**
 * @static
 * @enum {String}
 */
Query.SORT_TYPE = {
    /** @member {String} */
    ASC: 'asc',
    /** @member {String} */
    DESC: 'desc'
};
/**
 * @static
 * @enum {String}
 */
Query.METRIC_TYPE = {
    /**
     * no aggregation
     * @member {String}
     */
    VALUE: '$v',
    /**
     * sql expression
     * @member {String}
     */
    EXPRESSION: '$exp',
    /**
     * equivalent of sql 'avg()'
     * @member {String}
     */
    AVG: '$avg',
    /**
     * equivalent of sql 'count()'
     * @member {String}
     */
    COUNT: '$count',
    /**
     * equivalent of sql 'max()'
     * @member {String}
     */
    MAX: '$max',
    /**
     * equivalent of sql 'min()'
     * @member {String}
     */
    MIN: '$min',
    /**
     * equivalent of sql 'sum()'
     * @member {String}
     */
    SUM: '$sum',
    /**
     * equivalent of mysql 'group_concat()'
     * @member {String}
     */
    GROUP_CONCAT: '$gc',
    /**
     * equivalent of mysql 'group_concat(distinct)'
     * @member {String}
     */
    GROUP_CONCAT_UNIQ: '$gcu'
};
/**
 * @static
 * @enum {String}
 */
Query.FILTER_TYPE = {
    /**
     * equivalent of sql '='
     * @member {String}
     */
    EQ: '$eq',
    /**
     * equivalent of sql '!='
     * @member {String}
     */
    EQ_NOT: '$eqn',
    /**
     * equivalent of sql 'is'
     * @member {String}
     */
    IS: '$is',
    /**
     * equivalent of sql 'is not'
     * @member {String}
     */
    IS_NOT: '$isn',
    /**
     * equivalent of sql '<'
     * @member {String}
     */
    LESS: '$lt',
    /**
     * equivalent of sql '<='
     * @member {String}
     */
    LESS_EQ: '$ltq',
    /**
     * equivalent of sql '>'
     * @member {String}
     */
    GREATER: '$gt',
    /**
     * equivalent of sql '>='
     * @member {String}
     */
    GREATER_EQ: '$gtq',
    /**
     * equivalent of sql 'in()'
     * @member {String}
     */
    IN: '$in',
    /**
     * equivalent of sql 'not in()'
     * @member {String}
     */
    IN_NOT: '$inn',
    /**
     * equivalent of sql 'between()'
     * @member {String}
     */
    BETWEEN: '$btw',
    /**
     * equivalent of sql 'not between()'
     * @member {String}
     */
    BETWEEN_NOT: '$btwn',
    /**
     * equivalent of sql 'like()'
     * @member {String}
     */
    LIKE: '$lk'
};
/**
 * @static
 * @enum {String}
 */
Query.FILTER_VALUE = {
    /** @member {String} */
    YEAR_ROLLING: '#year-rolling#',
    /** @member {String} */
    YEAR_START: '#year-start#',
    /** @member {String} */
    YEAR_END: '#year-end#',
    /** @member {String} */
    YEAR_PREV_START: '#year-prev-start#',
    /** @member {String} */
    YEAR_PREV_END: '#year-prev-end#',

    /** @member {String} */
    QUARTER_START: '#quarter-start#',
    /** @member {String} */
    QUARTER_END: '#quarter-end#',
    /** @member {String} */
    QUARTER_PY_START: '#quarter-py-start#',
    /** @member {String} */
    QUARTER_PY_END: '#quarter-py-end#',
    /** @member {String} */
    QUARTER_PREV_START: '#quarter-prev-start#',
    /** @member {String} */
    QUARTER_PREV_END: '#quarter-prev-end#',

    /** @member {String} */
    MONTH_ROLLING: '#month-rolling#',
    /** @member {String} */
    MONTH_START: '#month-start#',
    /** @member {String} */
    MONTH_END: '#month-end#',
    /** @member {String} */
    MONTH_PY_START: '#month-py-start#',
    /** @member {String} */
    MONTH_PY_END: '#month-py-end#',
    /** @member {String} */
    MONTH_PREV_START: '#month-prev-start#',
    /** @member {String} */
    MONTH_PREV_END: '#month-prev-end#',

    /** @member {String} */
    WEEK_ROLLING: '#week-rolling#',
    /** @member {String} */
    WEEK_START: '#week-start#',
    /** @member {String} */
    WEEK_END: '#week-end#',
    /** @member {String} */
    WEEK_PY_START: '#week-py-start#',
    /** @member {String} */
    WEEK_PY_END: '#week-py-end#',
    /** @member {String} */
    WEEK_PREV_START: '#week-prev-start#',
    /** @member {String} */
    WEEK_PREV_END: '#week-prev-end#',

    /** @member {String} */
    TODAY: '#today#',
    /** @member {String} */
    YESTERDAY: '#yesterday#'
};
/**
 * @static
 * @enum {String}
 */
Query.FILTER_VALUE_HANDLER = {
    /** @member {Function} */
    YEAR_ROLLING: () => dayjs().add(-365, 'd').format(Query.FORMAT.DATE),
    /** @member {Function} */
    YEAR_START: () => dayjs().startOf('year').format(Query.FORMAT.DATE),
    /** @member {Function} */
    YEAR_END: () => dayjs().endOf('year').format(Query.FORMAT.DATE),
    /** @member {Function} */
    YEAR_PREV_START: () => dayjs().add(-1, 'y').startOf('year').format(Query.FORMAT.DATE),
    /** @member {Function} */
    YEAR_PREV_END: () => dayjs().add(-1, 'y').endOf('year').format(Query.FORMAT.DATE),

    /** @member {Function} */
    QUARTER_START: () => dayjs().startOf('Q').format(Query.FORMAT.DATE),
    /** @member {Function} */
    QUARTER_END: () => dayjs().endOf('Q').format(Query.FORMAT.DATE),
    /** @member {Function} */
    QUARTER_PY_START: () => dayjs().add(-1, 'y').startOf('Q').format(Query.FORMAT.DATE),
    /** @member {Function} */
    QUARTER_PY_END: () => dayjs().add(-1, 'y').endOf('Q').format(Query.FORMAT.DATE),
    /** @member {Function} */
    QUARTER_PREV_START: () => dayjs().add(-1, 'Q').startOf('Q').format(Query.FORMAT.DATE),
    /** @member {Function} */
    QUARTER_PREV_END: () => dayjs().add(-1, 'Q').endOf('Q').format(Query.FORMAT.DATE),

    /** @member {Function} */
    MONTH_ROLLING: () => dayjs().add(-30, 'd').format(Query.FORMAT.DATE),
    /** @member {Function} */
    MONTH_START: () => dayjs().startOf('month').format(Query.FORMAT.DATE),
    /** @member {Function} */
    MONTH_END: () => dayjs().endOf('month').format(Query.FORMAT.DATE),
    /** @member {Function} */
    MONTH_PY_START: () => dayjs().add(-1, 'y').startOf('month').format(Query.FORMAT.DATE),
    /** @member {Function} */
    MONTH_PY_END: () => dayjs().add(-1, 'y').endOf('month').format(Query.FORMAT.DATE),
    /** @member {Function} */
    MONTH_PREV_START: () => dayjs().add(-1, 'M').startOf('month').format(Query.FORMAT.DATE),
    /** @member {Function} */
    MONTH_PREV_END: () => dayjs().add(-1, 'M').endOf('month').format(Query.FORMAT.DATE),

    /** @member {Function} */
    WEEK_ROLLING: () => dayjs().add(-7, 'd').format(Query.FORMAT.DATE),
    /** @member {Function} */
    WEEK_START: () => dayjs().startOf('isoWeek').format(Query.FORMAT.DATE),
    /** @member {Function} */
    WEEK_END: () => dayjs().endOf('isoWeek').format(Query.FORMAT.DATE),
    /** @member {Function} */
    WEEK_PY_START: () => dayjs().add(-1, 'y').startOf('isoWeek').format(Query.FORMAT.DATE),
    /** @member {Function} */
    WEEK_PY_END: () => dayjs().add(-1, 'y').endOf('isoWeek').format(Query.FORMAT.DATE),
    /** @member {Function} */
    WEEK_PREV_START: () =>
        dayjs().startOf('isoWeek').add(-1, 'd').startOf('isoWeek').format(Query.FORMAT.DATE),
    /** @member {Function} */
    WEEK_PREV_END: () =>
        dayjs().startOf('isoWeek').add(-1, 'd').endOf('isoWeek').format(Query.FORMAT.DATE),

    /** @member {Function} */
    TODAY: () => dayjs().format(Query.FORMAT.DATE),
    /** @member {Function} */
    YESTERDAY: () => dayjs().add(-1, 'd').format(Query.FORMAT.DATE)
};
Query.FILTER_TYPE_VALUE_VALIDATION = {
    [Query.FILTER_TYPE.EQ]: v => v.length == 1,
    [Query.FILTER_TYPE.EQ_NOT]: v => v.length == 1,
    [Query.FILTER_TYPE.IS]: v => v.length == 1,
    [Query.FILTER_TYPE.IS_NOT]: v => v.length == 1,
    [Query.FILTER_TYPE.LESS]: v => v.length == 1,
    [Query.FILTER_TYPE.LESS_EQ]: v => v.length == 1,
    [Query.FILTER_TYPE.GREATER]: v => v.length == 1,
    [Query.FILTER_TYPE.GREATER_EQ]: v => v.length == 1,
    [Query.FILTER_TYPE.IN]: v => v.length > 0,
    [Query.FILTER_TYPE.IN_NOT]: v => v.length > 0,
    [Query.FILTER_TYPE.BETWEEN]: v => v.length == 2,
    [Query.FILTER_TYPE.BETWEEN_NOT]: v => v.length == 2,
    [Query.FILTER_TYPE.LIKE]: v => v.length > 0,
    [Query.FILTER_TYPE.MAX]: v => v.length == 1,
    [Query.FILTER_TYPE.MIN]: v => v.length == 1
};

export { Query };
