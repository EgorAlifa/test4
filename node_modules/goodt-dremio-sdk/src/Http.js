import axios from 'axios';
import { SDKCancelRequestError, SDKError } from './errors';
import { hook } from './utils';

export class Http {
    constructor({ getBaseURL, getHeaders, beforeRequest, processResponseError }) {
        this._requests = [];
        this._getBaseURL = getBaseURL;
        this._setupHandlers({
             processResponseError,
        });
        this._setupAxios({ getHeaders, beforeRequest });
    }

    get baseURL() {
        return this._getBaseURL();
    }

    /**
     *
     * @private
     */
    _setupAxios({ getHeaders, beforeRequest }) {
        this._axios = axios.create();
        this._axios.interceptors.request.use(async (config = {}) => {
            if (beforeRequest != null) {
                await hook(() => beforeRequest(this));
            }
            config.headers = {
                ...config.headers,
                ...getHeaders()
            };
            return config;
        });
    }

    /**
     *
     * @private
     */
    _setupHandlers({ processResponseError }) {
        this.processResponseError = processResponseError;
        this._axiosResolveHandler = ({ data }) => {
            if (data.error != null) {
                this._handleError(data.error);
                return null;
            }
            return data;
        };

        this._axiosRejectHandler = error => {
            this._handleError(error);
        };
    }

    /**
     *
     * @param {string} url
     * @param {string} [method='get']
     * @param {object} [params]
     * @param {object} [options]
     * @return {PromiseCancelable}
     * @private
     */
    request({ url, method = 'get', params, options }) {
        const [ axiosRequest, requestCancelController ] = this._buildRequest({
            url,
            method,
            params,
            options
        });
        const responsePromise = this._axios
            .request(axiosRequest)
            .then(this._axiosResolveHandler, this._axiosRejectHandler);

        return this._cancelable(responsePromise, requestCancelController);
    }

    /**
     *
     * @param {string} url
     * @param {string} [method='get']
     * @param {object} [params]
     * @param {object} [options]
     * @return {[import('axios').AxiosRequest, import('axios').CancelTokenSource]}
     * @private
     */
    _buildRequest({ url, method = 'get', params: paramsOrData, options }) {
        const source = axios.CancelToken.source();
        const isGet = method.toLocaleLowerCase() === 'get';
        const { params: optionParams, data: optionData, ...restOptions } = options;

        const requestConfig = {
            url,
            method,
            ...(isGet
                ? { params: { ...paramsOrData, ...optionParams }, data: optionData }
                : { data: { ...paramsOrData, ...optionData }, params: optionParams }),
            cancelToken: source.token,
            ...restOptions
        };

        return [ requestConfig, source ];
    }

    /**
     * Отменяет все активные запросы
     */
    dispose() {
        while (this._requests.length) {
            let p = this._requests.pop();
            p.cancel();
        }
    }

    /**
     * @private
     * @param {Promise} promise
     * @param {import('axios').CancelTokenSource} source
     * @return {PromiseCancelable}
     */
    _cancelable(promise, source) {
        let remove = () => this._removeRequest(p);
        let p = promise.finally(remove);
        p.cancel = () => {
            source.cancel('cancel');
            remove();
        };
        this._addRequest(p);
        return p;
    }

    /**
     * @private
     * @param {PromiseCancelable} promise
     */
    _addRequest(promise) {
        this._requests.push(promise);
    }

    /**
     * @private
     * @param {PromiseCancelable} promise
     */
    _removeRequest(promise) {
        this._requests = this._requests.filter(p => p !== promise);
    }

    /**
     *
     * @private
     * @param {Error} error
     * @throws {Error|SDKError}
     * @return {undefined|Error}
     */
    _handleError(error) {
        const sdkError = this._buildError(error);

        if (this.processResponseError == null) {
            throw sdkError;
        }

        const processedError = this.processResponseError(sdkError);
        if (processedError instanceof Error) {
            throw processedError;
        }

        if (processedError === null) {
            return;
        }

        throw error;
    }

    /**
     *
     * @private
     * @return {SDKError | SDKCancelRequestError}
     */
    _buildError(error) {
        // mute cancel error
        if (axios.isCancel(error)) {
            return new SDKCancelRequestError();
        }

        if (error instanceof Error === false) {
            return new SDKError(error, {
                code: 0,
                reason: error
            });
        }

        const { message } = error;
        // If non-transport error
        if (axios.isAxiosError(error) === false) {
            return new SDKError(message, {
                code: 0,
                reason: error
            });
        }

        // The request was made and the server responded with a status code
        // that falls out of the range of 2xx
        const {
            response,
            request,
            config: { url, data: requestData, method }
        } = error;

        const reason = { url, data: requestData, method };

        if (response != null) {
            const { data, status } = response;
            const errorMessage = data.error != null ? data.error : message;

            return new SDKError(errorMessage, {
                data,
                code: status,
                reason
            });
        }

        // The request was made but no response was received
        // `error.request` is an instance of XMLHttpRequest in the browser
        if (request != null) {
            return new SDKError(message, {
                code: 0,
                reason
            });
        }

        // Something happened in setting up the request that triggered an Error
        return new SDKError(message, {
            code: 0,
            reason: error
        });
    }
}