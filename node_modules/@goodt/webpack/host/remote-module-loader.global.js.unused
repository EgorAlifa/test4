/*
  Usage references:
  https://webpack.js.org/concepts/module-federation/#dynamic-remote-containers
  https://github.com/module-federation/module-federation-examples/blob/master/advanced-api/dynamic-remotes/app1/src/App.js
*/

/**
 * Resolves scope remote entry file url by `scopeName` from Global Scope
 *
 * @param {string} scopeName
 * @param {string} entryName remote entry file name
 * @param {string} remotesPath remote entries path
 * @returns {string}
 */
const resolveScopeRemoteEntry = (scopeName, { remotesPath } = {}) => {
    const remoteScopeFromConfig = window.__GOODT__.WMF.ENTRIES_MAP[scopeName];
    const remoteEntryFilename = 'remoteEntry.js'; // maybe get from webpack globals
    if (remoteScopeFromConfig != null) {
        return `${remoteScopeFromConfig.url}/${remoteEntryFilename}`;
    }
    return `${remotesPath}/${scopeName}/${remoteEntryFilename}`;
}

// side effect
// required by global scope loader
window.__GOODT__.WMF = Object.assign({
    resolveScopeRemoteEntry
}, window.__GOODT__.WMF);


/**
 * Create window-(global)-scope based loader
 * using IIFE modules
 *
 * @param {string} scope
 * @param {string} moduleName
 * @returns {function(): Promise<*>}
 */
export const createGlobalScopeLoader = async (scope, moduleName) => {
    await import('./utils/global.js');
    const { appendScript, buildModuleScopedName } = window.__GOODT__.WMF;

    // use resolvedScope, due to really widget scope is different from fake widget package scope
    // which only refers to widget package folder entry point to construct
    const serverModule = buildModuleScopedName(scope, 'Server');
    // const serverModule = buildModuleScopedName(scope, moduleName);

    // check if container already loaded
    let container = globalThis[serverModule];
    if (container == null) {
        /**
         * appends <script> with resolved by scope via `entries-endpoints.config.json` which maps
         *  scopes to container base url
         * @example {
         *         "default": {
         *           "localhost": {
         *             "url": "./widgets/basic"
         *           },
         *           "production": {
         *             "url": ""./widgets/basic"
         *           }
         *         }
         *       }
         * @type {Promise<void>}
         */
        container = appendScript(resolveScopeRemoteEntry(scope), { scope, module: 'Server' });
        // container = appendScript(resolveScopeRemoteEntry(scope), { scope, module: moduleName });
        // put globally to prevent extra <script> adding and
        // to reuse contaner loading promise
        globalThis[serverModule] = container;
    }

    return async () => {
        // if still waiting scope container
        if (container instanceof Promise) {
            await container;
            // here container/server is ready and in global scope
            container = globalThis[serverModule];
            /*
  Initializes the shared scope. Fills it with known provided modules from this build and all remotes

  Webpack unit test info: 'should provide both shared versions, but not the unused one'
  https://github.com/webpack/webpack/blob/master/test/configCases/sharing/provide-multiple-versions/index.js
*/

            await __webpack_init_sharing__('default');

            try {
                /*
  Initialize the container, it may provide shared modules

  Webpack unit test info:
    'should be able to consume different shared module version depending on context'
    'should not override an already loaded shared module version'
  https://github.com/webpack/webpack/blob/master/test/configCases/sharing/consume-multiple-versions/index.js
*/
                await container.init(__webpack_share_scopes__.default, __webpack_share_scopes__);
            } catch {
                /* catch silently if reinit failed */;
            }
        }

        // get module factory from scope `container` by `moduleName`
        const getModule = await container.get(`./${moduleName}`);

        return getModule();
    };
};
