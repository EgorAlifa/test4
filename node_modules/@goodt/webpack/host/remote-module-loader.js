/*
  Usage references:
  https://webpack.js.org/concepts/module-federation/#dynamic-remote-containers
  https://github.com/module-federation/module-federation-examples/blob/master/advanced-api/dynamic-remotes/app1/src/App.js
*/

const SCOPE_MODULE_LOADER_FACTORIES = new Map();

export const setup = async ({ remotesUrl, remotesConfig }) => {
    window.__GOODT__.WMF.REMOTE_ENTRY_FILENAME = __WMF__.REMOTE_ENTRY_FILENAME;
    window.__GOODT__.WMF.REMOTES_URL = remotesUrl ?? __WMF__.REMOTES_PATH;
    window.__GOODT__.WMF.ENTRIES_MAP = {
        ...window.__GOODT__.WMF.ENTRIES_MAP,
        ...remotesConfig
    };
}

/**
 * Resolves scope remote entry file url by `scopeName` from Global Scope
 *
 * @param {string} scopeName
 * @param {string} entryName remote entry file name
 * @param {string} remotesUrl remote entries path
 * @returns {string}
 */
const resolveScopeRemoteEntry = (scopeName, { remotesUrl } = {}) => {
    const { ENTRIES_MAP, REMOTES_URL, REMOTE_ENTRY_FILENAME } = window.__GOODT__.WMF;
    remotesUrl ??= REMOTES_URL;

    const remoteScopeFromConfig = ENTRIES_MAP[scopeName];
    const remoteUrl = remoteScopeFromConfig != null
        ? `${remoteScopeFromConfig.url}/${REMOTE_ENTRY_FILENAME}`
        : `${remotesUrl}/${scopeName}/${REMOTE_ENTRY_FILENAME}`;

    return new URL(remoteUrl, window.location).toString();
};

const REMOTE_ENTRY_QUERY_UID = Math.random().toString(16).slice(2);

const initRemoteEsmContainer = async (container) => {
    // special case for server/proxy container
    // if (typeof container.setScope === 'function') {
    //     container.setScope(scope);
    // }

    await __webpack_init_sharing__('default');

    try {
        /*
      Initialize the container, it may provide shared modules

      Webpack unit test info:
        'should be able to consume different shared module version depending on context'
        'should not override an already loaded shared module version'
      https://github.com/webpack/webpack/blob/master/test/configCases/sharing/consume-multiple-versions/index.js
    */
        await container.init(__webpack_share_scopes__.default);
    } catch {
        /!* catch silently if reinit failed *!/;
    }
};

/**
 * Create ESM-based loader
 * using js native module `import`
 *
 * @param {string} scope
 * @param {string} remotesUrl
 * @returns {function(moduleName: string): (function(): Promise<Module>)}
 */
const createScopeModuleLoaderFactory = (scope, { remotesUrl } = {}) => {
    // @todo переписать на использование Url
    const scopeRemoteEntry = resolveScopeRemoteEntry(scope, { remotesUrl }).concat(`?${REMOTE_ENTRY_QUERY_UID}`);
    let container = null;
    const getContainer = async () => {
        if (container != null) {
            return container;
        }
        container = await import(/* webpackIgnore: true */ scopeRemoteEntry);
        await initRemoteEsmContainer(container);
        return container;
    }

    return (moduleName) =>
        async () => {
            const _container = container ?? await getContainer();
            const getModule = await _container.get(`./${moduleName}`);
            return getModule();
        };
};

/**
 *
 * @param {string} scope
 * @param {string} moduleName
 * @param {string} remotesUrl
 * @returns {*|(function(): Promise<Elem>)}
 */
export const createRemoteModuleLoader = (scope, moduleName, { remotesUrl } = {}) => {
    // const isEsm ??= __WMF__.USE_ESM;
    // const createLoader = isEsm === true ? createEsmLoader : createGlobalScopeLoader;
    // remotesUrl ??= __WMF__.remotesUrl;
    let createModuleLoader = SCOPE_MODULE_LOADER_FACTORIES.get(scope);
    if (createModuleLoader == null) {
        createModuleLoader = createScopeModuleLoaderFactory(scope, { remotesUrl });
        SCOPE_MODULE_LOADER_FACTORIES.set(scope, createModuleLoader);
    }

    return createModuleLoader(moduleName);
};
