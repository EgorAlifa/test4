/**
 * В текущей реализации не используется.
 * Сохранено для возможности перехода на вариант один виджет – один репозиторий – один ремоут экспоузящий
 * свой единственный виджет
 * и использования ремоута сервера, который проксирует обращение за модулем на загрузку ремоута виджета
 * из подпапки мапящейся на имя модуля (виджета)
 * Модуль для прокси-ремоута.
 * При сборке с хранением контейнеров ремоутов в глобальном скоупе window
 */
/**
 * Remote entry for package with proxy-server
 * @module
 */
(function () {
    const { registerModule, getCurrentScope, appendScript, buildModuleScopedName, resolveScopeModuleRemoteEntry } = globalThis.__GOODT__;
    const scope = getCurrentScope();

    let WEBPACK_SHARED_SCOPES_DEFAULT;

    registerModule({
        async get(moduleName) {
            // normalize module name, clear from path prefix to use in service logic
            moduleName = moduleName.replace('./', '');
            // use resolvedScope, due to really widget scope is different from fake widget package scope
            // which only refers to widget package folder entry point to construct
            const resolvedModuleScope = buildModuleScopedName(scope, moduleName);
            let container = window[resolvedModuleScope]; // or get the container somewhere else
            if (container == null) {
                const resolvedScopeRemoteEntry = resolveScopeModuleRemoteEntry(scope, moduleName);
                container = appendScript(resolvedScopeRemoteEntry, { scope, module: moduleName });
                /**
                 * temporary set global value as script load promise
                 * to reuse it globally
                 * to prevent same module's first
                 * access add multiple <script> tags and loads in parallel
                 */
                window[resolvedModuleScope] = container;
            }

            if (container instanceof Promise) {
                await container;
                container = window[resolvedModuleScope];
                /*
                  Initialize the container, it may provide shared modules

                  Webpack unit test info:
                    'should be able to consume different shared module version depending on context'
                    'should not override an already loaded shared module version'
                  https://github.com/webpack/webpack/blob/master/test/configCases/sharing/consume-multiple-versions/index.js
                */
                try {
                    await container.init(WEBPACK_SHARED_SCOPES_DEFAULT);
                } catch {
                    /* catch silently if reinit failed */
                }
            }

            return container.get(`./${moduleName}`);
        },
        /**
         *
         * @param sharedScopes
         */
        init(sharedScopes) {
            // saves webpack shared scope to provide it to widgets
            WEBPACK_SHARED_SCOPES_DEFAULT = sharedScopes;
        }
    });
})();
