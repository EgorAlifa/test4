/**
 * В текущей реализации не используется.
 * Сохранено для возможности перехода на вариант один виджет – один репозиторий – один ремоут контейнер
 * экспоузящий свой единственный виджет
 * и использования ремоут-контейнера-сервера, который проксирует обращение за модулем на загрузку ремоута виджета
 * из контейнера в подпапке маgпящейся на имя модуля (виджета)
 * Для ESM сборки с хранением контейнеров ремоутов в модулях
 */
/**
 * Remote entry for package with proxy-server
 *
 * @module
 */
let WEBPACK_SHARED_SCOPES_DEFAULT;
let WEBPACK_SHARED_SCOPES;
let SCOPE = 'unknown';

export const setScope = (scope) => { SCOPE = scope };

export async function get(moduleName) {
    const { importModule, resolveScopeModuleRemoteEntry, } = globalThis.__GOODT__;

    // normalize module name, clear from path prefix to use in service logic
    moduleName = moduleName.replace('./', '');
    // use resolvedScope, due to really widget scope is different from fake widget package scope
    // which only refers to widget package folder entry point to construct
    const resolvedScopeRemoteEntry = resolveScopeModuleRemoteEntry(SCOPE, moduleName);
    const container = await importModule(resolvedScopeRemoteEntry);

    if (container == null) {
        // some error logic
        return null;
    }

    try {
        await container.init(WEBPACK_SHARED_SCOPES_DEFAULT || WEBPACK_SHARED_SCOPES.default);
    } catch(error) {
        /* catch silently if re-init failed */
        console.error(error);
    }

    return container.get(`./${moduleName}`);
}

/**
 *
 * @param sharedScopes
 */
export async function init(defaultSharedScopes, sharedScopes) {
    // saves webpack shared scope to provide it to widgets
    WEBPACK_SHARED_SCOPES_DEFAULT = defaultSharedScopes;
    WEBPACK_SHARED_SCOPES = sharedScopes;

    return Promise.resolve();
}