import {
  axios_default
} from "./chunk-M4VBMACY.js";
import {
  require_dayjs_min
} from "./chunk-QWZLMC3C.js";
import {
  __commonJS,
  __export,
  __name,
  __toESM,
  init_define_process
} from "./chunk-XVI4RBOZ.js";

// node_modules/dayjs/plugin/isoWeek.js
var require_isoWeek = __commonJS({
  "node_modules/dayjs/plugin/isoWeek.js"(exports, module) {
    init_define_process();
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).dayjs_plugin_isoWeek = t();
    }(exports, function() {
      "use strict";
      var e = "day";
      return function(t, i, s) {
        var a = /* @__PURE__ */ __name(function(t2) {
          return t2.add(4 - t2.isoWeekday(), e);
        }, "a"), d = i.prototype;
        d.isoWeekYear = function() {
          return a(this).year();
        }, d.isoWeek = function(t2) {
          if (!this.$utils().u(t2))
            return this.add(7 * (t2 - this.isoWeek()), e);
          var i2, d2, n2, o, r = a(this), u = (i2 = this.isoWeekYear(), d2 = this.$u, n2 = (d2 ? s.utc : s)().year(i2).startOf("year"), o = 4 - n2.isoWeekday(), n2.isoWeekday() > 4 && (o += 7), n2.add(o, e));
          return r.diff(u, "week") + 1;
        }, d.isoWeekday = function(e2) {
          return this.$utils().u(e2) ? this.day() || 7 : this.day(this.day() % 7 ? e2 : e2 - 7);
        };
        var n = d.startOf;
        d.startOf = function(e2, t2) {
          var i2 = this.$utils(), s2 = !!i2.u(t2) || t2;
          return "isoweek" === i2.p(e2) ? s2 ? this.date(this.date() - (this.isoWeekday() - 1)).startOf("day") : this.date(this.date() - 1 - (this.isoWeekday() - 1) + 7).endOf("day") : n.bind(this)(e2, t2);
        };
      };
    });
  }
});

// node_modules/dayjs/plugin/quarterOfYear.js
var require_quarterOfYear = __commonJS({
  "node_modules/dayjs/plugin/quarterOfYear.js"(exports, module) {
    init_define_process();
    !function(t, n) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = n() : "function" == typeof define && define.amd ? define(n) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs_plugin_quarterOfYear = n();
    }(exports, function() {
      "use strict";
      var t = "month", n = "quarter";
      return function(e, i) {
        var r = i.prototype;
        r.quarter = function(t2) {
          return this.$utils().u(t2) ? Math.ceil((this.month() + 1) / 3) : this.month(this.month() % 3 + 3 * (t2 - 1));
        };
        var s = r.add;
        r.add = function(e2, i2) {
          return e2 = Number(e2), this.$utils().p(i2) === n ? this.add(3 * e2, t) : s.bind(this)(e2, i2);
        };
        var u = r.startOf;
        r.startOf = function(e2, i2) {
          var r2 = this.$utils(), s2 = !!r2.u(i2) || i2;
          if (r2.p(e2) === n) {
            var o = this.quarter() - 1;
            return s2 ? this.month(3 * o).startOf(t).startOf("day") : this.month(3 * o + 2).endOf(t).endOf("day");
          }
          return u.bind(this)(e2, i2);
        };
      };
    });
  }
});

// dep:goodt-dremio-sdk
init_define_process();

// node_modules/goodt-dremio-sdk/src/sdk.js
init_define_process();

// node_modules/goodt-dremio-sdk/src/errors.js
var errors_exports = {};
__export(errors_exports, {
  SDKCancelRequestError: () => SDKCancelRequestError,
  SDKError: () => SDKError,
  SDKValidationError: () => SDKValidationError
});
init_define_process();
var SDKError = class extends Error {
  constructor(message, { code, data, reason } = {}) {
    super();
    this.name = "SDKError";
    this.message = message;
    this.code = code;
    this.data = data;
    this.reason = reason;
  }
};
__name(SDKError, "SDKError");
var SDKCancelRequestError = class extends Error {
  constructor() {
    super();
    this.name = "SDKCancelRequestError";
    this.isCancel = true;
  }
};
__name(SDKCancelRequestError, "SDKCancelRequestError");
var SDKValidationError = class extends SDKError {
  constructor(message, { reason } = {}) {
    super(message, { reason });
    this.name = "SDKValidationError";
  }
};
__name(SDKValidationError, "SDKValidationError");

// node_modules/goodt-dremio-sdk/src/Query.js
init_define_process();

// node_modules/goodt-dremio-sdk/src/utils.js
init_define_process();
var import_dayjs = __toESM(require_dayjs_min());
var import_isoWeek = __toESM(require_isoWeek());
var import_quarterOfYear = __toESM(require_quarterOfYear());
import_dayjs.default.extend(import_isoWeek.default);
import_dayjs.default.extend(import_quarterOfYear.default);
var utils = {
  firstKey(obj) {
    let k = Object.keys(obj);
    return k.length ? k[0] : null;
  },
  replaceKey(obj, keyOld, keyNew) {
    obj[keyNew] = obj[keyOld];
    if (keyOld != keyNew) {
      delete obj[keyOld];
    }
    return obj;
  }
};
var buildBaseURL = /* @__PURE__ */ __name(({ host }) => `${host}/api`, "buildBaseURL");
var buildRequestHeaders = /* @__PURE__ */ __name(({ authToken, admin }) => {
  const headers = {};
  if ([void 0, null, ""].includes(authToken) === false) {
    headers["Authorization"] = `Bearer ${authToken}`;
    headers["token"] = authToken;
  }
  if (admin === true) {
    headers["x-dremio-admin"] = 1;
  }
  return headers;
}, "buildRequestHeaders");
var hook = /* @__PURE__ */ __name((func) => {
  return func ? Promise.resolve(func()) : Promise.resolve();
}, "hook");
var buildRequestConfig = /* @__PURE__ */ __name(({
  action,
  pathParams = {},
  params = {},
  queryParams,
  options = {}
}) => {
  const {
    url: initialUrl = "",
    options: defaultOptions = {},
    params: defaultParams,
    data: defaultData
  } = action;
  const url = Object.entries(pathParams).reduce(
    (finalUrl, [key, value]) => finalUrl.replace(new RegExp(`:${key}`, "g"), String(value)),
    initialUrl
  );
  const {
    baseURL: host,
    method
  } = defaultOptions;
  if (host != null) {
    defaultOptions.baseURL = buildBaseURL({ host });
  }
  const mergedOptions = {
    ...defaultOptions,
    ...options,
    params: {
      ...defaultParams,
      ...queryParams,
      ...options.params
    },
    data: {
      ...defaultData,
      ...options.data
    }
  };
  return {
    url,
    ...method && { method },
    params,
    options: mergedOptions
  };
}, "buildRequestConfig");

// node_modules/goodt-dremio-sdk/src/Query.js
var Query = class {
  constructor({ query, dimensionList }) {
    this.query = query;
    this.dimensionList = dimensionList;
    this.states = [];
    this.enableDimensions(Object.keys(dimensionList));
  }
  enableDimensions(names) {
    let arr = [];
    names.forEach((name) => {
      let fields = this.dimensionList[name];
      if (!fields) {
        return;
      }
      arr.push({
        name,
        index: 0,
        fields,
        filters: []
      });
    });
    this.states = arr;
  }
  buildQuery() {
    let query = Query.clone(this.query);
    this.states.forEach(({ name, index, fields, filters }) => {
      let field = fields[index];
      if (!field) {
        return;
      }
      let dimension = Query.createDimension({ name, field });
      Query.queryInsertUpdateDimension(query, dimension);
      filters.forEach((filter) => {
        Query.queryInsertUpdateFilter(query, filter);
      });
    });
    return query;
  }
  dimensionStateExists(dimensionName) {
    return this.states.find(({ name }) => name == dimensionName) != null;
  }
  dimensionStateIsFirst(dimensionName) {
    let state = this.states.find(({ name }) => name == dimensionName);
    return state ? state.index == 0 : false;
  }
  dimensionStateIsLast(dimensionName) {
    let state = this.states.find(({ name }) => name == dimensionName);
    return state ? state.index == state.fields.length - 1 : false;
  }
  dimensionStateGoNext(dimensionName, filterValue, filterType) {
    let state = this.states.find(({ name }) => dimensionName == name);
    if (!state || state.index >= state.fields.length - 1) {
      return false;
    }
    let filter = Query.createFilter({
      name: state.fields[state.index],
      type: filterType,
      value: filterValue
    });
    state.filters.push(filter);
    state.index++;
  }
  dimensionStateGoPrev(dimensionName) {
    let state = this.states.find(({ name }) => dimensionName == name);
    if (!state || state.index <= 0) {
      return false;
    }
    state.filters.pop();
    state.index--;
    return true;
  }
  static clone(obj) {
    try {
      return JSON.parse(JSON.stringify(obj));
    } catch (e) {
      return Object.assign({}, obj);
    }
  }
  static createQuery(query = null) {
    if (query) {
      if (!Query.validateQuery(query)) {
        throw new SDKValidationError("query schema invalid");
      }
      if (!Object.keys(query[Query.KEY.FIELDS])) {
        throw new SDKValidationError(`query ${Query.KEY.FIELDS} schema invalid`);
      }
      if (!Query.validateFrom(query)) {
        throw new SDKValidationError(`query ${Query.KEY.FROM} schema invalid`);
      }
      query[Query.KEY.METRICS].forEach((el) => {
        if (!Query.validateMetric(el)) {
          throw new SDKValidationError(`query ${Query.KEY.METRICS} schema invalid`);
        }
      });
      query[Query.KEY.DIMENSIONS].forEach((el) => {
        if (!Query.validateDimension(el)) {
          throw new SDKValidationError(`query ${Query.KEY.DIMENSIONS} schema invalid`);
        }
      });
      query[Query.KEY.FILTERS].forEach((el) => {
        if (!Query.validateFilter(el)) {
          throw new SDKValidationError(`query ${Query.KEY.FILTERS} schema invalid`);
        }
      });
      query[Query.KEY.SORT].forEach((el) => {
        if (!Query.validateSort(el)) {
          throw new SDKValidationError(`query ${Query.KEY.SORT} schema invalid`);
        }
      });
    } else {
      query = {
        [Query.KEY.FIELDS]: {},
        [Query.KEY.FROM]: [],
        [Query.KEY.METRICS]: [],
        [Query.KEY.DIMENSIONS]: [],
        [Query.KEY.FILTERS]: [],
        [Query.KEY.SORT]: []
      };
    }
    return query;
  }
  static createMetric({ name, type, field }, metric = null) {
    if (metric) {
      if (name) {
        utils.replaceKey(metric, utils.firstKey(metric), name);
      }
      if (type) {
        let n = utils.firstKey(metric);
        utils.replaceKey(metric[n], utils.firstKey(metric[n]), type);
      }
      if (field) {
        let n = utils.firstKey(metric);
        let t = utils.firstKey(metric[n]);
        metric[n][t] = field;
      }
    } else {
      metric = { [name]: { [type]: field } };
    }
    return metric;
  }
  static createDimension({ name, field }, dimension = null) {
    if (dimension) {
      if (name) {
        utils.replaceKey(dimension, utils.firstKey(dimension), name);
      }
      if (field) {
        let n = utils.firstKey(dimension);
        dimension[n] = field;
      }
    } else {
      dimension = { [name]: field };
    }
    return dimension;
  }
  static createFilter({ name, type, value }, filter = null) {
    if (filter) {
      if (name) {
        utils.replaceKey(filter, utils.firstKey(filter), name);
      }
      if (type) {
        let n = utils.firstKey(filter);
        utils.replaceKey(filter[n], utils.firstKey(filter[n]), type);
      }
      if (value) {
        let n = utils.firstKey(filter);
        let t = utils.firstKey(filter[n]);
        filter[n][t] = value;
      }
    } else {
      filter = { [name]: { [type]: value } };
    }
    return filter;
  }
  static createSort({ name, type }, sort = null) {
    if (sort) {
      if (name) {
        utils.replaceKey(sort, utils.firstKey(sort), name);
      }
      if (type) {
        let n = utils.firstKey(sort);
        sort[n] = type;
      }
    } else {
      sort = { [name]: type };
    }
    return sort;
  }
  static getMetricName(metric) {
    return utils.firstKey(metric);
  }
  static getMetricType(metric) {
    let n = utils.firstKey(metric);
    return utils.firstKey(metric[n]);
  }
  static getMetricField(metric) {
    let n = utils.firstKey(metric);
    let t = utils.firstKey(metric[n]);
    return metric[n][t];
  }
  static getDimensionName(dimension) {
    return utils.firstKey(dimension);
  }
  static getDimensionField(dimension) {
    let n = utils.firstKey(dimension);
    return dimension[n];
  }
  static getFilterName(filter) {
    return utils.firstKey(filter);
  }
  static getFilterType(filter) {
    let n = utils.firstKey(filter);
    return utils.firstKey(filter[n]);
  }
  static getFilterValue(filter) {
    let n = utils.firstKey(filter);
    let t = utils.firstKey(filter[n]);
    return filter[n][t];
  }
  static getSortName(sort) {
    return utils.firstKey(sort);
  }
  static getSortType(sort) {
    let n = utils.firstKey(sort);
    return sort[n];
  }
  static queryInsertUpdateFilter(query, filter) {
    let arr = query[Query.KEY.FILTERS];
    let filterName = Query.getFilterName(filter);
    let index = arr.findIndex((el) => Query.getFilterName(el) == filterName);
    if (index >= 0) {
      arr.splice(index, 1, filter);
    } else {
      arr.push(filter);
    }
    return query;
  }
  static queryRemoveFilter(query, name) {
    query[Query.KEY.FILTERS] = query[Query.KEY.FILTERS].filter(
      (el) => Query.getFilterName(el) != name
    );
    return query;
  }
  static queryRemoveAllFilters(query) {
    query[Query.KEY.FILTERS] = [];
    return query;
  }
  static queryReplaceAllFilterValues(query) {
    query[Query.KEY.FILTERS].forEach((el) => {
      let value = Query.getFilterValue(el).map((val) => {
        for (let key in Query.FILTER_VALUE) {
          let handler = Query.FILTER_VALUE_HANDLER[key];
          if (Query.FILTER_VALUE[key] === val && handler) {
            return handler();
          }
        }
        return val;
      });
      Query.createFilter({ value }, el);
    });
    return query;
  }
  static queryGetDimensionField(query, name) {
    let dimension = query[Query.KEY.DIMENSIONS].find((el) => Query.getDimensionName(el) == name);
    return dimension ? dimension[name] : null;
  }
  static queryInsertUpdateDimension(query, dimension) {
    let arr = query[Query.KEY.DIMENSIONS];
    let dimensionName = Query.getDimensionName(dimension);
    let index = arr.findIndex((el) => Query.getDimensionName(el) == dimensionName);
    if (index >= 0) {
      arr.splice(index, 1, dimension);
    } else {
      arr.push(dimension);
    }
    return query;
  }
  static queryFieldNames(query) {
    return Object.keys(query[Query.KEY.FIELDS]);
  }
  static queryMetricNames(query) {
    return query[Query.KEY.METRICS].map((el) => Query.getMetricName(el)).filter((v, i, arr) => arr.indexOf(v) === i);
  }
  static queryDimensionNames(query) {
    return query[Query.KEY.DIMENSIONS].map((el) => Query.getDimensionName(el)).filter((v, i, arr) => arr.indexOf(v) === i);
  }
  static validateQuery(query) {
    let keys = Object.values(Query.KEY);
    let found = keys.reduce((acc, val) => acc + query[val] ? 1 : 0, 0);
    return keys.length != found;
  }
  static validateFrom(query) {
    let from = query[Query.KEY.FROM];
    return Array.isArray(from) && from.length > 0;
  }
  static validateMetric(metric) {
    if (!Query._validateObj(metric)) {
      return false;
    }
    let name = utils.firstKey(metric);
    let def = metric[name];
    if (!def || !Query._validateObj(def)) {
      return false;
    }
    let type = utils.firstKey(def);
    if (Object.values(Query.METRIC_TYPE).indexOf(type) < 0) {
      return false;
    }
    return typeof metric[name][type] == "string" && metric[name][type].length > 0;
  }
  static validateDimension(dimension) {
    if (!Query._validateObj(dimension)) {
      return false;
    }
    let name = utils.firstKey(dimension);
    return typeof dimension[name] == "string" && dimension[name].length > 0;
  }
  static validateFilter(filter) {
    if (!Query._validateObj(filter)) {
      return false;
    }
    let name = utils.firstKey(filter);
    let def = filter[name];
    if (!def || !Query._validateObj(def)) {
      return false;
    }
    let type = utils.firstKey(def);
    if (Object.values(Query.FILTER_TYPE).indexOf(type) < 0) {
      return false;
    }
    let values = filter[name][type];
    if (!Array.isArray(values) || !Query.FILTER_TYPE_VALUE_VALIDATION[type](values)) {
      return false;
    }
    return true;
  }
  static validateSort(sort) {
    if (!Query._validateObj(sort)) {
      return false;
    }
    let name = utils.firstKey(sort);
    if (Object.values(Query.SORT_TYPE).indexOf(sort[name]) < 0) {
      return false;
    }
    return true;
  }
  static _validateObj(obj) {
    if (typeof obj !== "object") {
      return false;
    }
    let k = utils.firstKey(obj);
    if (!k) {
      return false;
    }
    return true;
  }
};
__name(Query, "Query");
Query.FORMAT = {
  DATE: "YYYY-MM-DD",
  TIME: "HH:mm:ss",
  TIMESTAMP: "YYYY-MM-DD HH:mm:ss"
};
Query.KEY = {
  FIELDS: "$fields",
  FROM: "$from",
  METRICS: "$metrics",
  DIMENSIONS: "$dimensions",
  FILTERS: "$filters",
  SORT: "$sort"
};
Query.SORT_TYPE = {
  ASC: "asc",
  DESC: "desc"
};
Query.METRIC_TYPE = {
  VALUE: "$v",
  EXPRESSION: "$exp",
  AVG: "$avg",
  COUNT: "$count",
  MAX: "$max",
  MIN: "$min",
  SUM: "$sum",
  GROUP_CONCAT: "$gc",
  GROUP_CONCAT_UNIQ: "$gcu"
};
Query.FILTER_TYPE = {
  EQ: "$eq",
  EQ_NOT: "$eqn",
  IS: "$is",
  IS_NOT: "$isn",
  LESS: "$lt",
  LESS_EQ: "$ltq",
  GREATER: "$gt",
  GREATER_EQ: "$gtq",
  IN: "$in",
  IN_NOT: "$inn",
  BETWEEN: "$btw",
  BETWEEN_NOT: "$btwn",
  LIKE: "$lk"
};
Query.FILTER_VALUE = {
  YEAR_ROLLING: "#year-rolling#",
  YEAR_START: "#year-start#",
  YEAR_END: "#year-end#",
  YEAR_PREV_START: "#year-prev-start#",
  YEAR_PREV_END: "#year-prev-end#",
  QUARTER_START: "#quarter-start#",
  QUARTER_END: "#quarter-end#",
  QUARTER_PY_START: "#quarter-py-start#",
  QUARTER_PY_END: "#quarter-py-end#",
  QUARTER_PREV_START: "#quarter-prev-start#",
  QUARTER_PREV_END: "#quarter-prev-end#",
  MONTH_ROLLING: "#month-rolling#",
  MONTH_START: "#month-start#",
  MONTH_END: "#month-end#",
  MONTH_PY_START: "#month-py-start#",
  MONTH_PY_END: "#month-py-end#",
  MONTH_PREV_START: "#month-prev-start#",
  MONTH_PREV_END: "#month-prev-end#",
  WEEK_ROLLING: "#week-rolling#",
  WEEK_START: "#week-start#",
  WEEK_END: "#week-end#",
  WEEK_PY_START: "#week-py-start#",
  WEEK_PY_END: "#week-py-end#",
  WEEK_PREV_START: "#week-prev-start#",
  WEEK_PREV_END: "#week-prev-end#",
  TODAY: "#today#",
  YESTERDAY: "#yesterday#"
};
Query.FILTER_VALUE_HANDLER = {
  YEAR_ROLLING: () => (0, import_dayjs.default)().add(-365, "d").format(Query.FORMAT.DATE),
  YEAR_START: () => (0, import_dayjs.default)().startOf("year").format(Query.FORMAT.DATE),
  YEAR_END: () => (0, import_dayjs.default)().endOf("year").format(Query.FORMAT.DATE),
  YEAR_PREV_START: () => (0, import_dayjs.default)().add(-1, "y").startOf("year").format(Query.FORMAT.DATE),
  YEAR_PREV_END: () => (0, import_dayjs.default)().add(-1, "y").endOf("year").format(Query.FORMAT.DATE),
  QUARTER_START: () => (0, import_dayjs.default)().startOf("Q").format(Query.FORMAT.DATE),
  QUARTER_END: () => (0, import_dayjs.default)().endOf("Q").format(Query.FORMAT.DATE),
  QUARTER_PY_START: () => (0, import_dayjs.default)().add(-1, "y").startOf("Q").format(Query.FORMAT.DATE),
  QUARTER_PY_END: () => (0, import_dayjs.default)().add(-1, "y").endOf("Q").format(Query.FORMAT.DATE),
  QUARTER_PREV_START: () => (0, import_dayjs.default)().add(-1, "Q").startOf("Q").format(Query.FORMAT.DATE),
  QUARTER_PREV_END: () => (0, import_dayjs.default)().add(-1, "Q").endOf("Q").format(Query.FORMAT.DATE),
  MONTH_ROLLING: () => (0, import_dayjs.default)().add(-30, "d").format(Query.FORMAT.DATE),
  MONTH_START: () => (0, import_dayjs.default)().startOf("month").format(Query.FORMAT.DATE),
  MONTH_END: () => (0, import_dayjs.default)().endOf("month").format(Query.FORMAT.DATE),
  MONTH_PY_START: () => (0, import_dayjs.default)().add(-1, "y").startOf("month").format(Query.FORMAT.DATE),
  MONTH_PY_END: () => (0, import_dayjs.default)().add(-1, "y").endOf("month").format(Query.FORMAT.DATE),
  MONTH_PREV_START: () => (0, import_dayjs.default)().add(-1, "M").startOf("month").format(Query.FORMAT.DATE),
  MONTH_PREV_END: () => (0, import_dayjs.default)().add(-1, "M").endOf("month").format(Query.FORMAT.DATE),
  WEEK_ROLLING: () => (0, import_dayjs.default)().add(-7, "d").format(Query.FORMAT.DATE),
  WEEK_START: () => (0, import_dayjs.default)().startOf("isoWeek").format(Query.FORMAT.DATE),
  WEEK_END: () => (0, import_dayjs.default)().endOf("isoWeek").format(Query.FORMAT.DATE),
  WEEK_PY_START: () => (0, import_dayjs.default)().add(-1, "y").startOf("isoWeek").format(Query.FORMAT.DATE),
  WEEK_PY_END: () => (0, import_dayjs.default)().add(-1, "y").endOf("isoWeek").format(Query.FORMAT.DATE),
  WEEK_PREV_START: () => (0, import_dayjs.default)().startOf("isoWeek").add(-1, "d").startOf("isoWeek").format(Query.FORMAT.DATE),
  WEEK_PREV_END: () => (0, import_dayjs.default)().startOf("isoWeek").add(-1, "d").endOf("isoWeek").format(Query.FORMAT.DATE),
  TODAY: () => (0, import_dayjs.default)().format(Query.FORMAT.DATE),
  YESTERDAY: () => (0, import_dayjs.default)().add(-1, "d").format(Query.FORMAT.DATE)
};
Query.FILTER_TYPE_VALUE_VALIDATION = {
  [Query.FILTER_TYPE.EQ]: (v) => v.length == 1,
  [Query.FILTER_TYPE.EQ_NOT]: (v) => v.length == 1,
  [Query.FILTER_TYPE.IS]: (v) => v.length == 1,
  [Query.FILTER_TYPE.IS_NOT]: (v) => v.length == 1,
  [Query.FILTER_TYPE.LESS]: (v) => v.length == 1,
  [Query.FILTER_TYPE.LESS_EQ]: (v) => v.length == 1,
  [Query.FILTER_TYPE.GREATER]: (v) => v.length == 1,
  [Query.FILTER_TYPE.GREATER_EQ]: (v) => v.length == 1,
  [Query.FILTER_TYPE.IN]: (v) => v.length > 0,
  [Query.FILTER_TYPE.IN_NOT]: (v) => v.length > 0,
  [Query.FILTER_TYPE.BETWEEN]: (v) => v.length == 2,
  [Query.FILTER_TYPE.BETWEEN_NOT]: (v) => v.length == 2,
  [Query.FILTER_TYPE.LIKE]: (v) => v.length > 0,
  [Query.FILTER_TYPE.MAX]: (v) => v.length == 1,
  [Query.FILTER_TYPE.MIN]: (v) => v.length == 1
};

// node_modules/goodt-dremio-sdk/src/Http.js
init_define_process();
var Http = class {
  constructor({ getBaseURL, getHeaders, beforeRequest, processResponseError }) {
    this._requests = [];
    this._getBaseURL = getBaseURL;
    this._setupHandlers({
      processResponseError
    });
    this._setupAxios({ getHeaders, beforeRequest });
  }
  get baseURL() {
    return this._getBaseURL();
  }
  _setupAxios({ getHeaders, beforeRequest }) {
    this._axios = axios_default.create();
    this._axios.interceptors.request.use(async (config = {}) => {
      if (beforeRequest != null) {
        await hook(() => beforeRequest(this));
      }
      config.headers = {
        ...config.headers,
        ...getHeaders()
      };
      return config;
    });
  }
  _setupHandlers({ processResponseError }) {
    this.processResponseError = processResponseError;
    this._axiosResolveHandler = ({ data }) => {
      if (data.error != null) {
        this._handleError(data.error);
        return null;
      }
      return data;
    };
    this._axiosRejectHandler = (error) => {
      this._handleError(error);
    };
  }
  request({ url, method = "get", params, options }) {
    const [axiosRequest, requestCancelController] = this._buildRequest({
      url,
      method,
      params,
      options
    });
    const responsePromise = this._axios.request(axiosRequest).then(this._axiosResolveHandler, this._axiosRejectHandler);
    return this._cancelable(responsePromise, requestCancelController);
  }
  _buildRequest({ url, method = "get", params: paramsOrData, options }) {
    const source = axios_default.CancelToken.source();
    const isGet = method.toLocaleLowerCase() === "get";
    const { params: optionParams, data: optionData, ...restOptions } = options;
    const requestConfig = {
      url,
      method,
      ...isGet ? { params: { ...paramsOrData, ...optionParams }, data: optionData } : { data: { ...paramsOrData, ...optionData }, params: optionParams },
      cancelToken: source.token,
      ...restOptions
    };
    return [requestConfig, source];
  }
  dispose() {
    while (this._requests.length) {
      let p = this._requests.pop();
      p.cancel();
    }
  }
  _cancelable(promise, source) {
    let remove = /* @__PURE__ */ __name(() => this._removeRequest(p), "remove");
    let p = promise.finally(remove);
    p.cancel = () => {
      source.cancel("cancel");
      remove();
    };
    this._addRequest(p);
    return p;
  }
  _addRequest(promise) {
    this._requests.push(promise);
  }
  _removeRequest(promise) {
    this._requests = this._requests.filter((p) => p !== promise);
  }
  _handleError(error) {
    const sdkError = this._buildError(error);
    if (this.processResponseError == null) {
      throw sdkError;
    }
    const processedError = this.processResponseError(sdkError);
    if (processedError instanceof Error) {
      throw processedError;
    }
    if (processedError === null) {
      return;
    }
    throw error;
  }
  _buildError(error) {
    if (axios_default.isCancel(error)) {
      return new SDKCancelRequestError();
    }
    if (error instanceof Error === false) {
      return new SDKError(error, {
        code: 0,
        reason: error
      });
    }
    const { message } = error;
    if (axios_default.isAxiosError(error) === false) {
      return new SDKError(message, {
        code: 0,
        reason: error
      });
    }
    const {
      response,
      request,
      config: { url, data: requestData, method }
    } = error;
    const reason = { url, data: requestData, method };
    if (response != null) {
      const { data, status } = response;
      const errorMessage = data.error != null ? data.error : message;
      return new SDKError(errorMessage, {
        data,
        code: status,
        reason
      });
    }
    if (request != null) {
      return new SDKError(message, {
        code: 0,
        reason
      });
    }
    return new SDKError(message, {
      code: 0,
      reason: error
    });
  }
};
__name(Http, "Http");

// node_modules/goodt-dremio-sdk/src/constants.js
init_define_process();
var Dremio = {
  DATASET_TYPE: {
    VIRTUAL: "VIRTUAL",
    PROMOTED: "PROMOTED",
    DIRECT: "DIRECT"
  },
  CONTAINER_TYPE: {
    SPACE: "SPACE",
    SOURCE: "SOURCE",
    FOLDER: "FOLDER",
    HOME: "HOME"
  },
  JOB_STATUS: {
    NOT_SUBMITTED: "NOT_SUBMITTED",
    STARTING: "STARTING",
    RUNNING: "RUNNING",
    COMPLETED: "COMPLETED",
    CANCELED: "CANCELED",
    FAILED: "FAILED",
    CANCELLATION_REQUESTED: "CANCELLATION_REQUESTED",
    ENQUEUED: "ENQUEUED"
  },
  SOURCE_TYPE: {
    AMAZONELASTIC: "Amazon Elasticsearch Service",
    REDSHIFT: "Amazon Redshift",
    S3: "Amazon S3",
    ADLS: "Azure Data Lake Storage Gen1",
    AZURE_STORAGE: "Azure Storage",
    ELASTIC: "Elasticsearch",
    HDFS: "HDFS",
    HIVE: "Hive",
    MAPRFS: "MapR-FS",
    MSSQL: "Microsoft SQL Server",
    MONGO: "MongoDB",
    MYSQL: "MySQL",
    NAS: "NAS",
    ORACLE: "Oracle",
    POSTGRES: "PostgreSQL"
  }
};

// node_modules/goodt-dremio-sdk/src/sdk.js
var DataApiActions = /* @__PURE__ */ __name(({ connection, host: baseURL }) => ({
  DREMIO_URL: {
    url: "v1/dremio-url",
    params: {
      connection
    },
    options: {
      baseURL,
      method: "get"
    }
  },
  PERMISSIONS: {
    url: "v1/permissions",
    params: {
      connection
    },
    options: {
      baseURL,
      method: "get"
    }
  },
  PERMISSIONS_INFO: {
    url: "v1/permissions-info",
    params: {
      connection
    },
    options: {
      baseURL,
      method: "get"
    }
  },
  CATALOG: {
    url: "v1/catalog",
    params: {
      connection
    },
    options: {
      baseURL,
      method: "get"
    }
  },
  CATALOG_BY_PATH: {
    url: "v1/catalog/by-path",
    data: {
      connection
    },
    options: {
      baseURL,
      method: "post"
    }
  },
  DATA: {
    url: "v1/data",
    data: {
      connection
    },
    options: {
      baseURL,
      method: "post"
    }
  }
}), "DataApiActions");
var ConfigDefaults = {
  host: "http://localhost",
  connection: null,
  replaceFilterValues: true,
  authToken: null,
  admin: false,
  beforeRequest: null,
  processResponseError: null,
  processResponseResult: null
};
var SDK = class {
  constructor(config) {
    this.config = { ...ConfigDefaults, ...config };
    const {
      beforeRequest,
      processResponseError
    } = this.config;
    this.transport = new Http({
      beforeRequest,
      processResponseError,
      getHeaders: () => buildRequestHeaders(this.config),
      getBaseURL: () => this.config.host
    });
    this.processResponseResult = this.config.processResponseResult;
  }
  getDremioUrl() {
    return this.requestAction({ action: DataApiActions(this.config).DREMIO_URL });
  }
  getPermissions() {
    return this.requestAction({ action: DataApiActions(this.config).PERMISSIONS });
  }
  getPermissionsInfo() {
    return this.requestAction({ action: DataApiActions(this.config).PERMISSIONS_INFO });
  }
  getRootEntities() {
    return this.requestAction({ action: DataApiActions(this.config).CATALOG });
  }
  getEntityByPath(path) {
    const params = { path };
    return this.requestAction({ action: DataApiActions(this.config).CATALOG_BY_PATH, params });
  }
  getData(query, offset = 0, limit = 10, debug = false) {
    if (this.config.replaceFilterValues) {
      query = Query.queryReplaceAllFilterValues(Query.clone(query));
    }
    const params = {
      query,
      limit,
      offset
    };
    if (debug) {
      params.debug = debug;
    }
    return this.requestAction({ action: DataApiActions(this.config).DATA, params }).then((result) => {
      if (result == null) {
        return result;
      }
      if (this.processResponseResult == null) {
        return result;
      }
      return this.processResponseResult(result);
    });
  }
  cancelActiveRequests() {
    this.transport.dispose();
  }
  requestAction({ action, pathParams = {}, params = {}, queryParams, options }) {
    return this.transport.request(
      buildRequestConfig({ action, pathParams, params, queryParams, options })
    );
  }
};
__name(SDK, "SDK");
export {
  Dremio,
  errors_exports as Errors,
  Query,
  SDK
};
//# sourceMappingURL=goodt-dremio-sdk.js.map
