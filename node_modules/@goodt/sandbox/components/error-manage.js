import Vue from 'vue';
import errorStackFilter from 'error-stack-filter';
import {
    DefaultErrorHandlers,
    ErrorService,
    ErrorManager,
    createErrorInfoHandleStrategy,
    ConsoleLogger
} from '@goodt-common/error-service';
import { WidgetDebugMessage } from '@goodt-wcore/errors';
import { DremioPresentableError } from '@goodt-common/dremio';

const isDebugMode = () => {
    return Vue.config.silent === false;
}

/**
 *
 * @param {import('@goodt-wcore/managers/ErrorManager').ErrorInfo} errorInfo
 * @this {import('@goodt-wcore/managers/ErrorManager').ErrorInfoHandleStrategy}
 * @return {null|ErrorInfo}
 * @constructor
 */
const errorInfoHandler = function errorInfoHandler(errorInfo) {
    const { type, scope, error, context } = errorInfo;
    if (error.isCancel) {
        return null;
    }

    if (error instanceof DremioPresentableError) {
        error.setContext(context);
    }

    if (error instanceof WidgetDebugMessage) {
        if (error.type === 'info') {
            this.logger.info(error.message);
            return null;
        }
        if (error.type === 'warning') {
            this.logger.warn(error.message);
            return null;
        }
        this.logger.error(error);
        return null;
    }

    if (type === ErrorManager.ErrorInfoType.CoreWarning) {
        this.logger.warn(error.message);
        return null;
    }

    if (scope !== ErrorService.Scope.GLOBAL) {
        // Error.captureStackTrace(error, Vue.config.errorHandler);
        // непойманная никем ошибка, выброшенная ранее глобально
        if (error.scope === ErrorService.Scope.GLOBAL) {
            return null;
        }
        this.logger.error(error);
    }

    if (type === ErrorManager.ErrorInfoType.SilentError) {
        return null;
    }

    if (type != null) {
        return errorInfo;
    }

    return null;
};

/**
 *
 */
export const initGlobalErrorHandle = () => {
    // filter/ignore `node_modules` sources except goodt = ^@g
    errorStackFilter().setIgnoreFiles([ /\/node_modules\/([^@g])/, /lang\.js$/ ], 100);

    const [ { instance: errorService }, { instance: errorManager } ] = [ ErrorService, ErrorManager ];

    const strategy = createErrorInfoHandleStrategy({ handler: errorInfoHandler });
    const logger = new ConsoleLogger(window.console, { isEnabled: isDebugMode });

    errorManager.setLogger(logger);
    errorManager.setStrategy(strategy);
    errorService.subscribe((errorInfo) => errorManager.handle(errorInfo));

    DefaultErrorHandlers.forEach((h) => errorService.addHandler(h));

    return {
        errorManager,
        errorService
    };
};
