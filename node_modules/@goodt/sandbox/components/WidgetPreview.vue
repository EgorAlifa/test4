<template>
    <div class="mar-v-l1">
        <div class="row">
            <div class="col">
                <widget-render v-bind="renderOpts" v-if="renderOpts"></widget-render>
            </div>
            <div class="col col-auto" v-if="showPanels">
                <div class="tile scroll-y h-100" :style="panelSidebarStyle">
                    <div class="tile-body">
                        <div class="p cf">
                            <code class="pull-left text-truncate" :title="elemType">
                                {{ elemType }}
                            </code>
                        </div>
                        <!-- {panels} -->
                        <template v-for="({ component, meta: { icon, name } }, k) in panels">
                            <ui-collapse
                                v-if="isPanelVisible(name)"
                                class="p"
                                :key="`${elemType}-${k}`">
                                <template #header>
                                    <i class="mdi" :class="`mdi-${icon}`" v-if="icon"></i>
                                    {{ name }} {{  isPanelMuted(name) ? '(muted)' : '' }}
                                </template>
                                <component
                                    :is="component"
                                    :init-props="elemProps"
                                    :descriptor="elemDescriptor"
                                    :element-instance="elemInstance"
                                    @[panelEvent]="onPanelPropsChange">
                                </component>
                            </ui-collapse>
                        </template>
                        <!-- {/panels} -->
                        <ui-collapse class="p">
                            <template #header>
                                <div class="d-flex flex-v-center flex-h-space-between">
                                    <span>elem.props</span>
                                    <ui-button type="ghost" inline icon @click.stop="onCopyToClipboard">
                                        <i
                                            ref="clipboard-icon"
                                            class="mdi mdi-clipboard-plus text-large color-grey"></i>
                                    </ui-button>
                                </div>
                            </template>
                            <pre class="pre text-xsmall">{{ elemProps }}</pre>
                        </ui-collapse>
                        <ui-collapse>
                            <template #header>elem.descriptor</template>
                            <pre class="pre text-xsmall">{{ elemDescriptor }}</pre>
                        </ui-collapse>
                    </div>
                </div>
            </div>
        </div>
    </div>
</template>
<script>
import Vue from 'vue';
import cloneDeep from 'lodash/cloneDeep';
import { ElemEvent, PanelEvent } from '@goodt-wcore/core';
import { findNode } from '@goodt-common/utils';
import { UiCollapse, UiButton } from '@goodt-wcore/components';
import { StylePanelAsync, VariablePanelAsync, EventPanelAsync } from '@goodt-wcore/panels';

import WidgetRender from './WidgetRender.vue';

let ID = 0;

/**
 * @param {ElemInfoShort} child
 * @return {import('../render/render').ElemInfo}
 */
const buildElemInfo = (child) => ({
    ...child,
    id: `demo-${ID++}`,
    children: child.children.map(buildElemInfo)
});

/**
 * @typedef {object} ElemInfoShort
 * @property {string} type
 * @property {object} props
 * @property {import('vue/types/options').AsyncComponentFactory} component
 * @property {ElemInfoShort[]} children
 */
/**
 * @typedef {object} RenderOpts
 * @property {import('../render').ElemInfo} elem
 * @property {object} dataAddons
 */
export default {
    name: 'WidgetPreview',
    components: { UiCollapse, UiButton, WidgetRender },
    props: {
        /** @type {import('vue').PropOptions<ElemInfoShort>} */
        elem: {
            type: Object,
            default: null
        },
        panelSidebarStyle: {
            type: Object,
            default() {
                return { width: '23.75rem', 'max-height': '80vh' };
            }
        },
        showPanels: {
            type: Boolean,
            default: true
        },
        isEditorMode: {
            type: Boolean,
            default: true
        }
    },
    data() {
        return {
            /** @type {import('../../core/Elem').Elem} */
            elemInstance: null,
            elemDescriptor: {},
            elemProps: {},
            panels: [],
            panelEvent: PanelEvent.PROPS_CHANGE,

            /** @type {?RenderOpts} */
            renderOpts: null,
            mutedPanelNames: [],
            hiddenPanelNames: []
        };
    },
    computed: {
        /**
         * @return {string}
         */
        elemType() {
            const { elem } = this;
            return elem ? elem.type : '';
        },
        /**
         * @private
         */
        elemCtorPromise() {
            return this.elem.component()
                .then(({ default: componentOptions }) => Vue.extend(componentOptions));
        }
    },
    watch: {
        elemType: {
            handler(val) {
                if (val) {
                    const { elem } = this;
                    this.elemProps = cloneDeep(elem.props);
                    this.getElemComponentDescriptor().then((descriptor) => {
                        this.elemDescriptor = descriptor;
                        this.renderOpts = this.buildRenderOpts(elem);
                    });
                }
            },
            immediate: true
        },
        'elemInstance.descriptor.vars': {
            handler() {
                this.resolvePanelsState();
            },
            deep: true
        }
    },
    methods: {
        reset() {
            this.elemInstance = null;
            this.elemDescriptor = {};
            this.elemProps = {};
            this.panels = [];
        },
        isPanelMuted(panelName) {
            return this.mutedPanelNames.includes(panelName);
        },
        isPanelVisible(panelName) {
            return this.hiddenPanelNames.includes(panelName) === false;
        },
        resolvePanelsState() {
            if (this.elemInstance == null) {
                return;
            }
            const { descriptor, props, type } = this.elemInstance;

            this.mutedPanelNames = this.panels
                .filter(({ meta }) => meta.isMuted?.({ type, descriptor, props }) === true)
                .map(({ meta: { name } }) => name);

            this.hiddenPanelNames = this.panels
                .filter(({ meta }) => meta.isHidden?.({ type, descriptor, props }) === true)
                .map(({ meta: { name } }) => name);
        },
        /**
         * @param {ElemInfoShort} elem
         * @return {RenderOpts}
         */
        buildRenderOpts(elem) {
            const elemPatched = buildElemInfo(elem);
            const { props, ...elemAttrs } = elemPatched;
            const { elemProps, onElemMounted, onElemPropsChange } = this;
            return {
                elem: {
                    ...elemAttrs,
                    props: elemProps
                },
                dataAddons: (info) => info.id === elemAttrs.id
                    ? {
                        on: {
                            [ElemEvent.MOUNTED]: onElemMounted,
                            [ElemEvent.PROPS_CHANGE]: onElemPropsChange
                        }
                    }
                    : {
                        on: {
                            [ElemEvent.PROPS_CHANGE]: onElemPropsChange
                        }
                    }
            };
        },
        /**
         * @return {Promise<ElemDescriptor>}
         */
        async getElemComponentDescriptor() {
            return (await this.elemCtorPromise).options.data().descriptor;
        },
        /**
         *
         * @param {import('@goodt-wcore/core/Elem').ElemInstance} elemInstance
         */
        async onElemMounted(elemInstance) {
            this.elemInstance = elemInstance;

            const ElemCtor = await this.elemCtorPromise;
            ElemCtor.options.constructed();
            // new Set to back compatibility, to prevent panels duplication
            let panelModules = [...new Set([
                // elem panels
                ...ElemCtor.options.resolvePanels(),
                ...ElemCtor.options.resolvePanels({ type: 'default' }),
                StylePanelAsync,
                VariablePanelAsync,
                EventPanelAsync
            ])];
            panelModules = [...new Set(panelModules)];
            panelModules = await Promise.all(panelModules.flatMap((panel) => typeof panel === 'function' ? panel() : panel));

            let n = 0;
            this.panels = panelModules.map(({ default: ComponentOptions }) => {
                // eslint-disable-next-line no-shadow
                const PanelCtor = Vue.extend(ComponentOptions);
                // old
                const { $meta } = PanelCtor.options.data();
                // new
                const { meta } = PanelCtor.options;

                const name = meta?.name ?? $meta?.name ?? '';
                const icon = meta?.icon ?? $meta?.icon ?? '';
                const isMuted = meta?.isMuted;
                const isHidden = meta?.isHidden;
                const index = meta?.index ?? $meta?.index ?? 0;

                return {
                    meta: {
                        name: name || `${elemInstance.name} panel[${n++}]`,
                        icon: icon ? `mdi-${icon}` : 'mdi-cube-outline',
                        index,
                        isMuted,
                        isHidden
                    },
                    component: PanelCtor
                };
            }).sort(({ meta: { index: indexA } }, { meta: { index: indexB } }) => indexA - indexB);

            this.resolvePanelsState();
        },
        /**
         *
         * @param {Record<string, any>} newProps
         */
        onPanelPropsChange(newProps) {
            // @NOTE set reference as we reassign the props object (for the sake of sandbox)
            // in a real env there's no need for such approach as the arch differs
            // vuex --(props)--> panel --(new props)--> vuex --(new props)--> elem
            this.renderOpts.elem.props = this.elemProps = newProps;
        },
        /**
         * @param {import('@goodt-wcore/core/Elem').ElemInstance} elemInstance
         * @param {import('../render').ElemInfo} elem
         */
        onElemPropsChange({ id: elemId }, { props }) {
            const widget = findNode([this.renderOpts.elem], 'children', ({ id }) => id === elemId);
            this.$set(widget, 'props', props);
        },
        onCopyToClipboard() {
            const propsClip = JSON.stringify(this.elemProps, null, 2);
            const toggleClass = (token) =>
                token.split(' ').forEach((sub) => {
                    this.$refs['clipboard-icon'].classList.toggle(sub);
                });
            const toggle = () => {
                const apply = () => toggleClass('clipboard-done mdi-clipboard-check mdi-clipboard-plus');
                apply();
                setTimeout(apply, 2000);
            };
            window.navigator.clipboard.writeText(propsClip).then(toggle);
        }
    }
};
</script>

<style lang="pcss" scoped>
.clipboard-done {
    &:before {
        display: none;
    }
    &:after {
        content: 'copied';
        display: flex;
        margin-right: 8px;
        font-size: 12px;
    }
}
</style>
