/**
 * @typedef {object} CssObject
 * @property {object[]} fonts
 * @property {object} root
 * @property {string} custom
 */
/**
 * @typedef {object} ParserFormatOptions
 * @property {boolean} addComments
 * @property {number} tabSize
 */
const ParserFormatOptions = {
    addComments: true,
    tabSize: 2
};
const ParserBlockType = {
    FONTS: 'fonts',
    ROOT: 'root',
    CUSTOM: 'custom'
};
const ParserComments = {
    [ParserBlockType.FONTS]: '/* ---- custom fonts ---- */',
    [ParserBlockType.ROOT]: '/* ---- theme params ---- */',
    [ParserBlockType.CUSTOM]: '/* ----  custom css ---- */'
};

const Parser = {
    fontListReg: /@font-face\s*{\s*([^{}]+)\s*}/gm,
    rootReg: /:root\s*{\s*([^{}]+)\s*}/gm,
    cssRuleReg: /([^:]+)\s*:\s*(.+);/g,
    /** @type {ParserFormatOptions} */
    format: {},
    /**
     * @param {string} css
     * @returns {CssObject}
     */
    parse(css) {
        const source = this.parseSource(css);
        const fonts = this.parseFonts(source.fonts);
        const root = this.parseRoot(source.root);
        const { custom } = source;
        return { fonts, root, custom };
    },
    /**
     * @param {string} css
     * @returns {{ fonts:string, root:string, custom:string }}
     */
    parseSource(css) {
        const cssStripped = this.stripComments(css);
        const fontsMatches = cssStripped.match(this.fontListReg) ?? [];
        const rootMatch = cssStripped.match(this.rootReg) ?? [];
        const fonts = fontsMatches.join('\n');
        const root = rootMatch.length ? rootMatch[0] : '';
        const custom = fontsMatches
            .reduce((css, s) => css.replace(s, ''), cssStripped)
            .replace(root, '')
            .replace(/^\s*/, '');
        return { fonts, root, custom };
    },
    /**
     * @param {string} css
     * @returns {object[]}
     */
    parseFonts(css) {
        const matches = css.match(this.fontListReg);
        if (!matches) {
            return [];
        }
        return matches.map(m => this.parseCssRule(m.replace(this.fontListReg, '$1')));
    },
    /**
     * @param {string} css
     * @returns {object}
     */
    parseRoot(css) {
        const match = css.match(this.rootReg, '$1');
        const content = match ? match[0].replace(this.rootReg, '$1') : '';
        return this.parseCssRule(content);
    },
    /**
     * @param {string} ruleStr
     * @returns {object}
     */
    parseCssRule(ruleStr) {
        const props = ruleStr.matchAll(this.cssRuleReg);
        if (!props) {
            return {};
        }
        return [...props].reduce((acc, propMatch) => {
            const [, name, value] = [...propMatch].map(v => this.trim(v));
            return { ...acc, [name]: value };
        }, {});
    },
    /**
     * @param {CssObject} cssObject
     * @param {ParserFormatOptions} [format={}]
     * @returns {string}
     */
    toCss({ fonts, root, custom }, format = {}) {
        this.format = { ...ParserFormatOptions, ...format };
        const fontsSource = fonts
            .map(rule => {
                const ruleStr = Object.entries(rule).reduce((acc, [key, val]) => `${acc}\n${key}: ${val};`, '');
                return `@font-face {${ruleStr}\n}`;
            })
            .join('\n');
        const rootSourceBody = Object.entries(root).reduce((acc, [key, val]) => `${acc}\n${key}: ${val};`, '');
        const rootSource = `:root {${rootSourceBody}\n}`;
        return [
            this.formatCss(fontsSource, ParserBlockType.FONTS),
            this.formatCss(rootSource, ParserBlockType.ROOT),
            this.formatCss(custom, ParserBlockType.CUSTOM)
        ]
            .filter(v => v.length)
            .join('\n');
    },
    /**
     * @param {string} css
     * @param {string} blockType
     * @returns {string}
     */
    formatCss(css, blockType) {
        const { trim } = this;
        const { addComments, tabSize } = this.format;
        let output = css;

        if (tabSize >= 0) {
            const tab = ' '.repeat(tabSize);

            output = output
                .split('\n')
                .map(line => {
                    const lineTrimmed = trim(line);
                    return line.length > 0 && !line.match(/[{}]/) ? `${tab}${lineTrimmed}` : line;
                })
                .join('\n');
        }

        if (addComments) {
            const comment = ParserComments[blockType];
            output = [comment, output].join('\n');
        }

        return output;
    },
    /**
     * @param {string} css
     * @returns {string}
     */
    stripComments(css) {
        return Object.values(ParserComments)
            .reduce((acc, comment) => acc.replace(`${comment}\n`, ''), css)
            .replace(/^\s/, '');
    },
    /**
     * @param {string} str
     * @returns {string}
     */
    trim(str) {
        return String(str).trim();
    }
};

module.exports = { Parser };
